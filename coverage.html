
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/aske/go_fi_chart/cmd/server/main.go (0.0%)</option>

                        <option value="file1">github.com/aske/go_fi_chart/internal/api/handler.go (0.0%)</option>

                        <option value="file2">github.com/aske/go_fi_chart/internal/config/config.go (0.0%)</option>

                        <option value="file3">github.com/aske/go_fi_chart/internal/di/container.go (0.0%)</option>

                        <option value="file4">github.com/aske/go_fi_chart/internal/domain/asset/id_generator.go
                                (100.0%)
                        </option>

                        <option value="file5">github.com/aske/go_fi_chart/internal/domain/asset/memory_repository.go
                                (62.0%)
                        </option>

                        <option value="file6">github.com/aske/go_fi_chart/internal/domain/asset/model.go (29.3%)
                        </option>

                        <option value="file7">github.com/aske/go_fi_chart/internal/domain/asset/test_fixture.go
                                (88.2%)
                        </option>

                        <option value="file8">github.com/aske/go_fi_chart/internal/domain/error.go (0.0%)</option>

                        <option value="file9">github.com/aske/go_fi_chart/internal/domain/event/event.go (88.9%)
                        </option>

                        <option value="file10">
                                github.com/aske/go_fi_chart/internal/domain/gamification/memory_repository.go (78.9%)
                        </option>

                        <option value="file11">github.com/aske/go_fi_chart/internal/domain/gamification/model.go
                                (87.8%)
                        </option>

                        <option value="file12">github.com/aske/go_fi_chart/internal/domain/repository.go (0.0%)</option>

                        <option value="file13">github.com/aske/go_fi_chart/internal/domain/utils.go (0.0%)</option>

                        <option value="file14">
                                github.com/aske/go_fi_chart/internal/infrastructure/events/memory/event_bus.go (100.0%)
                        </option>

                        <option value="file15">
                                github.com/aske/go_fi_chart/internal/infrastructure/events/memory/event_store.go
                                (100.0%)
                        </option>

                        <option value="file16">github.com/aske/go_fi_chart/metrics/github/collector.go (0.0%)</option>

                        <option value="file17">github.com/aske/go_fi_chart/services/monitoring/internal/alerts/alert.go
                                (89.5%)
                        </option>

                        <option value="file18">github.com/aske/go_fi_chart/services/monitoring/internal/domain/types.go
                                (0.0%)
                        </option>

                        <option value="file19">
                                github.com/aske/go_fi_chart/services/monitoring/internal/exporters/prometheus/exporter.go
                                (93.5%)
                        </option>

                        <option value="file20">
                                github.com/aske/go_fi_chart/services/monitoring/internal/github/collector.go (0.0%)
                        </option>

                        <option value="file21">github.com/aske/go_fi_chart/services/monitoring/internal/github/types.go
                                (0.0%)
                        </option>

                        <option value="file22">
                                github.com/aske/go_fi_chart/services/monitoring/internal/metrics/collector.go (50.0%)
                        </option>

                        <option value="file23">
                                github.com/aske/go_fi_chart/services/monitoring/internal/metrics/github/collector.go
                                (84.0%)
                        </option>

                        <option value="file24">
                                github.com/aske/go_fi_chart/services/monitoring/internal/metrics/github/model.go
                                (100.0%)
                        </option>

                        <option value="file25">
                                github.com/aske/go_fi_chart/services/monitoring/internal/metrics/simple/metric.go (0.0%)
                        </option>

                        <option value="file26">github.com/aske/go_fi_chart/services/monitoring/internal/metrics/types.go
                                (0.0%)
                        </option>

                        <option value="file27">
                                github.com/aske/go_fi_chart/services/monitoring/metrics/collectors/base.go (93.8%)
                        </option>

                        <option value="file28">
                                github.com/aske/go_fi_chart/services/monitoring/metrics/collectors/simple.go (100.0%)
                        </option>

                        <option value="file29">github.com/aske/go_fi_chart/services/monitoring/metrics/domain/metric.go
                                (100.0%)
                        </option>

                        <option value="file30">github.com/aske/go_fi_chart/services/monitoring/metrics/domain/types.go
                                (100.0%)
                        </option>

                        <option value="file31">github.com/aske/go_fi_chart/services/monitoring/pkg/domain/types.go
                                (0.0%)
                        </option>

                        <option value="file32">github.com/aske/go_fi_chart/services/monitoring/pkg/health/checker.go
                                (100.0%)
                        </option>

                        <option value="file33">github.com/aske/go_fi_chart/services/monitoring/pkg/metrics/types.go
                                (0.0%)
                        </option>

                </select>
			</div>
			<div id="legend">
				<span>not tracked</span>

                    <span class="cov0">not covered</span>
                    <span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/aske/go_fi_chart/internal/api"
        "github.com/aske/go_fi_chart/internal/config"
        "github.com/aske/go_fi_chart/internal/domain/asset"
        "github.com/aske/go_fi_chart/internal/domain/gamification"
        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
)

func main() <span class="cov0" title="0">{
        log.Println("FIN-RPG 서버 시작 중...")

        // 설정 로드
        cfg := config.NewDefaultConfig()

        // 저장소 생성
        assetRepo := asset.NewMemoryAssetRepository()
        transactionRepo := asset.NewMemoryTransactionRepository()
        portfolioRepo := asset.NewMemoryPortfolioRepository()
        gamificationRepo := gamification.NewMemoryRepository()

        // API 핸들러 생성
        apiHandler := api.NewHandler(assetRepo, transactionRepo, portfolioRepo, gamificationRepo)

        // 라우터 설정
        r := chi.NewRouter()
        r.Use(middleware.Logger)
        r.Use(middleware.Recoverer)
        r.Use(middleware.RequestID)
        r.Use(middleware.RealIP)
        r.Use(middleware.Timeout(60 * time.Second))

        // 헬스 체크
        r.Get("/health", func(w http.ResponseWriter, _ *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                if _, err := w.Write([]byte("OK")); err != nil </span><span class="cov0" title="0">{
                        log.Printf("헬스 체크 응답 작성 실패: %v", err)
                }</span>
        })

        // API 라우터 그룹
        <span class="cov0" title="0">r.Route("/api", func(r chi.Router) </span><span class="cov0" title="0">{
                apiHandler.RegisterRoutes(r)
        }</span>)

        // 서버 설정
        <span class="cov0" title="0">srv := &amp;http.Server{
                Addr:              fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port),
                Handler:           r,
                ReadTimeout:       cfg.Server.ReadTimeout,
                WriteTimeout:      cfg.Server.WriteTimeout,
                IdleTimeout:       cfg.Server.IdleTimeout,
                ReadHeaderTimeout: 2 * time.Second,
        }

        // 종료 시그널 처리
        done := make(chan os.Signal, 1)
        signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                log.Printf("서버가 시작되었습니다. %s에서 대기 중...", srv.Addr)
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span
                        class="cov0" title="0">{
                        log.Fatalf("서버 시작 실패: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">&lt;-done
        log.Println("서버 종료 중...")

        ctx, cancel := context.WithTimeout(context.Background(), cfg.Server.ShutdownTimeout)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("서버 종료 실패: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("서버가 정상적으로 종료되었습니다.")</span>
}
</pre>

                <pre class="file" id="file1" style="display: none">package api

import (
        "encoding/json"
        "net/http"
        "time"

        "github.com/aske/go_fi_chart/internal/domain/asset"
        "github.com/aske/go_fi_chart/internal/domain/gamification"
        "github.com/go-chi/chi/v5"
)

// Handler API 핸들러입니다.
type Handler struct {
        assetRepo        asset.Repository
        transactionRepo  asset.TransactionRepository
        portfolioRepo    asset.PortfolioRepository
        gamificationRepo gamification.Repository
}

// NewHandler 새로운 API 핸들러를 생성합니다.
func NewHandler(
        assetRepo asset.Repository,
        transactionRepo asset.TransactionRepository,
        portfolioRepo asset.PortfolioRepository,
        gamificationRepo gamification.Repository,
) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                assetRepo:        assetRepo,
                transactionRepo:  transactionRepo,
                portfolioRepo:    portfolioRepo,
                gamificationRepo: gamificationRepo,
        }
}</span>

// RegisterRoutes 라우터에 API 핸들러를 등록합니다.
func (h *Handler) RegisterRoutes(r chi.Router) <span class="cov0" title="0">{
        // 자산 관리 API
        r.Route("/assets", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Get("/", h.ListAssets)
                r.Post("/", h.CreateAsset)
                r.Get("/{id}", h.GetAsset)
                r.Put("/{id}", h.UpdateAsset)
                r.Delete("/{id}", h.DeleteAsset)
        }</span>)

        // 거래 내역 API
        <span class="cov0" title="0">r.Route("/transactions", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Get("/", h.ListTransactions)
                r.Post("/", h.CreateTransaction)
                r.Get("/{id}", h.GetTransaction)
        }</span>)

        // 포트폴리오 API
        <span class="cov0" title="0">r.Route("/portfolios", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Get("/", h.GetPortfolio)
                r.Put("/", h.UpdatePortfolio)
        }</span>)

        // 게임화 API
        <span class="cov0" title="0">r.Route("/gamification", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Get("/profile", h.GetProfile)
                r.Get("/badges", h.ListBadges)
                r.Get("/streaks", h.ListStreaks)
                r.Get("/stats", h.GetStats)
        }</span>)
}

// 응답 헬퍼 함수
func respondJSON(w http.ResponseWriter, status int, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        if data != nil </span><span class="cov0" title="0">{
                if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>
        }
}

func respondError(w http.ResponseWriter, status int, message string) <span class="cov0" title="0">{
        respondJSON(w, status, map[string]string{"error": message})
}</span>

// 요청/응답 구조체
type CreateAssetRequest struct {
        UserID   string  `json:"userId"`
        Type     string  `json:"type"`
        Name     string  `json:"name"`
        Amount   float64 `json:"amount"`
        Currency string  `json:"currency"`
}

type UpdateAssetRequest struct {
        Name     string  `json:"name,omitempty"`
        Amount   float64 `json:"amount,omitempty"`
        Currency string  `json:"currency,omitempty"`
}

type AssetResponse struct {
        ID        string    `json:"id"`
        UserID    string    `json:"userId"`
        Type      string    `json:"type"`
        Name      string    `json:"name"`
        Amount    float64   `json:"amount"`
        Currency  string    `json:"currency"`
        CreatedAt time.Time `json:"createdAt"`
        UpdatedAt time.Time `json:"updatedAt"`
}

func (h *Handler) ListAssets(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.URL.Query().Get("userId")
        if userID == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "사용자 ID가 필요합니다")
                return
        }</span>

        <span class="cov0" title="0">assets, err := h.assetRepo.FindByUserID(r.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "자산 목록 조회 실패")
                return
        }</span>

        <span class="cov0" title="0">response := make([]AssetResponse, len(assets))
        for i, asset := range assets </span><span class="cov0" title="0">{
                response[i] = AssetResponse{
                        ID:        asset.ID,
                        UserID:    asset.UserID,
                        Type:      string(asset.Type),
                        Name:      asset.Name,
                        Amount:    asset.Amount.Amount,
                        Currency:  asset.Amount.Currency,
                        CreatedAt: asset.CreatedAt,
                        UpdatedAt: asset.UpdatedAt,
                }
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, response)</span>
}

func (h *Handler) CreateAsset(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req CreateAssetRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "잘못된 요청 형식")
                return
        }</span>

        <span class="cov0" title="0">asset := asset.NewAsset(req.UserID, asset.Type(req.Type), req.Name, req.Amount, req.Currency)
        if err := h.assetRepo.Save(r.Context(), asset); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "자산 생성 실패")
                return
        }</span>

        <span class="cov0" title="0">response := AssetResponse{
                ID:        asset.ID,
                UserID:    asset.UserID,
                Type:      string(asset.Type),
                Name:      asset.Name,
                Amount:    asset.Amount.Amount,
                Currency:  asset.Amount.Currency,
                CreatedAt: asset.CreatedAt,
                UpdatedAt: asset.UpdatedAt,
        }

        respondJSON(w, http.StatusCreated, response)</span>
}

func (h *Handler) GetAsset(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := chi.URLParam(r, "id")
        if id == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "자산 ID가 필요합니다")
                return
        }</span>

        <span class="cov0" title="0">asset, err := h.assetRepo.FindByID(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "자산을 찾을 수 없습니다")
                return
        }</span>

        <span class="cov0" title="0">response := AssetResponse{
                ID:        asset.ID,
                UserID:    asset.UserID,
                Type:      string(asset.Type),
                Name:      asset.Name,
                Amount:    asset.Amount.Amount,
                Currency:  asset.Amount.Currency,
                CreatedAt: asset.CreatedAt,
                UpdatedAt: asset.UpdatedAt,
        }

        respondJSON(w, http.StatusOK, response)</span>
}

func (h *Handler) UpdateAsset(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := chi.URLParam(r, "id")
        if id == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "자산 ID가 필요합니다")
                return
        }</span>

        <span class="cov0" title="0">var req UpdateAssetRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "잘못된 요청 형식")
                return
        }</span>

        <span class="cov0" title="0">asset, err := h.assetRepo.FindByID(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "자산을 찾을 수 없습니다")
                return
        }</span>

        <span class="cov0" title="0">if req.Name != "" </span><span class="cov0" title="0">{
                asset.Name = req.Name
        }</span>
        <span class="cov0" title="0">if req.Amount != 0 </span><span class="cov0" title="0">{
                asset.Amount.Amount = req.Amount
        }</span>
        <span class="cov0" title="0">if req.Currency != "" </span><span class="cov0" title="0">{
                asset.Amount.Currency = req.Currency
        }</span>
        <span class="cov0" title="0">asset.UpdatedAt = time.Now()

        if err := h.assetRepo.Update(r.Context(), asset); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "자산 업데이트 실패")
                return
        }</span>

        <span class="cov0" title="0">response := AssetResponse{
                ID:        asset.ID,
                UserID:    asset.UserID,
                Type:      string(asset.Type),
                Name:      asset.Name,
                Amount:    asset.Amount.Amount,
                Currency:  asset.Amount.Currency,
                CreatedAt: asset.CreatedAt,
                UpdatedAt: asset.UpdatedAt,
        }

        respondJSON(w, http.StatusOK, response)</span>
}

func (h *Handler) DeleteAsset(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := chi.URLParam(r, "id")
        if id == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "자산 ID가 필요합니다")
                return
        }</span>

        <span class="cov0" title="0">if err := h.assetRepo.Delete(r.Context(), id); err != nil </span><span class="cov0"
                                                                                                            title="0">{
                respondError(w, http.StatusInternalServerError, "자산 삭제 실패")
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusNoContent, nil)</span>
}

// 거래 내역 요청/응답 구조체
type CreateTransactionRequest struct {
        AssetID     string  `json:"assetId"`
        Type        string  `json:"type"`
        Amount      float64 `json:"amount"`
        Currency    string  `json:"currency"`
        Category    string  `json:"category"`
        Description string  `json:"description"`
}

type TransactionResponse struct {
        ID          string    `json:"id"`
        AssetID     string    `json:"assetId"`
        Type        string    `json:"type"`
        Amount      float64   `json:"amount"`
        Currency    string    `json:"currency"`
        Category    string    `json:"category"`
        Description string    `json:"description"`
        Date        time.Time `json:"date"`
        CreatedAt   time.Time `json:"createdAt"`
}

func (h *Handler) ListTransactions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        assetID := r.URL.Query().Get("assetId")
        if assetID == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "자산 ID가 필요합니다")
                return
        }</span>

        <span class="cov0" title="0">transactions, err := h.transactionRepo.FindByAssetID(r.Context(), assetID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "거래 내역 조회 실패")
                return
        }</span>

        <span class="cov0" title="0">response := make([]TransactionResponse, len(transactions))
        for i, tx := range transactions </span><span class="cov0" title="0">{
                response[i] = TransactionResponse{
                        ID:          tx.ID,
                        AssetID:     tx.AssetID,
                        Type:        string(tx.Type),
                        Amount:      tx.Amount.Amount,
                        Currency:    tx.Amount.Currency,
                        Category:    tx.Category,
                        Description: tx.Description,
                        Date:        tx.Date,
                        CreatedAt:   tx.CreatedAt,
                }
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, response)</span>
}

func (h *Handler) CreateTransaction(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req CreateTransactionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "잘못된 요청 형식")
                return
        }</span>

        // 자산 존재 여부 확인
        <span class="cov0" title="0">targetAsset, err := h.assetRepo.FindByID(r.Context(), req.AssetID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "자산을 찾을 수 없습니다")
                return
        }</span>

        // 거래 생성
        <span class="cov0" title="0">money := asset.NewMoney(req.Amount, req.Currency)
        tx, err := asset.NewTransaction(
                req.AssetID,
                asset.TransactionType(req.Type),
                money,
                req.Category,
                req.Description,
        )
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // 거래 유효성 검증
        <span class="cov0" title="0">if err := targetAsset.ValidateTransaction(tx); err != nil </span><span class="cov0"
                                                                                                            title="0">{
                respondError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // 거래 처리 및 자산 업데이트
        <span class="cov0" title="0">if err := targetAsset.ProcessTransaction(tx); err != nil </span><span class="cov0"
                                                                                                           title="0">{
                respondError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // 트랜잭션 저장
        <span class="cov0" title="0">if err := h.transactionRepo.Save(r.Context(), tx); err != nil </span><span
                                class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "거래 생성 실패")
                return
        }</span>

        // 자산 상태 저장
        <span class="cov0" title="0">if err := h.assetRepo.Update(r.Context(), targetAsset); err != nil </span><span
                                class="cov0" title="0">{
                // 롤백 처리가 필요할 수 있음
                respondError(w, http.StatusInternalServerError, "자산 상태 업데이트 실패")
                return
        }</span>

        <span class="cov0" title="0">response := TransactionResponse{
                ID:          tx.ID,
                AssetID:     tx.AssetID,
                Type:        string(tx.Type),
                Amount:      tx.Amount.Amount,
                Currency:    tx.Amount.Currency,
                Category:    tx.Category,
                Description: tx.Description,
                Date:        tx.Date,
                CreatedAt:   tx.CreatedAt,
        }

        respondJSON(w, http.StatusCreated, response)</span>
}

func (h *Handler) GetTransaction(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := chi.URLParam(r, "id")
        if id == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "거래 ID가 필요합니다")
                return
        }</span>

        <span class="cov0" title="0">tx, err := h.transactionRepo.FindByID(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "거래를 찾을 수 없습니다")
                return
        }</span>

        <span class="cov0" title="0">response := TransactionResponse{
                ID:          tx.ID,
                AssetID:     tx.AssetID,
                Type:        string(tx.Type),
                Amount:      tx.Amount.Amount,
                Currency:    tx.Amount.Currency,
                Category:    tx.Category,
                Description: tx.Description,
                Date:        tx.Date,
                CreatedAt:   tx.CreatedAt,
        }

        respondJSON(w, http.StatusOK, response)</span>
}

func (h *Handler) GetPortfolio(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        // TODO: 구현
        respondError(w, http.StatusNotImplemented, "아직 구현되지 않았습니다")
}</span>

func (h *Handler) UpdatePortfolio(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        // TODO: 구현
        respondError(w, http.StatusNotImplemented, "아직 구현되지 않았습니다")
}</span>

func (h *Handler) GetProfile(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        // TODO: 구현
        respondError(w, http.StatusNotImplemented, "아직 구현되지 않았습니다")
}</span>

func (h *Handler) ListBadges(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        // TODO: 구현
        respondError(w, http.StatusNotImplemented, "아직 구현되지 않았습니다")
}</span>

func (h *Handler) ListStreaks(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        // TODO: 구현
        respondError(w, http.StatusNotImplemented, "아직 구현되지 않았습니다")
}</span>

func (h *Handler) GetStats(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        // TODO: 구현
        respondError(w, http.StatusNotImplemented, "아직 구현되지 않았습니다")
}</span>
</pre>

                <pre class="file" id="file2" style="display: none">package config

import "time"

// Config 애플리케이션 전체 설정입니다.
type Config struct {
        Server   ServerConfig   `yaml:"server"`
        Metrics  MetricsConfig  `yaml:"metrics"`
        Database DatabaseConfig `yaml:"database"`
}

// ServerConfig HTTP 서버 설정입니다.
type ServerConfig struct {
        Host            string        `yaml:"host"`
        Port            int           `yaml:"port"`
        ReadTimeout     time.Duration `yaml:"readTimeout"`
        WriteTimeout    time.Duration `yaml:"writeTimeout"`
        IdleTimeout     time.Duration `yaml:"idleTimeout"`
        ShutdownTimeout time.Duration `yaml:"shutdownTimeout"`
}

// MetricsConfig 메트릭 설정입니다.
type MetricsConfig struct {
        Enabled         bool          `yaml:"enabled"`
        CollectInterval time.Duration `yaml:"collectInterval"`
        ExportInterval  time.Duration `yaml:"exportInterval"`
        RetentionPeriod time.Duration `yaml:"retentionPeriod"`
}

// DatabaseConfig 데이터베이스 설정입니다.
type DatabaseConfig struct {
        Driver          string        `yaml:"driver"`
        Host            string        `yaml:"host"`
        Port            int           `yaml:"port"`
        Name            string        `yaml:"name"`
        User            string        `yaml:"user"`
        Password        string        `yaml:"password"`
        ConnectTimeout  time.Duration `yaml:"connectTimeout"`
        MaxOpenConns    int           `yaml:"maxOpenConns"`
        MaxIdleConns    int           `yaml:"maxIdleConns"`
        ConnMaxLifetime time.Duration `yaml:"connMaxLifetime"`
}

// NewDefaultConfig 기본 설정값을 가진 Config를 생성합니다.
func NewDefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Server: ServerConfig{
                        Host:            "localhost",
                        Port:            8080,
                        ReadTimeout:     5 * time.Second,
                        WriteTimeout:    10 * time.Second,
                        IdleTimeout:     120 * time.Second,
                        ShutdownTimeout: 5 * time.Second,
                },
                Metrics: MetricsConfig{
                        Enabled:         true,
                        CollectInterval: 10 * time.Second,
                        ExportInterval:  30 * time.Second,
                        RetentionPeriod: 24 * time.Hour,
                },
                Database: DatabaseConfig{
                        Driver:          "postgres",
                        Host:            "localhost",
                        Port:            5432,
                        ConnectTimeout:  5 * time.Second,
                        MaxOpenConns:    25,
                        MaxIdleConns:    5,
                        ConnMaxLifetime: 5 * time.Minute,
                },
        }
}</span>
</pre>

                <pre class="file" id="file3" style="display: none">package di

import (
        "fmt"
        "reflect"
        "sync"
)

// Container 의존성 주입 컨테이너 인터페이스입니다.
type Container interface {
        // Register 의존성을 등록합니다.
        Register(name string, constructor interface{}) error
        // Resolve 의존성을 해결합니다.
        Resolve(name string) (interface{}, error)
}

// SimpleContainer 기본 의존성 주입 컨테이너 구현체입니다.
type SimpleContainer struct {
        mu           sync.RWMutex
        constructors map[string]interface{}
        instances    map[string]interface{}
}

// NewSimpleContainer 새로운 SimpleContainer를 생성합니다.
func NewSimpleContainer() *SimpleContainer <span class="cov0" title="0">{
        return &amp;SimpleContainer{
                constructors: make(map[string]interface{}),
                instances:    make(map[string]interface{}),
        }
}</span>

// Register 의존성 생성자를 등록합니다.
func (c *SimpleContainer) Register(name string, constructor interface{}) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if constructor == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("constructor cannot be nil")
        }</span>

        <span class="cov0" title="0">if _, exists := c.constructors[name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("dependency %s already registered", name)
        }</span>

        <span class="cov0" title="0">c.constructors[name] = constructor
        return nil</span>
}

// Resolve 의존성을 해결하고 인스턴스를 반환합니다.
func (c *SimpleContainer) Resolve(name string) (interface{}, error) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // 이미 생성된 인스턴스가 있는지 확인
        if instance, exists := c.instances[name]; exists </span><span class="cov0" title="0">{
                return instance, nil
        }</span>

        // 생성자 찾기
        <span class="cov0" title="0">constructor, exists := c.constructors[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dependency %s not registered", name)
        }</span>

        // 생성자 호출
        <span class="cov0" title="0">constructorValue := reflect.ValueOf(constructor)
        if constructorValue.Kind() != reflect.Func </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("constructor for %s must be a function", name)
        }</span>

        // 생성자 파라미터 해결
        <span class="cov0" title="0">params := make([]reflect.Value, constructorValue.Type().NumIn())
        for i := 0; i &lt; constructorValue.Type().NumIn(); i++ </span><span class="cov0" title="0">{
                paramType := constructorValue.Type().In(i)
                // TODO: 파라미터 의존성 해결 로직 구현
                params[i] = reflect.New(paramType).Elem()
        }</span>

        // 인스턴스 생성
        <span class="cov0" title="0">results := constructorValue.Call(params)
        if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("constructor for %s must return at least one value", name)
        }</span>

        <span class="cov0" title="0">instance := results[0].Interface()
        c.instances[name] = instance

        return instance, nil</span>
}
</pre>

                <pre class="file" id="file4" style="display: none">package asset

import (
        "github.com/google/uuid"
)

// generateID는 UUID v4를 사용하여 고유한 ID를 생성합니다.
// UUID v4는 랜덤하게 생성되며, 충돌 가능성이 극히 낮습니다.
// 또한 내부적으로 동시성을 지원하므로 별도의 동기화가 필요하지 않습니다.
func generateID() string <span class="cov8" title="1">{
        return uuid.New().String()
}</span>
</pre>

                <pre class="file" id="file5" style="display: none">package asset

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/aske/go_fi_chart/internal/domain"
)

// MemoryRepository 인메모리 저장소 구현체
type MemoryRepository[T domain.Entity] struct {
        data  map[string]T
        mutex sync.RWMutex
}

// NewMemoryRepository 새로운 인메모리 저장소를 생성합니다.
func NewMemoryRepository[T domain.Entity]() *MemoryRepository[T] <span class="cov8" title="1">{
        return &amp;MemoryRepository[T]{
                data: make(map[string]T),
        }
}</span>

// Save 엔티티를 저장합니다.
func (r *MemoryRepository[T]) Save(_ context.Context, entity T) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.data[entity.GetID()]; exists </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("Save", fmt.Errorf("entity with ID %s already exists", entity.GetID()))
        }</span>

        <span class="cov8" title="1">r.data[entity.GetID()] = entity
        return nil</span>
}

// FindByID ID로 엔티티를 조회합니다.
func (r *MemoryRepository[T]) FindByID(_ context.Context, id string) (T, error) <span class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        if entity, exists := r.data[id]; exists </span><span class="cov8" title="1">{
                return entity, nil
        }</span>

        <span class="cov8" title="1">var zero T
        return zero, domain.NewRepositoryError("FindByID", fmt.Errorf("entity with ID %s not found", id))</span>
}

// Update 엔티티를 업데이트합니다.
func (r *MemoryRepository[T]) Update(_ context.Context, entity T) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.data[entity.GetID()]; !exists </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("Update", fmt.Errorf("entity with ID %s not found", entity.GetID()))
        }</span>

        <span class="cov8" title="1">r.data[entity.GetID()] = entity
        return nil</span>
}

// Delete ID로 엔티티를 삭제합니다.
func (r *MemoryRepository[T]) Delete(_ context.Context, id string) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.data[id]; !exists </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("Delete", fmt.Errorf("entity with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">delete(r.data, id)
        return nil</span>
}

// FindAll 검색 조건에 맞는 모든 엔티티를 조회합니다.
func (r *MemoryRepository[T]) FindAll(_ context.Context, _ domain.SearchCriteria) ([]T, error) <span class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var result []T
        for _, entity := range r.data </span><span class="cov0" title="0">{
                result = append(result, entity)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// FindOne 검색 조건에 맞는 하나의 엔티티를 조회합니다.
func (r *MemoryRepository[T]) FindOne(_ context.Context, _ domain.SearchCriteria) (T, error) <span class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var zero T
        return zero, domain.NewRepositoryError("FindOne", fmt.Errorf("not implemented"))
}</span>

// WithTransaction 트랜잭션을 실행합니다.
func (r *MemoryRepository[T]) WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error <span class="cov0" title="0">{
        return fn(ctx)
}</span>

// MemoryAssetRepository Asset 도메인의 인메모리 저장소
type MemoryAssetRepository struct {
        repo *MemoryRepository[*Asset]
}

// NewMemoryAssetRepository 새로운 Asset 인메모리 저장소를 생성합니다.
func NewMemoryAssetRepository() *MemoryAssetRepository <span class="cov8" title="1">{
        return &amp;MemoryAssetRepository{
                repo: NewMemoryRepository[*Asset](),
        }
}</span>

// Save Asset을 저장합니다.
func (r *MemoryAssetRepository) Save(ctx context.Context, asset *Asset) error <span class="cov8" title="1">{
        return r.repo.Save(ctx, asset)
}</span>

// FindByID ID로 Asset을 조회합니다.
func (r *MemoryAssetRepository) FindByID(ctx context.Context, id string) (*Asset, error) <span class="cov8" title="1">{
        return r.repo.FindByID(ctx, id)
}</span>

// Update Asset을 업데이트합니다.
func (r *MemoryAssetRepository) Update(ctx context.Context, asset *Asset) error <span class="cov8" title="1">{
        return r.repo.Update(ctx, asset)
}</span>

// Delete ID로 Asset을 삭제합니다.
func (r *MemoryAssetRepository) Delete(ctx context.Context, id string) error <span class="cov8" title="1">{
        return r.repo.Delete(ctx, id)
}</span>

// FindByUserID 사용자 ID로 Asset 목록을 조회합니다.
func (r *MemoryAssetRepository) FindByUserID(_ context.Context, userID string) ([]*Asset, error) <span class="cov8"
                                                                                                       title="1">{
        r.repo.mutex.RLock()
        defer r.repo.mutex.RUnlock()

        var result []*Asset
        for _, asset := range r.repo.data </span><span class="cov8" title="1">{
                if asset.UserID == userID </span><span class="cov8" title="1">{
                        result = append(result, asset)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// FindByType Asset 유형으로 Asset 목록을 조회합니다.
func (r *MemoryAssetRepository) FindByType(_ context.Context, assetType Type) ([]*Asset, error) <span class="cov8"
                                                                                                      title="1">{
        r.repo.mutex.RLock()
        defer r.repo.mutex.RUnlock()

        var result []*Asset
        for _, asset := range r.repo.data </span><span class="cov8" title="1">{
                if asset.Type == assetType </span><span class="cov8" title="1">{
                        result = append(result, asset)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// UpdateAmount Asset의 금액을 업데이트합니다.
func (r *MemoryAssetRepository) UpdateAmount(_ context.Context, id string, amount float64) error <span class="cov8"
                                                                                                       title="1">{
        r.repo.mutex.Lock()
        defer r.repo.mutex.Unlock()

        asset, ok := r.repo.data[id]
        if !ok </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("UpdateAmount", fmt.Errorf("asset with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">asset.Amount = Money{Amount: amount, Currency: asset.Amount.Currency}
        asset.UpdatedAt = time.Now()
        r.repo.data[id] = asset

        return nil</span>
}

// FindAll 검색 조건에 맞는 모든 Asset을 조회합니다.
func (r *MemoryAssetRepository) FindAll(_ context.Context, _ domain.SearchCriteria) ([]*Asset, error) <span class="cov0"
                                                                                                            title="0">{
        r.repo.mutex.RLock()
        defer r.repo.mutex.RUnlock()

        var result []*Asset
        for _, asset := range r.repo.data </span><span class="cov0" title="0">{
                result = append(result, asset)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// FindOne 검색 조건에 맞는 하나의 Asset을 조회합니다.
func (r *MemoryAssetRepository) FindOne(ctx context.Context, criteria domain.SearchCriteria) (*Asset, error) <span
                                class="cov0" title="0">{
        return r.repo.FindOne(ctx, criteria)
}</span>

// WithTransaction 트랜잭션을 실행합니다.
func (r *MemoryAssetRepository) WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error <span
                                class="cov0" title="0">{
        return r.repo.WithTransaction(ctx, fn)
}</span>

// MemoryTransactionRepository Transaction 도메인의 인메모리 저장소 구현체입니다.
type MemoryTransactionRepository struct {
        repo *MemoryRepository[*Transaction]
}

// NewMemoryTransactionRepository 새로운 인메모리 Transaction 저장소를 생성합니다.
func NewMemoryTransactionRepository() *MemoryTransactionRepository <span class="cov8" title="1">{
        return &amp;MemoryTransactionRepository{
                repo: NewMemoryRepository[*Transaction](),
        }
}</span>

// Save Transaction을 저장합니다.
func (r *MemoryTransactionRepository) Save(ctx context.Context, tx *Transaction) error <span class="cov8" title="1">{
        return r.repo.Save(ctx, tx)
}</span>

// FindByID ID로 Transaction을 조회합니다.
func (r *MemoryTransactionRepository) FindByID(ctx context.Context, id string) (*Transaction, error) <span class="cov8"
                                                                                                           title="1">{
        return r.repo.FindByID(ctx, id)
}</span>

// Update Transaction을 업데이트합니다.
func (r *MemoryTransactionRepository) Update(ctx context.Context, tx *Transaction) error <span class="cov0" title="0">{
        return r.repo.Update(ctx, tx)
}</span>

// Delete ID로 Transaction을 삭제합니다.
func (r *MemoryTransactionRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        return r.repo.Delete(ctx, id)
}</span>

// FindByAssetID AssetID로 Transaction 목록을 조회합니다.
func (r *MemoryTransactionRepository) FindByAssetID(_ context.Context, assetID string) ([]*Transaction, error) <span
                                class="cov0" title="0">{
        r.repo.mutex.RLock()
        defer r.repo.mutex.RUnlock()

        var result []*Transaction
        for _, tx := range r.repo.data </span><span class="cov0" title="0">{
                if tx.AssetID == assetID </span><span class="cov0" title="0">{
                        result = append(result, tx)
                }</span>
        }
        <span class="cov0" title="0">return result, nil</span>
}

// FindByDateRange 날짜 범위로 Transaction 목록을 조회합니다.
func (r *MemoryTransactionRepository) FindByDateRange(_ context.Context, start, end time.Time) ([]*Transaction, error) <span
                                class="cov8" title="1">{
        r.repo.mutex.RLock()
        defer r.repo.mutex.RUnlock()

        var result []*Transaction
        for _, tx := range r.repo.data </span><span class="cov8" title="1">{
                if (tx.Date.Equal(start) || tx.Date.After(start)) &amp;&amp;
                        (tx.Date.Equal(end) || tx.Date.Before(end)) </span><span class="cov8" title="1">{
                        result = append(result, tx)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// GetTotalAmount 특정 기간 동안의 총 거래 금액을 계산합니다.
func (r *MemoryTransactionRepository) GetTotalAmount(_ context.Context, assetID string) (Money, error) <span
                                class="cov8" title="1">{
        r.repo.mutex.RLock()
        defer r.repo.mutex.RUnlock()

        total := Money{Amount: 0, Currency: "KRW"}
        for _, tx := range r.repo.data </span><span class="cov8" title="1">{
                if tx.AssetID == assetID </span><span class="cov8" title="1">{
                        switch tx.Type </span>{
                        case Income:<span class="cov8" title="1">
                                result, err := total.Add(tx.Amount)
                                if err != nil </span><span class="cov0" title="0">{
                                        return Money{}, err
                                }</span>
                                <span class="cov8" title="1">total = result</span>
                        case Expense:<span class="cov8" title="1">
                                result, err := total.Subtract(tx.Amount)
                                if err != nil </span><span class="cov0" title="0">{
                                        return Money{}, err
                                }</span>
                                <span class="cov8" title="1">total = result</span>
                        }
                }
        }
        <span class="cov8" title="1">return total, nil</span>
}

// FindAll 검색 조건에 맞는 모든 Transaction을 조회합니다.
func (r *MemoryTransactionRepository) FindAll(_ context.Context, _ domain.SearchCriteria) ([]*Transaction, error) <span
                                class="cov0" title="0">{
        r.repo.mutex.RLock()
        defer r.repo.mutex.RUnlock()

        var result []*Transaction
        for _, tx := range r.repo.data </span><span class="cov0" title="0">{
                result = append(result, tx)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// FindOne 검색 조건에 맞는 하나의 Transaction을 조회합니다.
func (r *MemoryTransactionRepository) FindOne(ctx context.Context, criteria domain.SearchCriteria) (*Transaction, error) <span
                                class="cov0" title="0">{
        return r.repo.FindOne(ctx, criteria)
}</span>

// WithTransaction 트랜잭션을 실행합니다.
func (r *MemoryTransactionRepository) WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error <span
                                class="cov0" title="0">{
        return r.repo.WithTransaction(ctx, fn)
}</span>

// MemoryPortfolioRepository Portfolio 도메인의 인메모리 저장소 구현체입니다.
type MemoryPortfolioRepository struct {
        repo *MemoryRepository[*Portfolio]
}

// NewMemoryPortfolioRepository 새로운 인메모리 Portfolio 저장소를 생성합니다.
func NewMemoryPortfolioRepository() *MemoryPortfolioRepository <span class="cov8" title="1">{
        return &amp;MemoryPortfolioRepository{
                repo: NewMemoryRepository[*Portfolio](),
        }
}</span>

// Save Portfolio를 저장합니다.
func (r *MemoryPortfolioRepository) Save(ctx context.Context, portfolio *Portfolio) error <span class="cov8" title="1">{
        return r.repo.Save(ctx, portfolio)
}</span>

// FindByID ID로 Portfolio를 조회합니다.
func (r *MemoryPortfolioRepository) FindByID(ctx context.Context, id string) (*Portfolio, error) <span class="cov8"
                                                                                                       title="1">{
        return r.repo.FindByID(ctx, id)
}</span>

// Update Portfolio를 업데이트합니다.
func (r *MemoryPortfolioRepository) Update(ctx context.Context, portfolio *Portfolio) error <span class="cov0"
                                                                                                  title="0">{
        return r.repo.Update(ctx, portfolio)
}</span>

// Delete ID로 Portfolio를 삭제합니다.
func (r *MemoryPortfolioRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        return r.repo.Delete(ctx, id)
}</span>

// FindByUserID 사용자 ID로 Portfolio를 조회합니다.
func (r *MemoryPortfolioRepository) FindByUserID(_ context.Context, userID string) (*Portfolio, error) <span
                                class="cov8" title="1">{
        r.repo.mutex.RLock()
        defer r.repo.mutex.RUnlock()

        for _, portfolio := range r.repo.data </span><span class="cov8" title="1">{
                if portfolio.UserID == userID </span><span class="cov8" title="1">{
                        return portfolio, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, domain.NewRepositoryError("FindByUserID", fmt.Errorf("portfolio for user %s not found", userID))</span>
}

// UpdateAssets Portfolio의 자산 구성을 업데이트합니다.
func (r *MemoryPortfolioRepository) UpdateAssets(_ context.Context, id string, assets []PortfolioAsset) error <span
                                class="cov8" title="1">{
        r.repo.mutex.Lock()
        defer r.repo.mutex.Unlock()

        portfolio, ok := r.repo.data[id]
        if !ok </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("UpdateAssets", fmt.Errorf("portfolio with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">portfolio.Assets = assets
        portfolio.UpdatedAt = time.Now()
        r.repo.data[id] = portfolio

        return nil</span>
}

// FindAll 검색 조건에 맞는 모든 Portfolio를 조회합니다.
func (r *MemoryPortfolioRepository) FindAll(_ context.Context, _ domain.SearchCriteria) ([]*Portfolio, error) <span
                                class="cov0" title="0">{
        r.repo.mutex.RLock()
        defer r.repo.mutex.RUnlock()

        var result []*Portfolio
        for _, portfolio := range r.repo.data </span><span class="cov0" title="0">{
                result = append(result, portfolio)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// FindOne 검색 조건에 맞는 하나의 Portfolio를 조회합니다.
func (r *MemoryPortfolioRepository) FindOne(ctx context.Context, criteria domain.SearchCriteria) (*Portfolio, error) <span
                                class="cov0" title="0">{
        return r.repo.FindOne(ctx, criteria)
}</span>

// WithTransaction 트랜잭션을 실행합니다.
func (r *MemoryPortfolioRepository) WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error <span
                                class="cov0" title="0">{
        return r.repo.WithTransaction(ctx, fn)
}</span>
</pre>

                <pre class="file" id="file6" style="display: none">package asset

import (
        "fmt"
        "time"

        "github.com/aske/go_fi_chart/internal/domain/event"
        "github.com/google/uuid"
)

// Money 화폐 값을 나타냅니다.
type Money struct {
        Amount   float64
        Currency string
}

// NewMoney Money 값 객체를 생성합니다.
func NewMoney(amount float64, currency string) Money <span class="cov8" title="1">{
        return Money{
                Amount:   amount,
                Currency: currency,
        }
}</span>

// Add 두 Money 값을 더합니다.
func (m Money) Add(other Money) (Money, error) <span class="cov8" title="1">{
        if m.Currency != other.Currency </span><span class="cov0" title="0">{
                return Money{}, fmt.Errorf("통화가 일치하지 않습니다: %s != %s", m.Currency, other.Currency)
        }</span>
        <span class="cov8" title="1">return Money{
                Amount:   m.Amount + other.Amount,
                Currency: m.Currency,
        }, nil</span>
}

// Subtract 두 Money 값을 뺍니다.
func (m Money) Subtract(other Money) (Money, error) <span class="cov8" title="1">{
        if m.Currency != other.Currency </span><span class="cov0" title="0">{
                return Money{}, fmt.Errorf("통화가 일치하지 않습니다: %s != %s", m.Currency, other.Currency)
        }</span>
        <span class="cov8" title="1">return Money{
                Amount:   m.Amount - other.Amount,
                Currency: m.Currency,
        }, nil</span>
}

// Multiply Money 값을 주어진 배수로 곱합니다.
func (m Money) Multiply(multiplier float64) Money <span class="cov0" title="0">{
        return Money{
                Amount:   m.Amount * multiplier,
                Currency: m.Currency,
        }
}</span>

// IsZero Money 값이 0인지 확인합니다.
func (m Money) IsZero() bool <span class="cov8" title="1">{
        return m.Amount == 0
}</span>

// IsNegative Money 값이 음수인지 확인합니다.
func (m Money) IsNegative() bool <span class="cov8" title="1">{
        return m.Amount &lt; 0
}</span>

// Performance 자산의 성과를 나타냅니다.
type Performance struct {
        StartValue     Money
        CurrentValue   Money
        GrowthRate     float64
        RiskScore      float64
        LastUpdateTime time.Time
}

// Goal 재무 목표를 나타냅니다.
type Goal struct {
        ID        string
        Type      GoalType
        Target    Money
        Deadline  time.Time
        Progress  float64
        Rewards   []Reward
        CreatedAt time.Time
        UpdatedAt time.Time
}

// GoalType 목표의 유형을 나타냅니다.
type GoalType string

const (
        GoalTypeSaving    GoalType = "SAVING"
        GoalTypeInvesting GoalType = "INVESTING"
        GoalTypeDebtFree  GoalType = "DEBT_FREE"
)

// Achievement 업적을 나타냅니다.
type Achievement struct {
        ID         string
        Type       AchievementType
        Progress   float64
        Conditions []Condition
        Rewards    []Reward
        UnlockedAt *time.Time
        CreatedAt  time.Time
        UpdatedAt  time.Time
}

// AchievementType 업적의 유형을 나타냅니다.
type AchievementType string

const (
        AchievementTypeSaving    AchievementType = "SAVING_MASTER"
        AchievementTypeInvesting AchievementType = "INVESTING_GURU"
        AchievementTypeCommunity AchievementType = "COMMUNITY_STAR"
)

// Condition 업적 달성 조건을 나타냅니다.
type Condition struct {
        Type      ConditionType
        Target    interface{}
        Current   interface{}
        Completed bool
}

// ConditionType 조건의 유형을 나타냅니다.
type ConditionType string

const (
        ConditionTypeAmount      ConditionType = "AMOUNT"
        ConditionTypeDuration    ConditionType = "DURATION"
        ConditionTypeStreak      ConditionType = "STREAK"
        ConditionTypeInteraction ConditionType = "INTERACTION"
)

// Reward 보상을 나타냅니다.
type Reward struct {
        Type    RewardType
        Value   interface{}
        Claimed bool
        ClaimBy time.Time
}

// RewardType 보상의 유형을 나타냅니다.
type RewardType string

const (
        RewardTypeBadge   RewardType = "BADGE"
        RewardTypeTitle   RewardType = "TITLE"
        RewardTypeFeature RewardType = "FEATURE"
)

// Asset 자산을 나타냅니다.
type Asset struct {
        ID           string
        UserID       string
        Type         Type
        Name         string
        Amount       Money
        Performance  Performance
        Goals        []Goal
        Achievements []Achievement
        CreatedAt    time.Time
        UpdatedAt    time.Time
        events       []event.Event // 미발행 이벤트 저장
}

func (a *Asset) GetID() string <span class="cov8" title="1">{
        return a.ID
}</span>

func (a *Asset) GetCreatedAt() time.Time <span class="cov8" title="1">{
        return a.CreatedAt
}</span>

func (a *Asset) GetUpdatedAt() time.Time <span class="cov8" title="1">{
        return a.UpdatedAt
}</span>

// Type 자산의 유형을 나타냅니다.
type Type string

const (
        Cash       Type = "CASH"
        Stock      Type = "STOCK"
        Bond       Type = "BOND"
        RealEstate Type = "REAL_ESTATE"
        Crypto     Type = "CRYPTO"
)

// NewAsset 새로운 자산을 생성합니다.
func NewAsset(userID string, assetType Type, name string, amount float64, currency string) *Asset <span class="cov8"
                                                                                                        title="1">{
        now := time.Now()
        return &amp;Asset{
                ID:     generateID(),
                UserID: userID,
                Type:   assetType,
                Name:   name,
                Amount: Money{
                        Amount:   amount,
                        Currency: currency,
                },
                Performance: Performance{
                        StartValue: Money{
                                Amount:   amount,
                                Currency: currency,
                        },
                        CurrentValue: Money{
                                Amount:   amount,
                                Currency: currency,
                        },
                        LastUpdateTime: now,
                },
                Goals:        make([]Goal, 0),
                Achievements: make([]Achievement, 0),
                CreatedAt:    now,
                UpdatedAt:    now,
        }
}</span>

// AddGoal 자산에 새로운 목표를 추가합니다.
func (a *Asset) AddGoal(goalType GoalType, target Money, deadline time.Time) *Goal <span class="cov0" title="0">{
        now := time.Now()
        goal := &amp;Goal{
                ID:        generateID(),
                Type:      goalType,
                Target:    target,
                Deadline:  deadline,
                Progress:  0,
                Rewards:   make([]Reward, 0),
                CreatedAt: now,
                UpdatedAt: now,
        }
        a.Goals = append(a.Goals, *goal)
        return goal
}</span>

// UpdateProgress 목표의 진행률을 업데이트합니다.
func (g *Goal) UpdateProgress(current Money) <span class="cov0" title="0">{
        g.Progress = (current.Amount / g.Target.Amount) * 100
        g.UpdatedAt = time.Now()
}</span>

// IsAchieved 목표가 달성되었는지 확인합니다.
func (g *Goal) IsAchieved() bool <span class="cov0" title="0">{
        return g.Progress &gt;= 100
}</span>

// AddAchievement 자산에 새로운 업적을 추가합니다.
func (a *Asset) AddAchievement(achievementType AchievementType, conditions []Condition) *Achievement <span class="cov0"
                                                                                                           title="0">{
        now := time.Now()
        achievement := &amp;Achievement{
                ID:         generateID(),
                Type:       achievementType,
                Progress:   0,
                Conditions: conditions,
                Rewards:    make([]Reward, 0),
                CreatedAt:  now,
                UpdatedAt:  now,
        }
        a.Achievements = append(a.Achievements, *achievement)
        return achievement
}</span>

// UpdateAchievementProgress 업적의 진행률을 업데이트합니다.
func (a *Achievement) UpdateProgress() <span class="cov0" title="0">{
        var completed int
        for _, condition := range a.Conditions </span><span class="cov0" title="0">{
                if condition.Completed </span><span class="cov0" title="0">{
                        completed++
                }</span>
        }
        <span class="cov0" title="0">a.Progress = float64(completed) / float64(len(a.Conditions)) * 100

        if a.Progress &gt;= 100 &amp;&amp; a.UnlockedAt == nil </span><span class="cov0" title="0">{
                now := time.Now()
                a.UnlockedAt = &amp;now
        }</span>

        <span class="cov0" title="0">a.UpdatedAt = time.Now()</span>
}

// IsUnlocked 업적이 해금되었는지 확인합니다.
func (a *Achievement) IsUnlocked() bool <span class="cov0" title="0">{
        return a.UnlockedAt != nil
}</span>

// TransactionType 거래의 유형을 나타냅니다.
type TransactionType string

const (
        Income   TransactionType = "INCOME"
        Expense  TransactionType = "EXPENSE"
        Transfer TransactionType = "TRANSFER"
)

// Transaction 거래 내역을 나타냅니다.
type Transaction struct {
        ID          string
        AssetID     string
        Type        TransactionType
        Amount      Money
        Category    string
        Description string
        Date        time.Time
        CreatedAt   time.Time
}

// NewTransaction 새로운 Transaction 값 객체를 생성합니다.
func NewTransaction(assetID string, transactionType TransactionType, amount Money, category string, description string) (*Transaction, error) <span
                                class="cov8" title="1">{
        if amount.IsZero() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("거래 금액은 0이 될 수 없습니다")
        }</span>
        <span class="cov8" title="1">if amount.IsNegative() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("거래 금액은 음수가 될 수 없습니다")
        }</span>

        <span class="cov8" title="1">now := time.Now()
        return &amp;Transaction{
                ID:          uuid.New().String(),
                AssetID:     assetID,
                Type:        transactionType,
                Amount:      amount,
                Category:    category,
                Description: description,
                Date:        now,
                CreatedAt:   now,
        }, nil</span>
}

// GetID 거래의 ID를 반환합니다.
func (t *Transaction) GetID() string <span class="cov8" title="1">{
        return t.ID
}</span>

// GetAmount 거래 금액을 반환합니다.
func (t *Transaction) GetAmount() Money <span class="cov0" title="0">{
        return t.Amount
}</span>

// GetDate 거래 일자를 반환합니다.
func (t *Transaction) GetDate() time.Time <span class="cov0" title="0">{
        return t.Date
}</span>

// GetCreatedAt 거래 생성 일자를 반환합니다.
func (t *Transaction) GetCreatedAt() time.Time <span class="cov8" title="1">{
        return t.CreatedAt
}</span>

// GetUpdatedAt 거래의 업데이트 일자를 반환합니다.
func (t *Transaction) GetUpdatedAt() time.Time <span class="cov8" title="1">{
        return t.Date
}</span>

// Portfolio 포트폴리오를 나타냅니다.
type Portfolio struct {
        ID        string
        UserID    string
        Assets    []PortfolioAsset
        CreatedAt time.Time
        UpdatedAt time.Time
}

// GetID 포트폴리오의 ID를 반환합니다.
func (p *Portfolio) GetID() string <span class="cov8" title="1">{
        return p.ID
}</span>

// GetCreatedAt 포트폴리오의 생성 일자를 반환합니다.
func (p *Portfolio) GetCreatedAt() time.Time <span class="cov8" title="1">{
        return p.CreatedAt
}</span>

// GetUpdatedAt 포트폴리오의 업데이트 일자를 반환합니다.
func (p *Portfolio) GetUpdatedAt() time.Time <span class="cov8" title="1">{
        return p.UpdatedAt
}</span>

// PortfolioAsset 포트폴리오의 자산 구성을 나타냅니다.
type PortfolioAsset struct {
        AssetID string
        Weight  float64
}

func NewPortfolio(userID string, assets []PortfolioAsset) *Portfolio <span class="cov8" title="1">{
        now := time.Now()
        return &amp;Portfolio{
                ID:        generateID(),
                UserID:    userID,
                Assets:    assets,
                CreatedAt: now,
                UpdatedAt: now,
        }
}</span>

// AddEvent 이벤트를 추가합니다.
func (a *Asset) AddEvent(evt event.Event) <span class="cov0" title="0">{
        if a.events == nil </span><span class="cov0" title="0">{
                a.events = make([]event.Event, 0)
        }</span>
        <span class="cov0" title="0">a.events = append(a.events, evt)</span>
}

// GetUncommittedEvents 미발행 이벤트를 반환합니다.
func (a *Asset) GetUncommittedEvents() []event.Event <span class="cov0" title="0">{
        return a.events
}</span>

// ClearEvents 이벤트를 초기화합니다.
func (a *Asset) ClearEvents() <span class="cov0" title="0">{
        a.events = make([]event.Event, 0)
}</span>

// ProcessTransaction 거래를 처리합니다.
func (a *Asset) ProcessTransaction(tx *Transaction) error <span class="cov0" title="0">{
        if err := a.ValidateTransaction(tx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch tx.Type </span>{
        case Income:<span class="cov0" title="0">
                result, err := a.Amount.Add(tx.Amount)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">a.Amount = result</span>
        case Expense:<span class="cov0" title="0">
                result, err := a.Amount.Subtract(tx.Amount)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">a.Amount = result</span>
        case Transfer:<span class="cov0" title="0">
                result, err := a.Amount.Subtract(tx.Amount)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">a.Amount = result</span>
        }

        <span class="cov0" title="0">a.UpdatedAt = time.Now()

        // 거래 처리 이벤트 발행
        a.AddEvent(event.NewEvent(
                event.TypeTransactionRecorded,
                a.ID,
                "asset",
                map[string]interface{}{
                        "transactionID": tx.ID,
                        "type":          tx.Type,
                        "amount":        tx.Amount,
                },
                map[string]string{
                        "userID": a.UserID,
                },
                1,
        ))

        return nil</span>
}

// ValidateTransaction 거래가 유효한지 검증합니다.
func (a *Asset) ValidateTransaction(tx *Transaction) error <span class="cov0" title="0">{
        if tx.Amount.IsZero() </span><span class="cov0" title="0">{
                return fmt.Errorf("거래 금액은 0이 될 수 없습니다")
        }</span>

        <span class="cov0" title="0">if tx.Amount.IsNegative() </span><span class="cov0" title="0">{
                return fmt.Errorf("거래 금액은 음수가 될 수 없습니다")
        }</span>

        <span class="cov0" title="0">if tx.Type == Expense &amp;&amp; a.Amount.Amount &lt; tx.Amount.Amount </span><span
                                class="cov0" title="0">{
                return fmt.Errorf("잔액이 부족합니다")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>

                <pre class="file" id="file7" style="display: none">package asset

import (
        "time"
)

// TestFixture 테스트에 사용할 데이터 세트
type TestFixture struct {
        Assets       []*Asset
        Transactions []*Transaction
        Portfolios   []*Portfolio
}

// NewTestFixture 새로운 테스트 픽스처를 생성합니다.
func NewTestFixture() *TestFixture <span class="cov8" title="1">{
        assets := []*Asset{
                {
                        ID:        "asset-1",
                        UserID:    "test-user-1",
                        Type:      Cash,
                        Name:      "현금 자산",
                        Amount:    Money{Amount: 1000000.0, Currency: "KRW"},
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
                {
                        ID:        "asset-2",
                        UserID:    "test-user-1",
                        Type:      Stock,
                        Name:      "주식 자산",
                        Amount:    Money{Amount: 2000000.0, Currency: "KRW"},
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
                {
                        ID:        "asset-3",
                        UserID:    "test-user-1",
                        Type:      RealEstate,
                        Name:      "부동산 자산",
                        Amount:    Money{Amount: 300000000.0, Currency: "KRW"},
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
        }

        transactions := []*Transaction{
                {
                        ID:          "tx-1",
                        AssetID:     assets[0].ID,
                        Type:        Income,
                        Amount:      Money{Amount: 500000.0, Currency: "KRW"},
                        Category:    "급여",
                        Description: "3월 급여",
                        Date:        time.Now(),
                        CreatedAt:   time.Now(),
                },
                {
                        ID:          "tx-2",
                        AssetID:     assets[0].ID,
                        Type:        Expense,
                        Amount:      Money{Amount: 100000.0, Currency: "KRW"},
                        Category:    "식비",
                        Description: "3월 식비",
                        Date:        time.Now(),
                        CreatedAt:   time.Now(),
                },
                {
                        ID:          "tx-3",
                        AssetID:     assets[0].ID,
                        Type:        Transfer,
                        Amount:      Money{Amount: 1000000.0, Currency: "KRW"},
                        Category:    "이체",
                        Description: "주식 계좌로 이체",
                        Date:        time.Now(),
                        CreatedAt:   time.Now(),
                },
        }

        // 포트폴리오 데이터 생성
        portfolios := []*Portfolio{
                {
                        ID:     "portfolio-1",
                        UserID: "test-user-1",
                        Assets: []PortfolioAsset{
                                {
                                        AssetID: "asset-1",
                                        Weight:  0.2, // 20%
                                },
                                {
                                        AssetID: "asset-2",
                                        Weight:  0.5, // 50%
                                },
                                {
                                        AssetID: "asset-3",
                                        Weight:  0.3, // 30%
                                },
                        },
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
        }

        return &amp;TestFixture{
                Assets:       assets,
                Transactions: transactions,
                Portfolios:   portfolios,
        }
}</span>

// GetAssetByID 테스트 픽스처에서 ID로 Asset을 찾습니다.
func (f *TestFixture) GetAssetByID(id string) *Asset <span class="cov8" title="1">{
        for _, asset := range f.Assets </span><span class="cov8" title="1">{
                if asset.ID == id </span><span class="cov8" title="1">{
                        return asset
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetTransactionByID 테스트 픽스처에서 ID로 Transaction을 찾습니다.
func (f *TestFixture) GetTransactionByID(id string) *Transaction <span class="cov8" title="1">{
        for _, tx := range f.Transactions </span><span class="cov8" title="1">{
                if tx.ID == id </span><span class="cov8" title="1">{
                        return tx
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetPortfolioByID 테스트 픽스처에서 ID로 Portfolio를 찾습니다.
func (f *TestFixture) GetPortfolioByID(id string) *Portfolio <span class="cov8" title="1">{
        for _, portfolio := range f.Portfolios </span><span class="cov8" title="1">{
                if portfolio.ID == id </span><span class="cov8" title="1">{
                        return portfolio
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetAssetsByUserID 테스트 픽스처에서 UserID로 Asset 목록을 찾습니다.
func (f *TestFixture) GetAssetsByUserID(userID string) []*Asset <span class="cov8" title="1">{
        var result []*Asset
        for _, asset := range f.Assets </span><span class="cov8" title="1">{
                if asset.UserID == userID </span><span class="cov8" title="1">{
                        result = append(result, asset)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetTransactionsByAssetID 테스트 픽스처에서 AssetID로 Transaction 목록을 찾습니다.
func (f *TestFixture) GetTransactionsByAssetID(assetID string) []*Transaction <span class="cov8" title="1">{
        var result []*Transaction
        for _, tx := range f.Transactions </span><span class="cov8" title="1">{
                if tx.AssetID == assetID </span><span class="cov8" title="1">{
                        result = append(result, tx)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetPortfolioByUserID 테스트 픽스처에서 UserID로 Portfolio를 찾습니다.
func (f *TestFixture) GetPortfolioByUserID(userID string) *Portfolio <span class="cov8" title="1">{
        for _, portfolio := range f.Portfolios </span><span class="cov8" title="1">{
                if portfolio.UserID == userID </span><span class="cov8" title="1">{
                        return portfolio
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// CreateTestAsset 테스트용 자산을 생성합니다.
func CreateTestAsset() *Asset <span class="cov0" title="0">{
        return &amp;Asset{
                ID:        "test-asset-1",
                UserID:    "test-user-1",
                Type:      Stock,
                Name:      "삼성전자",
                Amount:    NewMoney(500000, "KRW"),
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }
}</span>

// CreateTestTransaction 테스트용 거래 내역을 생성합니다.
func CreateTestTransaction() *Transaction <span class="cov0" title="0">{
        tx, _ := NewTransaction(
                "test-asset-1",
                Income,
                NewMoney(100000, "KRW"),
                "급여",
                "2월 급여",
        )
        return tx
}</span>

// CreateTestPortfolio 테스트용 포트폴리오를 생성합니다.
func CreateTestPortfolio() *Portfolio <span class="cov0" title="0">{
        return &amp;Portfolio{
                ID:        "test-portfolio-1",
                UserID:    "test-user-1",
                Assets:    []PortfolioAsset{},
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }
}</span>
</pre>

                <pre class="file" id="file8" style="display: none">package domain

import "fmt"

// Error 도메인 에러 인터페이스입니다.
type Error interface {
        error
        // Code 에러 코드를 반환합니다.
        Code() string
        // Domain 에러가 발생한 도메인을 반환합니다.
        Domain() string
}

// BaseError 기본 도메인 에러 구현체입니다.
type BaseError struct {
        domain string
        code   string
        msg    string
}

// NewError 새로운 도메인 에러를 생성합니다.
func NewError(domain string, code string, msg string) Error <span class="cov0" title="0">{
        return &amp;BaseError{
                domain: domain,
                code:   code,
                msg:    msg,
        }
}</span>

func (e *BaseError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("[%s] %s: %s", e.domain, e.code, e.msg)
}</span>

func (e *BaseError) Code() string <span class="cov0" title="0">{
        return e.code
}</span>

func (e *BaseError) Domain() string <span class="cov0" title="0">{
        return e.domain
}</span>

// 자주 사용되는 에러 코드 상수
const (
        ErrCodeNotFound         = "NOT_FOUND"
        ErrCodeAlreadyExists    = "ALREADY_EXISTS"
        ErrCodeInvalidArgument  = "INVALID_ARGUMENT"
        ErrCodeInvalidOperation = "INVALID_OPERATION"
        ErrCodeNotImplemented   = "NOT_IMPLEMENTED"
        ErrCodeInternal         = "INTERNAL"
)
</pre>

                <pre class="file" id="file9" style="display: none">package event

import (
        "context"
        "time"
)

// Type 이벤트의 타입을 나타냅니다.
type Type string

// 시스템에서 사용되는 이벤트 타입 상수들
const (
        TypeAssetCreated        Type = "asset.created"
        TypeAssetUpdated        Type = "asset.updated"
        TypeAssetDeleted        Type = "asset.deleted"
        TypeTransactionRecorded Type = "transaction.recorded"
        TypePortfolioRebalanced Type = "portfolio.rebalanced"
        TypeMetricCollected     Type = "metric.collected"
        TypeAlertTriggered      Type = "alert.triggered"
)

// Event 도메인 이벤트 인터페이스
type Event interface {
        // EventType 이벤트의 타입을 반환합니다.
        EventType() Type
        // AggregateID 이벤트가 발생한 애그리게잇의 ID를 반환합니다.
        AggregateID() string
        // AggregateType 이벤트가 발생한 애그리게잇의 타입을 반환합니다.
        AggregateType() string
        // Payload 이벤트의 페이로드를 반환합니다.
        Payload() interface{}
        // Metadata 이벤트의 메타데이터를 반환합니다.
        Metadata() map[string]string
        // Timestamp 이벤트가 발생한 시간을 반환합니다.
        Timestamp() time.Time
        // Version 이벤트의 버전을 반환합니다.
        Version() int
}

// Handler 이벤트를 처리하는 핸들러 인터페이스
type Handler interface {
        // HandleEvent 이벤트를 처리합니다.
        HandleEvent(ctx context.Context, event Event) error
        // HandlerName 핸들러의 이름을 반환합니다.
        HandlerName() string
}

// Bus 이벤트 버스 인터페이스입니다.
type Bus interface {
        // Publish 이벤트를 발행합니다.
        Publish(ctx context.Context, event Event) error
        // Subscribe 이벤트 핸들러를 등록합니다.
        Subscribe(handler Handler) error
        // Unsubscribe 이벤트 핸들러를 제거합니다.
        Unsubscribe(handler Handler) error
}

// Store 이벤트를 저장하는 저장소 인터페이스
type Store interface {
        // Save 이벤트를 저장합니다.
        Save(ctx context.Context, events ...Event) error
        // Load 특정 애그리게잇의 이벤트들을 로드합니다.
        Load(ctx context.Context, aggregateID string) ([]Event, error)
}

// BaseEvent 기본 이벤트 구현체
type BaseEvent struct {
        eventType     Type
        aggregateID   string
        aggregateType string
        payload       interface{}
        metadata      map[string]string
        timestamp     time.Time
        version       int
}

// NewEvent 새로운 이벤트를 생성합니다.
func NewEvent(
        eventType Type,
        aggregateID string,
        aggregateType string,
        payload interface{},
        metadata map[string]string,
        version int,
) Event <span class="cov8" title="1">{
        return &amp;BaseEvent{
                eventType:     eventType,
                aggregateID:   aggregateID,
                aggregateType: aggregateType,
                payload:       payload,
                metadata:      metadata,
                timestamp:     time.Now(),
                version:       version,
        }
}</span>

func (e *BaseEvent) EventType() Type <span class="cov8" title="1">{
        return e.eventType
}</span>

func (e *BaseEvent) AggregateID() string <span class="cov8" title="1">{
        return e.aggregateID
}</span>

func (e *BaseEvent) AggregateType() string <span class="cov8" title="1">{
        return e.aggregateType
}</span>

func (e *BaseEvent) Payload() interface{} <span class="cov8" title="1">{
        return e.payload
}</span>

func (e *BaseEvent) Metadata() map[string]string <span class="cov8" title="1">{
        return e.metadata
}</span>

func (e *BaseEvent) Timestamp() time.Time <span class="cov8" title="1">{
        return e.timestamp
}</span>

func (e *BaseEvent) Version() int <span class="cov8" title="1">{
        return e.version
}</span>

// SimpleBus 기본 이벤트 버스 구현체
type SimpleBus struct {
        handlers []Handler
}

// NewSimpleBus 새로운 SimpleBus를 생성합니다.
func NewSimpleBus() *SimpleBus <span class="cov0" title="0">{
        return &amp;SimpleBus{
                handlers: make([]Handler, 0),
        }
}</span>
</pre>

                <pre class="file" id="file10" style="display: none">package gamification

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/aske/go_fi_chart/internal/domain"
)

// MemoryRepository 게임화 프로필의 인메모리 저장소 구현체입니다.
type MemoryRepository struct {
        data  map[string]*Profile
        mutex sync.RWMutex
}

// NewMemoryRepository 새로운 인메모리 저장소를 생성합니다.
func NewMemoryRepository() *MemoryRepository <span class="cov8" title="1">{
        return &amp;MemoryRepository{
                data: make(map[string]*Profile),
        }
}</span>

// Save 프로필을 저장합니다.
func (r *MemoryRepository) Save(_ context.Context, profile *Profile) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.data[profile.ID]; exists </span><span class="cov0" title="0">{
                return domain.NewError("gamification", domain.ErrCodeAlreadyExists, fmt.Sprintf("profile with ID %s already exists", profile.ID))
        }</span>

        <span class="cov8" title="1">r.data[profile.ID] = profile
        return nil</span>
}

// FindByID ID로 프로필을 조회합니다.
func (r *MemoryRepository) FindByID(_ context.Context, id string) (*Profile, error) <span class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        if profile, exists := r.data[id]; exists </span><span class="cov8" title="1">{
                return profile, nil
        }</span>

        <span class="cov8" title="1">return nil, domain.NewError("gamification", domain.ErrCodeNotFound, fmt.Sprintf("profile with ID %s not found", id))</span>
}

// Update 프로필을 업데이트합니다.
func (r *MemoryRepository) Update(_ context.Context, profile *Profile) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.data[profile.ID]; !exists </span><span class="cov0" title="0">{
                return domain.NewError("gamification", domain.ErrCodeNotFound, fmt.Sprintf("profile with ID %s not found", profile.ID))
        }</span>

        <span class="cov8" title="1">profile.UpdatedAt = time.Now()
        r.data[profile.ID] = profile
        return nil</span>
}

// Delete ID로 프로필을 삭제합니다.
func (r *MemoryRepository) Delete(_ context.Context, id string) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.data[id]; !exists </span><span class="cov0" title="0">{
                return domain.NewError("gamification", domain.ErrCodeNotFound, fmt.Sprintf("profile with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">delete(r.data, id)
        return nil</span>
}

// FindAll 검색 조건에 맞는 모든 프로필을 조회합니다.
func (r *MemoryRepository) FindAll(_ context.Context, _ domain.SearchCriteria) ([]*Profile, error) <span class="cov0"
                                                                                                         title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        profiles := make([]*Profile, 0, len(r.data))
        for _, profile := range r.data </span><span class="cov0" title="0">{
                profiles = append(profiles, profile)
        }</span>
        <span class="cov0" title="0">return profiles, nil</span>
}

// FindOne 검색 조건에 맞는 하나의 프로필을 조회합니다.
func (r *MemoryRepository) FindOne(_ context.Context, _ domain.SearchCriteria) (*Profile, error) <span class="cov0"
                                                                                                       title="0">{
        return nil, domain.NewError("gamification", domain.ErrCodeNotImplemented, "FindOne not implemented")
}</span>

// WithTransaction 트랜잭션을 실행합니다.
func (r *MemoryRepository) WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error <span
                                class="cov0" title="0">{
        return fn(ctx)
}</span>

// FindByUserID 사용자 ID로 프로필을 조회합니다.
func (r *MemoryRepository) FindByUserID(_ context.Context, userID string) (*Profile, error) <span class="cov8"
                                                                                                  title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        for _, profile := range r.data </span><span class="cov8" title="1">{
                if profile.UserID == userID </span><span class="cov8" title="1">{
                        return profile, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, domain.NewError("gamification", domain.ErrCodeNotFound, fmt.Sprintf("profile for user %s not found", userID))</span>
}

// UpdateExperience 사용자의 경험치를 업데이트합니다.
func (r *MemoryRepository) UpdateExperience(_ context.Context, id string, exp int) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        profile, exists := r.data[id]
        if !exists </span><span class="cov0" title="0">{
                return domain.NewError("gamification", domain.ErrCodeNotFound, fmt.Sprintf("profile with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">leveledUp := profile.AddExperience(exp)
        if leveledUp </span><span class="cov8" title="1">{
                profile.UpdatedAt = time.Now()
        }</span>

        <span class="cov8" title="1">r.data[id] = profile
        return nil</span>
}

// UpdateStats 사용자의 통계를 업데이트합니다.
func (r *MemoryRepository) UpdateStats(_ context.Context, id string, stats Statistics) error <span class="cov8"
                                                                                                   title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        profile, exists := r.data[id]
        if !exists </span><span class="cov0" title="0">{
                return domain.NewError("gamification", domain.ErrCodeNotFound, fmt.Sprintf("profile with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">profile.Stats = stats
        profile.UpdatedAt = time.Now()
        r.data[id] = profile
        return nil</span>
}

// AddBadge 사용자에게 뱃지를 추가합니다.
func (r *MemoryRepository) AddBadge(_ context.Context, id string, badge Badge) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        profile, exists := r.data[id]
        if !exists </span><span class="cov0" title="0">{
                return domain.NewError("gamification", domain.ErrCodeNotFound, fmt.Sprintf("profile with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">profile.Badges = append(profile.Badges, badge)
        profile.Stats.BadgesEarned++
        profile.UpdatedAt = time.Now()
        r.data[id] = profile
        return nil</span>
}

// UpdateStreak 사용자의 연속 달성을 업데이트합니다.
func (r *MemoryRepository) UpdateStreak(_ context.Context, id string, streakType StreakType) error <span class="cov8"
                                                                                                         title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        profile, exists := r.data[id]
        if !exists </span><span class="cov0" title="0">{
                return domain.NewError("gamification", domain.ErrCodeNotFound, fmt.Sprintf("profile with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">profile.UpdateStreak(streakType)
        r.data[id] = profile
        return nil</span>
}
</pre>

                <pre class="file" id="file11" style="display: none">package gamification

import (
        "time"

        "github.com/aske/go_fi_chart/internal/domain"
)

// Level 사용자의 레벨을 나타냅니다.
type Level struct {
        Value       int
        Experience  int
        NextLevel   int
        Title       string
        UnlockedAt  time.Time
        Description string
}

// Profile 사용자의 게임화 프로필을 나타냅니다.
type Profile struct {
        ID           string
        UserID       string
        Level        Level
        Experience   int
        Achievements []string // Achievement IDs
        Badges       []Badge
        Streaks      []Streak
        Stats        Statistics
        CreatedAt    time.Time
        UpdatedAt    time.Time
}

func (p *Profile) GetID() string <span class="cov0" title="0">{
        return p.ID
}</span>

func (p *Profile) GetCreatedAt() time.Time <span class="cov0" title="0">{
        return p.CreatedAt
}</span>

func (p *Profile) GetUpdatedAt() time.Time <span class="cov0" title="0">{
        return p.UpdatedAt
}</span>

// Badge 사용자가 획득한 뱃지를 나타냅니다.
type Badge struct {
        ID          string
        Type        BadgeType
        Title       string
        Description string
        Tier        BadgeTier
        UnlockedAt  time.Time
}

// BadgeType 뱃지의 유형을 나타냅니다.
type BadgeType string

const (
        BadgeTypeSaving    BadgeType = "SAVING"
        BadgeTypeInvesting BadgeType = "INVESTING"
        BadgeTypeCommunity BadgeType = "COMMUNITY"
        BadgeTypeChallenge BadgeType = "CHALLENGE"
)

// BadgeTier 뱃지의 등급을 나타냅니다.
type BadgeTier string

const (
        BadgeTierBronze  BadgeTier = "BRONZE"
        BadgeTierSilver  BadgeTier = "SILVER"
        BadgeTierGold    BadgeTier = "GOLD"
        BadgeTierDiamond BadgeTier = "DIAMOND"
)

// Streak 연속 달성을 나타냅니다.
type Streak struct {
        Type        StreakType
        Count       int
        LastUpdated time.Time
        MaxCount    int
}

// StreakType 연속 달성의 유형을 나타냅니다.
type StreakType string

const (
        StreakTypeDaily   StreakType = "DAILY"
        StreakTypeWeekly  StreakType = "WEEKLY"
        StreakTypeMonthly StreakType = "MONTHLY"
)

// Statistics 사용자의 게임화 통계를 나타냅니다.
type Statistics struct {
        TotalSavings      float64
        TotalInvestments  float64
        GoalsCompleted    int
        BadgesEarned      int
        LongestStreak     int
        CommunityRanking  int
        ContributionScore float64
}

// NewProfile 새로운 게임화 프로필을 생성합니다.
func NewProfile(userID string) *Profile <span class="cov8" title="1">{
        now := time.Now()
        return &amp;Profile{
                ID:     domain.GenerateID(),
                UserID: userID,
                Level: Level{
                        Value:       1,
                        Experience:  0,
                        NextLevel:   100,
                        Title:       "초보 투자자",
                        UnlockedAt:  now,
                        Description: "자산 관리의 첫 걸음을 내딛었습니다.",
                },
                Experience:   0,
                Achievements: make([]string, 0),
                Badges:       make([]Badge, 0),
                Streaks:      make([]Streak, 0),
                Stats:        Statistics{},
                CreatedAt:    now,
                UpdatedAt:    now,
        }
}</span>

// AddExperience 경험치를 추가하고 레벨업 여부를 반환합니다.
func (p *Profile) AddExperience(exp int) bool <span class="cov8" title="1">{
        p.Experience += exp
        p.UpdatedAt = time.Now()

        leveledUp := false
        for p.Experience &gt;= p.Level.NextLevel </span><span class="cov8" title="1">{
                p.levelUp()
                leveledUp = true
        }</span>
        <span class="cov8" title="1">return leveledUp</span>
}

// levelUp 레벨을 올립니다.
func (p *Profile) levelUp() <span class="cov8" title="1">{
        p.Level.Value++
        p.Level.Experience = p.Experience
        p.Level.NextLevel = calculateNextLevelExp(p.Level.Value)
        p.Level.UnlockedAt = time.Now()
        p.updateLevelTitle()
}</span>

// calculateNextLevelExp 다음 레벨에 필요한 경험치를 계산합니다.
func calculateNextLevelExp(level int) int <span class="cov8" title="1">{
        return level * level * 100
}</span>

// updateLevelTitle 레벨에 따른 타이틀을 업데이트합니다.
func (p *Profile) updateLevelTitle() <span class="cov8" title="1">{
        switch </span>{
        case p.Level.Value &gt;= 50:<span class="cov8" title="1">
                p.Level.Title = "투자의 신"
                p.Level.Description = "최고 수준의 투자 전문가입니다."</span>
        case p.Level.Value &gt;= 40:<span class="cov8" title="1">
                p.Level.Title = "투자 마스터"
                p.Level.Description = "뛰어난 투자 실력을 보유하고 있습니다."</span>
        case p.Level.Value &gt;= 30:<span class="cov8" title="1">
                p.Level.Title = "숙련된 투자자"
                p.Level.Description = "안정적인 투자 능력을 보유하고 있습니다."</span>
        case p.Level.Value &gt;= 20:<span class="cov8" title="1">
                p.Level.Title = "중급 투자자"
                p.Level.Description = "투자의 기본을 완벽히 이해했습니다."</span>
        default:<span class="cov8" title="1">
                p.Level.Title = "초보 투자자"
                p.Level.Description = "투자의 기초를 배우고 있습니다."</span>
        }
}

// AddBadge 뱃지를 추가합니다.
func (p *Profile) AddBadge(badgeType BadgeType, tier BadgeTier, title, description string) <span class="cov8" title="1">{
        badge := Badge{
                ID:          domain.GenerateID(),
                Type:        badgeType,
                Title:       title,
                Description: description,
                Tier:        tier,
                UnlockedAt:  time.Now(),
        }
        p.Badges = append(p.Badges, badge)
        p.Stats.BadgesEarned++
        p.UpdatedAt = time.Now()
}</span>

// UpdateStreak 연속 달성을 업데이트합니다.
func (p *Profile) UpdateStreak(streakType StreakType) <span class="cov8" title="1">{
        now := time.Now()
        for i, streak := range p.Streaks </span><span class="cov8" title="1">{
                if streak.Type == streakType </span><span class="cov8" title="1">{
                        if now.Sub(streak.LastUpdated) &lt;= getStreakTimeout(streakType) </span><span class="cov8"
                                                                                                       title="1">{
                                p.Streaks[i].Count++
                                if p.Streaks[i].Count &gt; p.Streaks[i].MaxCount </span><span class="cov8" title="1">{
                                        p.Streaks[i].MaxCount = p.Streaks[i].Count
                                }</span>
                        } else<span class="cov8" title="1"> {
                                p.Streaks[i].Count = 1
                        }</span>
                        <span class="cov8" title="1">p.Streaks[i].LastUpdated = now
                        return</span>
                }
        }

        // 새로운 스트릭 추가
        <span class="cov8" title="1">p.Streaks = append(p.Streaks, Streak{
                Type:        streakType,
                Count:       1,
                LastUpdated: now,
                MaxCount:    1,
        })</span>
}

// getStreakTimeout 스트릭 타임아웃을 반환합니다.
func getStreakTimeout(streakType StreakType) time.Duration <span class="cov8" title="1">{
        switch streakType </span>{
        case StreakTypeDaily:<span class="cov8" title="1">
                return 24 * time.Hour</span>
        case StreakTypeWeekly:<span class="cov0" title="0">
                return 7 * 24 * time.Hour</span>
        case StreakTypeMonthly:<span class="cov0" title="0">
                return 30 * 24 * time.Hour</span>
        default:<span class="cov0" title="0">
                return 24 * time.Hour</span>
        }
}
</pre>

                <pre class="file" id="file12" style="display: none">package domain

import (
        "context"
        "time"
)

// Entity 모든 엔티티가 구현해야 하는 기본 인터페이스
type Entity interface {
        GetID() string
        GetCreatedAt() time.Time
        GetUpdatedAt() time.Time
}

// SearchCriteria 검색 조건 인터페이스
type SearchCriteria interface {
        ToQuery() (string, []interface{})
}

// Repository 기본 레포지토리 인터페이스
type Repository[T Entity, ID comparable] interface {
        // 기본 CRUD 작업
        Save(ctx context.Context, entity T) error
        FindByID(ctx context.Context, id ID) (T, error)
        Update(ctx context.Context, entity T) error
        Delete(ctx context.Context, id ID) error

        // 검색 작업
        FindAll(ctx context.Context, criteria SearchCriteria) ([]T, error)
        FindOne(ctx context.Context, criteria SearchCriteria) (T, error)

        // 트랜잭션 관리
        WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error
}

// RepositoryError 레포지토리 관련 에러 타입
type RepositoryError struct {
        Op  string // 작업 종류 (예: Save, FindByID 등)
        Err error  // 원본 에러
}

func (e *RepositoryError) Error() string <span class="cov0" title="0">{
        if e.Err == nil </span><span class="cov0" title="0">{
                return e.Op
        }</span>
        <span class="cov0" title="0">return e.Op + ": " + e.Err.Error()</span>
}

// NewRepositoryError 새로운 레포지토리 에러 생성
func NewRepositoryError(op string, err error) error <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Op:  op,
                Err: err,
        }
}</span>
</pre>

                <pre class="file" id="file13" style="display: none">package domain

import (
        "github.com/google/uuid"
)

// GenerateID UUID v4를 사용하여 고유한 ID를 생성합니다.
func GenerateID() string <span class="cov0" title="0">{
        return uuid.New().String()
}</span>
</pre>

                <pre class="file" id="file14" style="display: none">package memory

import (
        "context"
        "sync"

        "github.com/aske/go_fi_chart/internal/domain/event"
)

// EventBus 인메모리 이벤트 버스 구현체
type EventBus struct {
        handlers map[string][]event.Handler
        mu       sync.RWMutex
        closed   bool
}

// NewEventBus 새로운 인메모리 이벤트 버스를 생성합니다.
func NewEventBus() *EventBus <span class="cov8" title="1">{
        return &amp;EventBus{
                handlers: make(map[string][]event.Handler),
        }
}</span>

// Publish 이벤트를 발행합니다.
func (b *EventBus) Publish(ctx context.Context, evt event.Event) error <span class="cov8" title="1">{
        b.mu.RLock()
        defer b.mu.RUnlock()

        if b.closed </span><span class="cov8" title="1">{
                return event.ErrEventBusClosed
        }</span>

        // 모든 핸들러에게 이벤트 전달
        <span class="cov8" title="1">for _, handlers := range b.handlers </span><span class="cov8" title="1">{
                for _, handler := range handlers </span><span class="cov8" title="1">{
                        if err := handler.HandleEvent(ctx, evt); err != nil </span><span class="cov8" title="1">{
                                // 에러가 발생해도 다른 핸들러는 계속 실행
                                continue</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// Subscribe 이벤트 핸들러를 등록합니다.
func (b *EventBus) Subscribe(handler event.Handler) error <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()

        if b.closed </span><span class="cov8" title="1">{
                return event.ErrEventBusClosed
        }</span>

        <span class="cov8" title="1">handlerName := handler.HandlerName()
        b.handlers[handlerName] = append(b.handlers[handlerName], handler)
        return nil</span>
}

// Unsubscribe 이벤트 핸들러를 제거합니다.
func (b *EventBus) Unsubscribe(handler event.Handler) error <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()

        if b.closed </span><span class="cov8" title="1">{
                return event.ErrEventBusClosed
        }</span>

        <span class="cov8" title="1">handlerName := handler.HandlerName()
        handlers := b.handlers[handlerName]
        for i, h := range handlers </span><span class="cov8" title="1">{
                if h == handler </span><span class="cov8" title="1">{
                        b.handlers[handlerName] = append(handlers[:i], handlers[i+1:]...)
                        break</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// Close 이벤트 버스를 종료합니다.
func (b *EventBus) Close() error <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()

        b.closed = true
        b.handlers = nil
        return nil
}</span>
</pre>

                <pre class="file" id="file15" style="display: none">package memory

import (
        "context"
        "sync"

        "github.com/aske/go_fi_chart/internal/domain/event"
)

// EventStore 인메모리 이벤트 저장소 구현체
type EventStore struct {
        events map[string][]event.Event
        mu     sync.RWMutex
}

// NewEventStore 새로운 인메모리 이벤트 저장소를 생성합니다.
func NewEventStore() *EventStore <span class="cov8" title="1">{
        return &amp;EventStore{
                events: make(map[string][]event.Event),
        }
}</span>

// Save 이벤트를 저장합니다.
func (s *EventStore) Save(_ context.Context, events ...event.Event) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        for _, evt := range events </span><span class="cov8" title="1">{
                aggregateID := evt.AggregateID()
                s.events[aggregateID] = append(s.events[aggregateID], evt)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Load 특정 애그리게잇의 이벤트들을 로드합니다.
func (s *EventStore) Load(_ context.Context, aggregateID string) ([]event.Event, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        events, exists := s.events[aggregateID]
        if !exists </span><span class="cov8" title="1">{
                return []event.Event{}, nil
        }</span>

        <span class="cov8" title="1">result := make([]event.Event, len(events))
        copy(result, events)
        return result, nil</span>
}

// Clear 모든 이벤트를 삭제합니다.
func (s *EventStore) Clear() <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.events = make(map[string][]event.Event)
}</span>
</pre>

                <pre class="file" id="file16" style="display: none">package github

import (
        "context"
        "sync"

        "github.com/aske/go_fi_chart/services/monitoring/pkg/domain"
        pkgmetrics "github.com/aske/go_fi_chart/services/monitoring/pkg/metrics"
)

// ActionCollector GitHub 액션 메트릭을 수집하는 컬렉터입니다.
type ActionCollector struct {
        mu        sync.RWMutex
        metrics   []pkgmetrics.Metric
        publisher domain.Publisher
}

// NewActionCollector 새로운 ActionCollector를 생성합니다.
func NewActionCollector(publisher domain.Publisher) *ActionCollector <span class="cov0" title="0">{
        return &amp;ActionCollector{
                metrics:   make([]pkgmetrics.Metric, 0),
                publisher: publisher,
        }
}</span>

// AddMetric 메트릭을 추가합니다.
func (c *ActionCollector) AddMetric(metric pkgmetrics.Metric) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.metrics = append(c.metrics, metric)
        return nil
}</span>

// Collect 수집된 메트릭을 반환하고 이벤트를 발행합니다.
func (c *ActionCollector) Collect(ctx context.Context) ([]pkgmetrics.Metric, error) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        metrics := make([]pkgmetrics.Metric, len(c.metrics))
        copy(metrics, c.metrics)

        event := domain.NewMonitoringEvent(domain.TypeMetricCollected, metrics)
        if err := c.publisher.Publish(ctx, event); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c.metrics = make([]pkgmetrics.Metric, 0)
        return metrics, nil</span>
}
</pre>

                <pre class="file" id="file17" style="display: none">package alerts

import (
        "context"
        "sync"

        "github.com/aske/go_fi_chart/services/monitoring/pkg/domain"
)

// AlertLevel 알림의 심각도를 나타냅니다.
type AlertLevel = domain.AlertLevel

const (
        LevelInfo     = domain.LevelInfo
        LevelWarning  = domain.LevelWarning
        LevelError    = domain.LevelError
        LevelCritical = domain.LevelCritical
)

// Alert 모니터링 시스템의 알림을 나타냅니다.
type Alert = domain.Alert

// Notifier 알림을 처리하는 인터페이스입니다.
type Notifier interface {
        Notify(ctx context.Context, alert Alert) error
}

// SimpleNotifier 기본적인 알림 처리자 구현체입니다.
type SimpleNotifier struct {
        mu        sync.RWMutex
        publisher domain.Publisher
        handlers  []Notifier
}

// NewSimpleNotifier 새로운 SimpleNotifier를 생성합니다.
func NewSimpleNotifier(publisher domain.Publisher) *SimpleNotifier <span class="cov8" title="1">{
        return &amp;SimpleNotifier{
                publisher: publisher,
                handlers:  make([]Notifier, 0),
        }
}</span>

// AddHandler 알림 핸들러를 추가합니다.
func (n *SimpleNotifier) AddHandler(handler Notifier) <span class="cov8" title="1">{
        n.mu.Lock()
        defer n.mu.Unlock()
        n.handlers = append(n.handlers, handler)
}</span>

// RemoveHandler 알림 핸들러를 제거합니다.
func (n *SimpleNotifier) RemoveHandler(handler Notifier) <span class="cov8" title="1">{
        n.mu.Lock()
        defer n.mu.Unlock()
        for i, h := range n.handlers </span><span class="cov8" title="1">{
                if h == handler </span><span class="cov8" title="1">{
                        n.handlers = append(n.handlers[:i], n.handlers[i+1:]...)
                        break</span>
                }
        }
}

// Notify 알림을 처리하고 이벤트를 발행합니다.
func (n *SimpleNotifier) Notify(ctx context.Context, alert Alert) error <span class="cov8" title="1">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        // 모든 핸들러에게 알림 전달
        for _, handler := range n.handlers </span><span class="cov8" title="1">{
                if err := handler.Notify(ctx, alert); err != nil </span><span class="cov0" title="0">{
                        // 에러가 발생해도 다른 핸들러는 계속 실행
                        continue</span>
                }
        }

        // 알림 이벤트 발행
        <span class="cov8" title="1">evt := domain.NewMonitoringEvent(domain.TypeAlertTriggered, alert)
        if err := n.publisher.Publish(ctx, evt); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>

                <pre class="file" id="file18" style="display: none">package domain

import "time"

// EventType 이벤트 타입입니다.
type EventType string

const (
        TypeMetricCollected EventType = "metric_collected"
        TypeAlertTriggered  EventType = "alert_triggered"
)

// Event 모니터링 이벤트입니다.
type Event struct {
        Type      EventType
        Timestamp time.Time
        Data      interface{}
}

// NewMonitoringEvent 새로운 모니터링 이벤트를 생성합니다.
func NewMonitoringEvent(eventType EventType, data interface{}) Event <span class="cov0" title="0">{
        return Event{
                Type:      eventType,
                Timestamp: time.Now(),
                Data:      data,
        }
}</span>

// Handler 이벤트 핸들러 인터페이스입니다.
type Handler interface {
        Handle(event Event) error
}

// Publisher 이벤트 발행자 인터페이스입니다.
type Publisher interface {
        Publish(event Event) error
}
</pre>

                <pre class="file" id="file19" style="display: none">package prometheus

import (
        "context"
        "fmt"
        "sync"

        "github.com/aske/go_fi_chart/services/monitoring/pkg/metrics"
        "github.com/prometheus/client_golang/prometheus"
)

// Exporter Prometheus 익스포터 구현체입니다.
type Exporter struct {
        mu       sync.RWMutex
        registry *prometheus.Registry
        metrics  map[string]prometheus.Collector
}

// NewExporter 새로운 Exporter를 생성합니다.
func NewExporter() *Exporter <span class="cov8" title="1">{
        return &amp;Exporter{
                registry: prometheus.NewRegistry(),
                metrics:  make(map[string]prometheus.Collector),
        }
}</span>

// Export 메트릭을 Prometheus 형식으로 변환하여 등록합니다.
func (e *Exporter) Export(_ context.Context, metrics []metrics.Metric) error <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()

        for _, m := range metrics </span><span class="cov8" title="1">{
                collector, err := e.getOrCreateCollector(m)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("메트릭 컬렉터 생성 실패: %w", err)
                }</span>

                <span class="cov8" title="1">switch m.Type() </span>{
                case "counter":<span class="cov8" title="1">
                        if counter, ok := collector.(prometheus.Counter); ok </span><span class="cov8" title="1">{
                                counter.Add(m.Value().Raw)
                        }</span>
                case "gauge":<span class="cov8" title="1">
                        if gauge, ok := collector.(prometheus.Gauge); ok </span><span class="cov8" title="1">{
                                gauge.Set(m.Value().Raw)
                        }</span>
                case "histogram":<span class="cov8" title="1">
                        if histogram, ok := collector.(prometheus.Histogram); ok </span><span class="cov8" title="1">{
                                histogram.Observe(m.Value().Raw)
                        }</span>
                case "summary":<span class="cov8" title="1">
                        if summary, ok := collector.(prometheus.Summary); ok </span><span class="cov8" title="1">{
                                summary.Observe(m.Value().Raw)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// GetRegistry Prometheus 레지스트리를 반환합니다.
func (e *Exporter) GetRegistry() *prometheus.Registry <span class="cov0" title="0">{
        return e.registry
}</span>

// getOrCreateCollector 메트릭에 대한 Prometheus 컬렉터를 반환하거나 생성합니다.
func (e *Exporter) getOrCreateCollector(m metrics.Metric) (prometheus.Collector, error) <span class="cov8" title="1">{
        if collector, exists := e.metrics[m.Name()]; exists </span><span class="cov8" title="1">{
                return collector, nil
        }</span>

        <span class="cov8" title="1">var collector prometheus.Collector

        switch m.Type() </span>{
        case "counter":<span class="cov8" title="1">
                collector = prometheus.NewCounter(prometheus.CounterOpts{
                        Name: m.Name(),
                        Help: m.Description(),
                })</span>
        case "gauge":<span class="cov8" title="1">
                collector = prometheus.NewGauge(prometheus.GaugeOpts{
                        Name: m.Name(),
                        Help: m.Description(),
                })</span>
        case "histogram":<span class="cov8" title="1">
                collector = prometheus.NewHistogram(prometheus.HistogramOpts{
                        Name: m.Name(),
                        Help: m.Description(),
                })</span>
        case "summary":<span class="cov8" title="1">
                collector = prometheus.NewSummary(prometheus.SummaryOpts{
                        Name: m.Name(),
                        Help: m.Description(),
                })</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("지원하지 않는 메트릭 타입: %s", m.Type())</span>
        }

        <span class="cov8" title="1">if err := e.registry.Register(collector); err != nil </span><span class="cov0"
                                                                                                       title="0">{
                return nil, fmt.Errorf("메트릭 등록 실패: %w", err)
        }</span>

        <span class="cov8" title="1">e.metrics[m.Name()] = collector
        return collector, nil</span>
}
</pre>

                <pre class="file" id="file20" style="display: none">package github

import (
        "context"
        "sync"

        "github.com/aske/go_fi_chart/services/monitoring/pkg/domain"
        "github.com/aske/go_fi_chart/services/monitoring/pkg/metrics"
)

// Collector GitHub 메트릭 수집기입니다.
type Collector struct {
        metrics   []metrics.Metric
        publisher domain.Publisher
        mu        sync.RWMutex
}

// NewCollector 새로운 GitHub 메트릭 수집기를 생성합니다.
func NewCollector(publisher domain.Publisher) *Collector <span class="cov0" title="0">{
        return &amp;Collector{
                publisher: publisher,
        }
}</span>

// Add 메트릭을 추가합니다.
func (c *Collector) Add(metric metrics.Metric) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.metrics = append(c.metrics, metric)
}</span>

// Collect 메트릭을 수집하고 이벤트를 발행합니다.
func (c *Collector) Collect(ctx context.Context) ([]metrics.Metric, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        result := make([]metrics.Metric, len(c.metrics))
        copy(result, c.metrics)

        for _, metric := range c.metrics </span><span class="cov0" title="0">{
                event := domain.NewMonitoringEvent(domain.TypeMetricCollected, metric)
                if err := c.publisher.Publish(ctx, event); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">c.metrics = make([]metrics.Metric, 0)
        return result, nil</span>
}

// Metrics 수집된 메트릭 목록을 반환합니다.
func (c *Collector) Metrics() []metrics.Metric <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        result := make([]metrics.Metric, len(c.metrics))
        copy(result, c.metrics)
        return result
}</span>
</pre>

                <pre class="file" id="file21" style="display: none">package github

import (
        "time"

        "github.com/aske/go_fi_chart/services/monitoring/pkg/metrics"
)

// ActionStatus GitHub 액션의 상태입니다.
type ActionStatus string

const (
        ActionStatusSuccess ActionStatus = "success"
        ActionStatusFailure ActionStatus = "failure"
        ActionStatusSkipped ActionStatus = "skipped"
)

// ActionStatusMetric GitHub 액션 상태 메트릭입니다.
type ActionStatusMetric struct {
        name   string
        status ActionStatus
}

// NewActionStatusMetric 새로운 액션 상태 메트릭을 생성합니다.
func NewActionStatusMetric(name string, status ActionStatus) *ActionStatusMetric <span class="cov0" title="0">{
        return &amp;ActionStatusMetric{
                name:   name,
                status: status,
        }
}</span>

// Name 메트릭 이름을 반환합니다.
func (m *ActionStatusMetric) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

// Type 메트릭 타입을 반환합니다.
func (m *ActionStatusMetric) Type() metrics.Type <span class="cov0" title="0">{
        return metrics.TypeGauge
}</span>

// Value 메트릭 값을 반환합니다.
func (m *ActionStatusMetric) Value() metrics.Value <span class="cov0" title="0">{
        var value float64
        switch m.status </span>{
        case ActionStatusSuccess:<span class="cov0" title="0">
                value = 1</span>
        case ActionStatusFailure:<span class="cov0" title="0">
                value = 0</span>
        case ActionStatusSkipped:<span class="cov0" title="0">
                value = -1</span>
        default:<span class="cov0" title="0">
                value = -2</span>
        }

        <span class="cov0" title="0">return metrics.NewValue(value, map[string]string{
                "action": m.name,
        })</span>
}

// Description 메트릭 설명을 반환합니다.
func (m *ActionStatusMetric) Description() string <span class="cov0" title="0">{
        return "GitHub 액션 실행 상태"
}</span>

// ActionDurationMetric GitHub 액션 실행 시간 메트릭입니다.
type ActionDurationMetric struct {
        name     string
        duration time.Duration
}

// NewActionDurationMetric 새로운 액션 실행 시간 메트릭을 생성합니다.
func NewActionDurationMetric(name string, duration time.Duration) *ActionDurationMetric <span class="cov0" title="0">{
        return &amp;ActionDurationMetric{
                name:     name,
                duration: duration,
        }
}</span>

// Name 메트릭 이름을 반환합니다.
func (m *ActionDurationMetric) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

// Type 메트릭 타입을 반환합니다.
func (m *ActionDurationMetric) Type() metrics.Type <span class="cov0" title="0">{
        return metrics.TypeGauge
}</span>

// Value 메트릭 값을 반환합니다.
func (m *ActionDurationMetric) Value() metrics.Value <span class="cov0" title="0">{
        return metrics.NewValue(m.duration.Seconds(), map[string]string{
                "action": m.name,
        })
}</span>

// Description 메트릭 설명을 반환합니다.
func (m *ActionDurationMetric) Description() string <span class="cov0" title="0">{
        return "GitHub 액션 실행 시간 (초)"
}</span>
</pre>

                <pre class="file" id="file22" style="display: none">package metrics

import (
        "context"
        "sync"

        "github.com/aske/go_fi_chart/services/monitoring/pkg/domain"
        pkgmetrics "github.com/aske/go_fi_chart/services/monitoring/pkg/metrics"
)

// BaseCollector 모든 컬렉터의 기본 구현을 제공합니다.
type BaseCollector struct {
        mu        sync.RWMutex
        metrics   []pkgmetrics.Metric
        publisher domain.Publisher
}

// NewBaseCollector 새로운 BaseCollector를 생성합니다.
func NewBaseCollector(publisher domain.Publisher) *BaseCollector <span class="cov8" title="1">{
        return &amp;BaseCollector{
                metrics:   make([]pkgmetrics.Metric, 0),
                publisher: publisher,
        }
}</span>

// AddMetric 메트릭을 추가합니다.
func (c *BaseCollector) AddMetric(metric pkgmetrics.Metric) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.metrics = append(c.metrics, metric)
        return nil
}</span>

// Collect 수집된 메트릭을 반환하고 이벤트를 발행합니다.
func (c *BaseCollector) Collect(ctx context.Context) ([]pkgmetrics.Metric, error) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        metrics := make([]pkgmetrics.Metric, len(c.metrics))
        copy(metrics, c.metrics)

        evt := domain.NewMonitoringEvent(domain.TypeMetricCollected, metrics)
        if err := c.publisher.Publish(ctx, evt); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c.metrics = make([]pkgmetrics.Metric, 0)
        return metrics, nil</span>
}

// Reset 수집된 메트릭을 초기화합니다.
func (c *BaseCollector) Reset() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.metrics = make([]pkgmetrics.Metric, 0)
}</span>

// SimpleCollector 기본적인 메트릭 수집기 구현체입니다.
type SimpleCollector struct {
        *BaseCollector
}

// NewSimpleCollector 새로운 SimpleCollector를 생성합니다.
func NewSimpleCollector(publisher domain.Publisher) *SimpleCollector <span class="cov8" title="1">{
        return &amp;SimpleCollector{
                BaseCollector: NewBaseCollector(publisher),
        }
}</span>

// AddMetric 메트릭을 추가합니다.
func (c *SimpleCollector) AddMetric(metric pkgmetrics.Metric) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.metrics = append(c.metrics, metric)
        return nil
}</span>

// Collect 수집된 메트릭을 반환하고 이벤트를 발행합니다.
func (c *SimpleCollector) Collect(ctx context.Context) ([]pkgmetrics.Metric, error) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        metrics := make([]pkgmetrics.Metric, len(c.metrics))
        copy(metrics, c.metrics)

        evt := domain.NewMonitoringEvent(domain.TypeMetricCollected, metrics)
        if err := c.publisher.Publish(ctx, evt); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">c.metrics = make([]pkgmetrics.Metric, 0)
        return metrics, nil</span>
}

// Reset 수집된 메트릭을 초기화합니다.
func (c *SimpleCollector) Reset() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.metrics = make([]pkgmetrics.Metric, 0)
}</span>
</pre>

                <pre class="file" id="file23" style="display: none">package github

import (
        "context"
        "sync"
        "time"

        "github.com/aske/go_fi_chart/services/monitoring/pkg/domain"
        pkgmetrics "github.com/aske/go_fi_chart/services/monitoring/pkg/metrics"
)

// Collector GitHub 메트릭을 수집하는 컬렉터입니다.
type Collector struct {
        mu        sync.RWMutex
        metrics   []pkgmetrics.Metric
        publisher domain.Publisher
}

// NewCollector 새로운 GitHub 메트릭 컬렉터를 생성합니다.
func NewCollector(publisher domain.Publisher) *Collector <span class="cov8" title="1">{
        return &amp;Collector{
                metrics:   make([]pkgmetrics.Metric, 0),
                publisher: publisher,
        }
}</span>

// AddActionStatusMetric GitHub 액션 상태 메트릭을 추가합니다.
func (c *Collector) AddActionStatusMetric(name string, status ActionStatus) error <span class="cov8" title="1">{
        metric := NewActionMetric(name, status, 0)
        c.mu.Lock()
        defer c.mu.Unlock()
        c.metrics = append(c.metrics, metric.ToMetric())
        return nil
}</span>

// AddActionDurationMetric GitHub 액션 실행 시간 메트릭을 추가합니다.
func (c *Collector) AddActionDurationMetric(name string, duration time.Duration) error <span class="cov8" title="1">{
        metric := NewActionMetric(name, ActionStatusSuccess, duration)
        c.mu.Lock()
        defer c.mu.Unlock()
        c.metrics = append(c.metrics, metric.ToMetric())
        if metric.Duration &gt; 0 </span><span class="cov8" title="1">{
                c.metrics = append(c.metrics, metric.ToDurationMetric())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Collect 수집된 메트릭을 반환하고 이벤트를 발행합니다.
func (c *Collector) Collect(ctx context.Context) ([]pkgmetrics.Metric, error) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        metrics := make([]pkgmetrics.Metric, len(c.metrics))
        copy(metrics, c.metrics)

        evt := domain.NewMonitoringEvent(domain.TypeMetricCollected, metrics)
        if err := c.publisher.Publish(ctx, evt); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">c.metrics = make([]pkgmetrics.Metric, 0)
        return metrics, nil</span>
}

// Reset 수집된 메트릭을 초기화합니다.
func (c *Collector) Reset() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.metrics = make([]pkgmetrics.Metric, 0)
}</span>
</pre>

                <pre class="file" id="file24" style="display: none">package github

import (
        "time"

        "github.com/aske/go_fi_chart/services/monitoring/pkg/metrics"
)

// ActionStatus GitHub 액션의 상태를 나타냅니다.
type ActionStatus string

const (
        ActionStatusSuccess    ActionStatus = "success"
        ActionStatusFailure    ActionStatus = "failure"
        ActionStatusInProgress ActionStatus = "in_progress"
)

// ActionMetric GitHub Actions 실행 메트릭을 나타냅니다.
type ActionMetric struct {
        WorkflowName string
        Status       ActionStatus
        Duration     time.Duration
        StartedAt    time.Time
        FinishedAt   time.Time
}

// NewActionMetric 새로운 액션 메트릭을 생성합니다.
func NewActionMetric(name string, status ActionStatus, duration time.Duration) ActionMetric <span class="cov8"
                                                                                                  title="1">{
        now := time.Now()
        return ActionMetric{
                WorkflowName: name,
                Status:       status,
                Duration:     duration,
                StartedAt:    now.Add(-duration),
                FinishedAt:   now,
        }
}</span>

// ToMetric 액션 메트릭을 일반 메트릭으로 변환합니다.
func (m ActionMetric) ToMetric() metrics.Metric <span class="cov8" title="1">{
        var value float64
        switch m.Status </span>{
        case ActionStatusSuccess:<span class="cov8" title="1">
                value = 1</span>
        case ActionStatusFailure:<span class="cov8" title="1">
                value = 0</span>
        case ActionStatusInProgress:<span class="cov8" title="1">
                value = 2</span>
        default:<span class="cov8" title="1">
                value = -1</span>
        }

        <span class="cov8" title="1">return metrics.NewBaseMetric(
                m.WorkflowName,
                metrics.TypeGauge,
                metrics.NewValue(value, map[string]string{
                        "status": string(m.Status),
                }),
                "GitHub 액션 실행 상태",
        )</span>
}

// ToDurationMetric 액션 실행 시간 메트릭을 생성합니다.
func (m ActionMetric) ToDurationMetric() metrics.Metric <span class="cov8" title="1">{
        return metrics.NewBaseMetric(
                m.WorkflowName+"_duration",
                metrics.TypeGauge,
                metrics.NewValue(m.Duration.Seconds(), map[string]string{
                        "action": m.WorkflowName,
                }),
                "GitHub 액션 실행 시간 (초)",
        )
}</span>
</pre>

                <pre class="file" id="file25" style="display: none">package simple

import (
        "github.com/aske/go_fi_chart/services/monitoring/internal/metrics"
)

// Metric 기본 메트릭 구현체입니다.
type Metric struct {
        name        string
        metricType  metrics.Type
        value       metrics.Value
        description string
}

// NewMetric 새로운 메트릭을 생성합니다.
func NewMetric(name string, metricType metrics.Type, value float64, description string) *Metric <span class="cov0"
                                                                                                      title="0">{
        return &amp;Metric{
                name:        name,
                metricType:  metricType,
                value:       metrics.NewValue(value, nil),
                description: description,
        }
}</span>

// Name 메트릭의 이름을 반환합니다.
func (m *Metric) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

// Type 메트릭의 타입을 반환합니다.
func (m *Metric) Type() metrics.Type <span class="cov0" title="0">{
        return m.metricType
}</span>

// Value 메트릭의 값을 반환합니다.
func (m *Metric) Value() metrics.Value <span class="cov0" title="0">{
        return m.value
}</span>

// Description 메트릭의 설명을 반환합니다.
func (m *Metric) Description() string <span class="cov0" title="0">{
        return m.description
}</span>

// WithLabels 레이블이 추가된 새로운 메트릭을 반환합니다.
func (m *Metric) WithLabels(labels map[string]string) *Metric <span class="cov0" title="0">{
        return &amp;Metric{
                name:        m.name,
                metricType:  m.metricType,
                value:       m.value.WithLabels(labels),
                description: m.description,
        }
}</span>
</pre>

                <pre class="file" id="file26" style="display: none">package metrics

import (
        "context"
        "time"
)

// Type 메트릭의 타입을 나타냅니다.
type Type string

const (
        TypeCounter   Type = "counter"
        TypeGauge     Type = "gauge"
        TypeHistogram Type = "histogram"
        TypeSummary   Type = "summary"
)

// Value 메트릭의 값을 나타냅니다.
type Value struct {
        Raw       float64           `json:"raw"`
        Labels    map[string]string `json:"labels,omitempty"`
        Timestamp time.Time         `json:"timestamp"`
}

// NewValue 새로운 메트릭 값을 생성합니다.
func NewValue(raw float64, labels map[string]string) Value <span class="cov0" title="0">{
        return Value{
                Raw:       raw,
                Labels:    labels,
                Timestamp: time.Now(),
        }
}</span>

// WithLabel 레이블을 추가한 새로운 Value를 반환합니다.
func (v Value) WithLabel(key, value string) Value <span class="cov0" title="0">{
        newLabels := make(map[string]string, len(v.Labels)+1)
        for k, v := range v.Labels </span><span class="cov0" title="0">{
                newLabels[k] = v
        }</span>
        <span class="cov0" title="0">newLabels[key] = value
        return Value{
                Raw:       v.Raw,
                Labels:    newLabels,
                Timestamp: v.Timestamp,
        }</span>
}

// WithLabels 여러 레이블을 추가한 새로운 Value를 반환합니다.
func (v Value) WithLabels(labels map[string]string) Value <span class="cov0" title="0">{
        newLabels := make(map[string]string, len(v.Labels)+len(labels))
        for k, v := range v.Labels </span><span class="cov0" title="0">{
                newLabels[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range labels </span><span class="cov0" title="0">{
                newLabels[k] = v
        }</span>
        <span class="cov0" title="0">return Value{
                Raw:       v.Raw,
                Labels:    newLabels,
                Timestamp: v.Timestamp,
        }</span>
}

// Metric 메트릭 인터페이스입니다.
type Metric interface {
        // Name 메트릭의 이름을 반환합니다.
        Name() string
        // Type 메트릭의 타입을 반환합니다.
        Type() Type
        // Value 메트릭의 값을 반환합니다.
        Value() Value
        // Description 메트릭의 설명을 반환합니다.
        Description() string
}

// Collector 메트릭 수집기 인터페이스입니다.
type Collector interface {
        // Collect 메트릭을 수집합니다.
        Collect(ctx context.Context) ([]Metric, error)
}
</pre>

                <pre class="file" id="file27" style="display: none">package collectors

import (
        "context"
        "sync"

        "github.com/aske/go_fi_chart/services/monitoring/metrics/domain"
)

// BaseCollector 모든 컬렉터의 기본 구현을 제공합니다.
type BaseCollector struct {
        mu        sync.RWMutex
        metrics   []domain.Metric
        publisher domain.Publisher
}

// NewBaseCollector 새로운 BaseCollector를 생성합니다.
func NewBaseCollector(publisher domain.Publisher) *BaseCollector <span class="cov8" title="1">{
        return &amp;BaseCollector{
                metrics:   make([]domain.Metric, 0),
                publisher: publisher,
        }
}</span>

// AddMetric 메트릭을 추가합니다.
func (c *BaseCollector) AddMetric(metric domain.Metric) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.metrics = append(c.metrics, metric)
        return nil
}</span>

// Collect 수집된 메트릭을 반환하고 이벤트를 발행합니다.
func (c *BaseCollector) Collect(ctx context.Context) ([]domain.Metric, error) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        metrics := make([]domain.Metric, len(c.metrics))
        copy(metrics, c.metrics)

        if err := c.publisher.Publish(ctx, metrics); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">c.metrics = make([]domain.Metric, 0)
        return metrics, nil</span>
}

// Reset 수집된 메트릭을 초기화합니다.
func (c *BaseCollector) Reset() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.metrics = make([]domain.Metric, 0)
}</span>
</pre>

                <pre class="file" id="file28" style="display: none">package collectors

import (
        "github.com/aske/go_fi_chart/services/monitoring/metrics/domain"
)

// SimpleCollector 기본적인 메트릭 수집기 구현체입니다.
type SimpleCollector struct {
        *BaseCollector
}

// NewSimpleCollector 새로운 SimpleCollector를 생성합니다.
func NewSimpleCollector(publisher domain.Publisher) *SimpleCollector <span class="cov8" title="1">{
        return &amp;SimpleCollector{
                BaseCollector: NewBaseCollector(publisher),
        }
}</span>
</pre>

                <pre class="file" id="file29" style="display: none">package domain

// BaseMetric 기본 메트릭 구현체입니다.
type BaseMetric struct {
        name        string
        metricType  Type
        value       Value
        description string
}

// NewBaseMetric 새로운 BaseMetric을 생성합니다.
func NewBaseMetric(name string, metricType Type, value Value, description string) *BaseMetric <span class="cov8"
                                                                                                    title="1">{
        return &amp;BaseMetric{
                name:        name,
                metricType:  metricType,
                value:       value,
                description: description,
        }
}</span>

// Name 메트릭의 이름을 반환합니다.
func (m *BaseMetric) Name() string <span class="cov8" title="1">{
        return m.name
}</span>

// Type 메트릭의 타입을 반환합니다.
func (m *BaseMetric) Type() Type <span class="cov8" title="1">{
        return m.metricType
}</span>

// Value 메트릭의 값을 반환합니다.
func (m *BaseMetric) Value() Value <span class="cov8" title="1">{
        return m.value
}</span>

// Description 메트릭의 설명을 반환합니다.
func (m *BaseMetric) Description() string <span class="cov8" title="1">{
        return m.description
}</span>
</pre>

                <pre class="file" id="file30" style="display: none">package domain

import (
        "context"
        "time"
)

// Type 메트릭의 타입을 나타냅니다.
type Type string

const (
        // TypeCounter 카운터 타입 메트릭입니다.
        TypeCounter Type = "counter"
        // TypeGauge 게이지 타입 메트릭입니다.
        TypeGauge Type = "gauge"
        // TypeHistogram 히스토그램 타입 메트릭입니다.
        TypeHistogram Type = "histogram"
        // TypeSummary 요약 타입 메트릭입니다.
        TypeSummary Type = "summary"
)

// Value 메트릭의 값을 나타냅니다.
type Value struct {
        Raw       float64           `json:"raw"`
        Labels    map[string]string `json:"labels,omitempty"`
        Timestamp time.Time         `json:"timestamp"`
}

// NewValue 새로운 메트릭 값을 생성합니다.
func NewValue(raw float64, labels map[string]string) Value <span class="cov8" title="1">{
        return Value{
                Raw:       raw,
                Labels:    labels,
                Timestamp: time.Now(),
        }
}</span>

// WithLabel 레이블을 추가한 새로운 Value를 반환합니다.
func (v Value) WithLabel(key, value string) Value <span class="cov8" title="1">{
        newLabels := make(map[string]string, len(v.Labels)+1)
        for k, v := range v.Labels </span><span class="cov8" title="1">{
                newLabels[k] = v
        }</span>
        <span class="cov8" title="1">newLabels[key] = value
        return Value{
                Raw:       v.Raw,
                Labels:    newLabels,
                Timestamp: v.Timestamp,
        }</span>
}

// WithLabels 여러 레이블을 추가한 새로운 Value를 반환합니다.
func (v Value) WithLabels(labels map[string]string) Value <span class="cov8" title="1">{
        newLabels := make(map[string]string, len(v.Labels)+len(labels))
        for k, v := range v.Labels </span><span class="cov8" title="1">{
                newLabels[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range labels </span><span class="cov8" title="1">{
                newLabels[k] = v
        }</span>
        <span class="cov8" title="1">return Value{
                Raw:       v.Raw,
                Labels:    newLabels,
                Timestamp: v.Timestamp,
        }</span>
}

// Metric 메트릭 인터페이스입니다.
type Metric interface {
        // Name 메트릭의 이름을 반환합니다.
        Name() string
        // Type 메트릭의 타입을 반환합니다.
        Type() Type
        // Value 메트릭의 값을 반환합니다.
        Value() Value
        // Description 메트릭의 설명을 반환합니다.
        Description() string
}

// Collector 메트릭 수집기 인터페이스입니다.
type Collector interface {
        // Collect 메트릭을 수집합니다.
        Collect(ctx context.Context) ([]Metric, error)
        // AddMetric 메트릭을 추가합니다.
        AddMetric(metric Metric) error
        // Reset 수집된 메트릭을 초기화합니다.
        Reset()
}

// Publisher 메트릭 이벤트 발행자 인터페이스입니다.
type Publisher interface {
        // Publish 메트릭 이벤트를 발행합니다.
        Publish(ctx context.Context, metrics []Metric) error
}

// Event 메트릭 이벤트입니다.
type Event struct {
        Type      string
        Metrics   []Metric
        Timestamp time.Time
}

const (
        // TypeMetricCollected 메트릭 수집 이벤트 타입입니다.
        TypeMetricCollected = "metric.collected"
)
</pre>

                <pre class="file" id="file31" style="display: none">package domain

import (
        "context"
        "time"
)

// EventType 이벤트 타입입니다.
type EventType string

const (
        TypeMetricCollected EventType = "metric_collected"
        TypeAlertTriggered  EventType = "alert_triggered"
)

// Event 모니터링 이벤트입니다.
type Event struct {
        Type      EventType
        Timestamp time.Time
        Data      interface{}
}

// NewMonitoringEvent 새로운 모니터링 이벤트를 생성합니다.
func NewMonitoringEvent(eventType EventType, data interface{}) Event <span class="cov0" title="0">{
        return Event{
                Type:      eventType,
                Timestamp: time.Now(),
                Data:      data,
        }
}</span>

// Handler 이벤트 핸들러 인터페이스입니다.
type Handler interface {
        Handle(ctx context.Context, event Event) error
}

// Publisher 이벤트 발행자 인터페이스입니다.
type Publisher interface {
        Publish(ctx context.Context, event Event) error
        Subscribe(handler Handler) error
        Unsubscribe(handler Handler) error
}

// MetricType 메트릭의 타입을 나타냅니다.
type MetricType string

const (
        TypeCounter   MetricType = "counter"
        TypeGauge     MetricType = "gauge"
        TypeHistogram MetricType = "histogram"
        TypeSummary   MetricType = "summary"
)

// MetricValue 메트릭의 값을 나타냅니다.
type MetricValue struct {
        Raw       float64
        Labels    map[string]string
        Timestamp time.Time
}

// NewMetricValue 새로운 메트릭 값을 생성합니다.
func NewMetricValue(raw float64, labels map[string]string) MetricValue <span class="cov0" title="0">{
        return MetricValue{
                Raw:       raw,
                Labels:    labels,
                Timestamp: time.Now(),
        }
}</span>

// Metric 메트릭 인터페이스입니다.
type Metric interface {
        Name() string
        Type() MetricType
        Value() MetricValue
        Description() string
}

// Collector 메트릭 수집기 인터페이스입니다.
type Collector interface {
        Collect(ctx context.Context) ([]Metric, error)
}

// AlertLevel 알림의 심각도를 나타냅니다.
type AlertLevel string

const (
        LevelInfo     AlertLevel = "INFO"
        LevelWarning  AlertLevel = "WARNING"
        LevelError    AlertLevel = "ERROR"
        LevelCritical AlertLevel = "CRITICAL"
)

// Alert 알림을 나타냅니다.
type Alert struct {
        ID        string
        Level     AlertLevel
        Source    string
        Message   string
        Timestamp time.Time
        Metadata  map[string]string
}

// NewAlert 새로운 알림을 생성합니다.
func NewAlert(id, source, message string, level AlertLevel, metadata map[string]string) Alert <span class="cov0"
                                                                                                    title="0">{
        return Alert{
                ID:        id,
                Level:     level,
                Source:    source,
                Message:   message,
                Timestamp: time.Now(),
                Metadata:  metadata,
        }
}</span>

// Notifier 알림 처리자 인터페이스입니다.
type Notifier interface {
        Notify(ctx context.Context, alert Alert) error
}
</pre>

                <pre class="file" id="file32" style="display: none">package health

import (
        "context"
        "sync"
        "time"
)

// Status 서비스의 상태를 나타냅니다.
type Status string

const (
        StatusUp   Status = "UP"
        StatusDown Status = "DOWN"
)

// Check 헬스 체크 결과를 나타냅니다.
type Check struct {
        Status    Status    `json:"status"`
        Timestamp time.Time `json:"timestamp"`
        Error     string    `json:"error,omitempty"`
}

// Checker 서비스 상태를 체크하는 인터페이스입니다.
type Checker interface {
        // Check 현재 서비스의 상태를 확인합니다.
        Check(ctx context.Context) Check
}

// SimpleChecker 기본적인 상태 체크 구현체입니다.
type SimpleChecker struct {
        mu     sync.RWMutex
        status Status
        err    error
}

// NewSimpleChecker 새로운 SimpleChecker를 생성합니다.
func NewSimpleChecker() *SimpleChecker <span class="cov8" title="1">{
        return &amp;SimpleChecker{
                status: StatusUp,
        }
}</span>

// Check 현재 서비스의 상태를 반환합니다.
func (c *SimpleChecker) Check(_ context.Context) Check <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        var errStr string
        if c.err != nil </span><span class="cov8" title="1">{
                errStr = c.err.Error()
        }</span>

        <span class="cov8" title="1">return Check{
                Status:    c.status,
                Timestamp: time.Now(),
                Error:     errStr,
        }</span>
}

// SetStatus 서비스의 상태를 설정합니다.
func (c *SimpleChecker) SetStatus(status Status, err error) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.status = status
        c.err = err
}</span>
</pre>

                <pre class="file" id="file33" style="display: none">package metrics

import (
        "context"
        "time"

        "github.com/aske/go_fi_chart/services/monitoring/pkg/domain"
)

// Type 메트릭의 타입을 나타냅니다.
type Type = domain.MetricType

const (
        // TypeCounter 카운터 타입 메트릭입니다.
        TypeCounter = domain.TypeCounter
        // TypeGauge 게이지 타입 메트릭입니다.
        TypeGauge = domain.TypeGauge
        // TypeHistogram 히스토그램 타입 메트릭입니다.
        TypeHistogram = domain.TypeHistogram
        // TypeSummary 요약 타입 메트릭입니다.
        TypeSummary = domain.TypeSummary
)

// Value 메트릭의 값을 나타냅니다.
type Value struct {
        Raw       float64           `json:"raw"`
        Labels    map[string]string `json:"labels,omitempty"`
        Timestamp time.Time         `json:"timestamp"`
}

// NewValue 새로운 메트릭 값을 생성합니다.
func NewValue(raw float64, labels map[string]string) Value <span class="cov0" title="0">{
        domainValue := domain.NewMetricValue(raw, labels)
        return Value{
                Raw:       domainValue.Raw,
                Labels:    domainValue.Labels,
                Timestamp: domainValue.Timestamp,
        }
}</span>

// WithLabel 레이블을 추가한 새로운 Value를 반환합니다.
func (v Value) WithLabel(key, value string) Value <span class="cov0" title="0">{
        newLabels := make(map[string]string, len(v.Labels)+1)
        for k, v := range v.Labels </span><span class="cov0" title="0">{
                newLabels[k] = v
        }</span>
        <span class="cov0" title="0">newLabels[key] = value
        return Value{
                Raw:       v.Raw,
                Labels:    newLabels,
                Timestamp: v.Timestamp,
        }</span>
}

// WithLabels 여러 레이블을 추가한 새로운 Value를 반환합니다.
func (v Value) WithLabels(labels map[string]string) Value <span class="cov0" title="0">{
        newLabels := make(map[string]string, len(v.Labels)+len(labels))
        for k, v := range v.Labels </span><span class="cov0" title="0">{
                newLabels[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range labels </span><span class="cov0" title="0">{
                newLabels[k] = v
        }</span>
        <span class="cov0" title="0">return Value{
                Raw:       v.Raw,
                Labels:    newLabels,
                Timestamp: v.Timestamp,
        }</span>
}

// Metric 메트릭 인터페이스입니다.
type Metric interface {
        // Name 메트릭의 이름을 반환합니다.
        Name() string
        // Type 메트릭의 타입을 반환합니다.
        Type() Type
        // Value 메트릭의 값을 반환합니다.
        Value() Value
        // Description 메트릭의 설명을 반환합니다.
        Description() string
}

// Collector 메트릭 수집기 인터페이스입니다.
type Collector interface {
        // Collect 메트릭을 수집합니다.
        Collect(ctx context.Context) ([]Metric, error)
}

// BaseMetric 기본 메트릭 구현체입니다.
type BaseMetric struct {
        name        string
        metricType  Type
        value       Value
        description string
}

// NewBaseMetric 새로운 BaseMetric을 생성합니다.
func NewBaseMetric(name string, metricType Type, value Value, description string) *BaseMetric <span class="cov0"
                                                                                                    title="0">{
        return &amp;BaseMetric{
                name:        name,
                metricType:  metricType,
                value:       value,
                description: description,
        }
}</span>

// Name 메트릭의 이름을 반환합니다.
func (m *BaseMetric) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

// Type 메트릭의 타입을 반환합니다.
func (m *BaseMetric) Type() Type <span class="cov0" title="0">{
        return m.metricType
}</span>

// Value 메트릭의 값을 반환합니다.
func (m *BaseMetric) Value() Value <span class="cov0" title="0">{
        return m.value
}</span>

// Description 메트릭의 설명을 반환합니다.
func (m *BaseMetric) Description() string <span class="cov0" title="0">{
        return m.description
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
