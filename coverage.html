
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/aske/go_fi_chart/cmd/server/main.go (0.0%)</option>

                        <option value="file1">github.com/aske/go_fi_chart/internal/config/config.go (0.0%)</option>

                        <option value="file2">github.com/aske/go_fi_chart/internal/di/container.go (0.0%)</option>

                        <option value="file3">github.com/aske/go_fi_chart/internal/domain/asset/id_generator.go
                                (100.0%)
                        </option>

                        <option value="file4">github.com/aske/go_fi_chart/internal/domain/asset/memory_repository.go
                                (76.0%)
                        </option>

                        <option value="file5">github.com/aske/go_fi_chart/internal/domain/asset/model.go (100.0%)
                        </option>

                        <option value="file6">github.com/aske/go_fi_chart/internal/domain/asset/test_fixture.go
                                (100.0%)
                        </option>

                        <option value="file7">github.com/aske/go_fi_chart/internal/domain/error.go (0.0%)</option>

                        <option value="file8">github.com/aske/go_fi_chart/internal/domain/event.go (0.0%)</option>

                        <option value="file9">github.com/aske/go_fi_chart/internal/domain/repository.go (0.0%)</option>

                        <option value="file10">github.com/aske/go_fi_chart/internal/infrastructure/events/event.go
                                (0.0%)
                        </option>

                        <option value="file11">github.com/aske/go_fi_chart/metrics/github/collector.go (0.0%)</option>

                        <option value="file12">github.com/aske/go_fi_chart/services/monitoring/internal/alerts/alert.go
                                (89.5%)
                        </option>

                        <option value="file13">
                                github.com/aske/go_fi_chart/services/monitoring/internal/exporters/prometheus/exporter.go
                                (93.5%)
                        </option>

                        <option value="file14">
                                github.com/aske/go_fi_chart/services/monitoring/internal/metrics/collector.go (94.1%)
                        </option>

                        <option value="file15">
                                github.com/aske/go_fi_chart/services/monitoring/internal/metrics/github/collector.go
                                (90.5%)
                        </option>

                        <option value="file16">github.com/aske/go_fi_chart/services/monitoring/pkg/health/checker.go
                                (100.0%)
                        </option>

                </select>
			</div>
			<div id="legend">
				<span>not tracked</span>

                    <span class="cov0">not covered</span>
                    <span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"
        "net/http"
        "time"
)

func main() <span class="cov0" title="0">{
        log.Println("FIN-RPG 서버 시작 중...")

        // TODO: 의존성 주입 설정
        // TODO: 라우터 설정
        // TODO: 미들웨어 설정
        // TODO: 데이터베이스 연결

        srv := &amp;http.Server{
                Addr:              ":8080",
                ReadTimeout:       5 * time.Second,
                WriteTimeout:      10 * time.Second,
                IdleTimeout:       120 * time.Second,
                ReadHeaderTimeout: 2 * time.Second,
        }

        log.Println("서버가 시작되었습니다. :8080 포트에서 대기 중...")
        if err := srv.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("서버 시작 실패: %v", err)
        }</span>
}
</pre>

                <pre class="file" id="file1" style="display: none">package config

import "time"

// Config 애플리케이션 전체 설정입니다.
type Config struct {
        Server   ServerConfig   `yaml:"server"`
        Metrics  MetricsConfig  `yaml:"metrics"`
        Database DatabaseConfig `yaml:"database"`
}

// ServerConfig HTTP 서버 설정입니다.
type ServerConfig struct {
        Host            string        `yaml:"host"`
        Port            int           `yaml:"port"`
        ReadTimeout     time.Duration `yaml:"readTimeout"`
        WriteTimeout    time.Duration `yaml:"writeTimeout"`
        IdleTimeout     time.Duration `yaml:"idleTimeout"`
        ShutdownTimeout time.Duration `yaml:"shutdownTimeout"`
}

// MetricsConfig 메트릭 설정입니다.
type MetricsConfig struct {
        Enabled         bool          `yaml:"enabled"`
        CollectInterval time.Duration `yaml:"collectInterval"`
        ExportInterval  time.Duration `yaml:"exportInterval"`
        RetentionPeriod time.Duration `yaml:"retentionPeriod"`
}

// DatabaseConfig 데이터베이스 설정입니다.
type DatabaseConfig struct {
        Driver          string        `yaml:"driver"`
        Host            string        `yaml:"host"`
        Port            int           `yaml:"port"`
        Name            string        `yaml:"name"`
        User            string        `yaml:"user"`
        Password        string        `yaml:"password"`
        ConnectTimeout  time.Duration `yaml:"connectTimeout"`
        MaxOpenConns    int           `yaml:"maxOpenConns"`
        MaxIdleConns    int           `yaml:"maxIdleConns"`
        ConnMaxLifetime time.Duration `yaml:"connMaxLifetime"`
}

// NewDefaultConfig 기본 설정값을 가진 Config를 생성합니다.
func NewDefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Server: ServerConfig{
                        Host:            "localhost",
                        Port:            8080,
                        ReadTimeout:     5 * time.Second,
                        WriteTimeout:    10 * time.Second,
                        IdleTimeout:     120 * time.Second,
                        ShutdownTimeout: 5 * time.Second,
                },
                Metrics: MetricsConfig{
                        Enabled:         true,
                        CollectInterval: 10 * time.Second,
                        ExportInterval:  30 * time.Second,
                        RetentionPeriod: 24 * time.Hour,
                },
                Database: DatabaseConfig{
                        Driver:          "postgres",
                        Host:            "localhost",
                        Port:            5432,
                        ConnectTimeout:  5 * time.Second,
                        MaxOpenConns:    25,
                        MaxIdleConns:    5,
                        ConnMaxLifetime: 5 * time.Minute,
                },
        }
}</span>
</pre>

                <pre class="file" id="file2" style="display: none">package di

import (
        "fmt"
        "reflect"
        "sync"
)

// Container 의존성 주입 컨테이너 인터페이스입니다.
type Container interface {
        // Register 의존성을 등록합니다.
        Register(name string, constructor interface{}) error
        // Resolve 의존성을 해결합니다.
        Resolve(name string) (interface{}, error)
}

// SimpleContainer 기본 의존성 주입 컨테이너 구현체입니다.
type SimpleContainer struct {
        mu           sync.RWMutex
        constructors map[string]interface{}
        instances    map[string]interface{}
}

// NewSimpleContainer 새로운 SimpleContainer를 생성합니다.
func NewSimpleContainer() *SimpleContainer <span class="cov0" title="0">{
        return &amp;SimpleContainer{
                constructors: make(map[string]interface{}),
                instances:    make(map[string]interface{}),
        }
}</span>

// Register 의존성 생성자를 등록합니다.
func (c *SimpleContainer) Register(name string, constructor interface{}) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if constructor == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("constructor cannot be nil")
        }</span>

        <span class="cov0" title="0">if _, exists := c.constructors[name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("dependency %s already registered", name)
        }</span>

        <span class="cov0" title="0">c.constructors[name] = constructor
        return nil</span>
}

// Resolve 의존성을 해결하고 인스턴스를 반환합니다.
func (c *SimpleContainer) Resolve(name string) (interface{}, error) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // 이미 생성된 인스턴스가 있는지 확인
        if instance, exists := c.instances[name]; exists </span><span class="cov0" title="0">{
                return instance, nil
        }</span>

        // 생성자 찾기
        <span class="cov0" title="0">constructor, exists := c.constructors[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dependency %s not registered", name)
        }</span>

        // 생성자 호출
        <span class="cov0" title="0">constructorValue := reflect.ValueOf(constructor)
        if constructorValue.Kind() != reflect.Func </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("constructor for %s must be a function", name)
        }</span>

        // 생성자 파라미터 해결
        <span class="cov0" title="0">params := make([]reflect.Value, constructorValue.Type().NumIn())
        for i := 0; i &lt; constructorValue.Type().NumIn(); i++ </span><span class="cov0" title="0">{
                paramType := constructorValue.Type().In(i)
                // TODO: 파라미터 의존성 해결 로직 구현
                params[i] = reflect.New(paramType).Elem()
        }</span>

        // 인스턴스 생성
        <span class="cov0" title="0">results := constructorValue.Call(params)
        if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("constructor for %s must return at least one value", name)
        }</span>

        <span class="cov0" title="0">instance := results[0].Interface()
        c.instances[name] = instance

        return instance, nil</span>
}
</pre>

                <pre class="file" id="file3" style="display: none">package asset

import (
        "github.com/google/uuid"
)

// generateID는 UUID v4를 사용하여 고유한 ID를 생성합니다.
// UUID v4는 랜덤하게 생성되며, 충돌 가능성이 극히 낮습니다.
// 또한 내부적으로 동시성을 지원하므로 별도의 동기화가 필요하지 않습니다.
func generateID() string <span class="cov8" title="1">{
        return uuid.New().String()
}</span>
</pre>

                <pre class="file" id="file4" style="display: none">package asset

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/aske/go_fi_chart/internal/domain"
)

// MemoryRepository 인메모리 저장소 구현체
type MemoryRepository[T domain.Entity] struct {
        data  map[string]T
        mutex sync.RWMutex
}

// NewMemoryRepository 새로운 인메모리 저장소를 생성합니다.
func NewMemoryRepository[T domain.Entity]() *MemoryRepository[T] <span class="cov8" title="1">{
        return &amp;MemoryRepository[T]{
                data: make(map[string]T),
        }
}</span>

// Save 엔티티를 저장합니다.
func (r *MemoryRepository[T]) Save(_ context.Context, entity T) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.data[entity.GetID()]; exists </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("Save", fmt.Errorf("entity with ID %s already exists", entity.GetID()))
        }</span>

        <span class="cov8" title="1">r.data[entity.GetID()] = entity
        return nil</span>
}

// FindByID ID로 엔티티를 조회합니다.
func (r *MemoryRepository[T]) FindByID(_ context.Context, id string) (T, error) <span class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        if entity, exists := r.data[id]; exists </span><span class="cov8" title="1">{
                return entity, nil
        }</span>

        <span class="cov8" title="1">var zero T
        return zero, domain.NewRepositoryError("FindByID", fmt.Errorf("entity with ID %s not found", id))</span>
}

// Update 엔티티를 업데이트합니다.
func (r *MemoryRepository[T]) Update(_ context.Context, entity T) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.data[entity.GetID()]; !exists </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("Update", fmt.Errorf("entity with ID %s not found", entity.GetID()))
        }</span>

        <span class="cov8" title="1">r.data[entity.GetID()] = entity
        return nil</span>
}

// Delete ID로 엔티티를 삭제합니다.
func (r *MemoryRepository[T]) Delete(_ context.Context, id string) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.data[id]; !exists </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("Delete", fmt.Errorf("entity with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">delete(r.data, id)
        return nil</span>
}

// FindAll 검색 조건에 맞는 모든 엔티티를 조회합니다.
func (r *MemoryRepository[T]) FindAll(_ context.Context, _ domain.SearchCriteria) ([]T, error) <span class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var result []T
        for _, entity := range r.data </span><span class="cov0" title="0">{
                result = append(result, entity)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// FindOne 검색 조건에 맞는 하나의 엔티티를 조회합니다.
func (r *MemoryRepository[T]) FindOne(_ context.Context, _ domain.SearchCriteria) (T, error) <span class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var zero T
        return zero, domain.NewRepositoryError("FindOne", fmt.Errorf("not implemented"))
}</span>

// WithTransaction 트랜잭션을 실행합니다.
func (r *MemoryRepository[T]) WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error <span class="cov0" title="0">{
        return fn(ctx)
}</span>

// MemoryAssetRepository Asset 도메인의 인메모리 저장소
type MemoryAssetRepository struct {
        *MemoryRepository[*Asset]
}

// NewMemoryAssetRepository 새로운 Asset 인메모리 저장소를 생성합니다.
func NewMemoryAssetRepository() *MemoryAssetRepository <span class="cov8" title="1">{
        return &amp;MemoryAssetRepository{
                MemoryRepository: NewMemoryRepository[*Asset](),
        }
}</span>

// FindByUserID 사용자 ID로 Asset 목록을 조회합니다.
func (r *MemoryAssetRepository) FindByUserID(_ context.Context, userID string) ([]*Asset, error) <span class="cov8"
                                                                                                       title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var result []*Asset
        for _, asset := range r.data </span><span class="cov8" title="1">{
                if asset.UserID == userID </span><span class="cov8" title="1">{
                        result = append(result, asset)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// FindByType Asset 유형으로 Asset 목록을 조회합니다.
func (r *MemoryAssetRepository) FindByType(_ context.Context, assetType Type) ([]*Asset, error) <span class="cov8"
                                                                                                      title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var result []*Asset
        for _, asset := range r.data </span><span class="cov8" title="1">{
                if asset.Type == assetType </span><span class="cov8" title="1">{
                        result = append(result, asset)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// UpdateAmount Asset의 금액을 업데이트합니다.
func (r *MemoryAssetRepository) UpdateAmount(_ context.Context, id string, amount float64) error <span class="cov8"
                                                                                                       title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        asset, exists := r.data[id]
        if !exists </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("UpdateAmount", fmt.Errorf("asset with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">asset.Amount = amount
        asset.UpdatedAt = time.Now()
        r.data[id] = asset
        return nil</span>
}

// MemoryTransactionRepository Transaction 도메인의 인메모리 저장소
type MemoryTransactionRepository struct {
        *MemoryRepository[*Transaction]
}

// NewMemoryTransactionRepository 새로운 Transaction 인메모리 저장소를 생성합니다.
func NewMemoryTransactionRepository() *MemoryTransactionRepository <span class="cov8" title="1">{
        return &amp;MemoryTransactionRepository{
                MemoryRepository: NewMemoryRepository[*Transaction](),
        }
}</span>

// FindByAssetID 자산 ID로 Transaction 목록을 조회합니다.
func (r *MemoryTransactionRepository) FindByAssetID(_ context.Context, assetID string) ([]*Transaction, error) <span
                                class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var result []*Transaction
        for _, tx := range r.data </span><span class="cov0" title="0">{
                if tx.AssetID == assetID </span><span class="cov0" title="0">{
                        result = append(result, tx)
                }</span>
        }
        <span class="cov0" title="0">return result, nil</span>
}

// FindByDateRange 날짜 범위로 Transaction 목록을 조회합니다.
func (r *MemoryTransactionRepository) FindByDateRange(_ context.Context, start, end time.Time) ([]*Transaction, error) <span
                                class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var result []*Transaction
        for _, tx := range r.data </span><span class="cov8" title="1">{
                if (tx.Date.Equal(start) || tx.Date.After(start)) &amp;&amp; (tx.Date.Equal(end) || tx.Date.Before(end)) </span><span
                                class="cov8" title="1">{
                        result = append(result, tx)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// GetTotalAmount 자산 ID에 대한 총 거래 금액을 계산합니다.
func (r *MemoryTransactionRepository) GetTotalAmount(_ context.Context, assetID string) (float64, error) <span
                                class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var total float64
        for _, tx := range r.data </span><span class="cov8" title="1">{
                if tx.AssetID == assetID </span><span class="cov8" title="1">{
                        switch tx.Type </span>{
                        case Income:<span class="cov8" title="1">
                                total += tx.Amount</span>
                        case Expense:<span class="cov8" title="1">
                                total -= tx.Amount</span>
                        case Transfer:<span class="cov0" title="0"></span>
                                // Transfer는 별도 처리 필요
                        }
                }
        }
        <span class="cov8" title="1">return total, nil</span>
}

// MemoryPortfolioRepository Portfolio 도메인의 인메모리 저장소
type MemoryPortfolioRepository struct {
        *MemoryRepository[*Portfolio]
}

// NewMemoryPortfolioRepository 새로운 Portfolio 인메모리 저장소를 생성합니다.
func NewMemoryPortfolioRepository() *MemoryPortfolioRepository <span class="cov8" title="1">{
        return &amp;MemoryPortfolioRepository{
                MemoryRepository: NewMemoryRepository[*Portfolio](),
        }
}</span>

// FindByUserID 사용자 ID로 Portfolio를 조회합니다.
func (r *MemoryPortfolioRepository) FindByUserID(_ context.Context, userID string) (*Portfolio, error) <span
                                class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        for _, portfolio := range r.data </span><span class="cov8" title="1">{
                if portfolio.UserID == userID </span><span class="cov8" title="1">{
                        return portfolio, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, domain.NewRepositoryError("FindByUserID", fmt.Errorf("portfolio for user %s not found", userID))</span>
}

// UpdateAssets Portfolio의 자산 구성을 업데이트합니다.
func (r *MemoryPortfolioRepository) UpdateAssets(_ context.Context, id string, assets []PortfolioAsset) error <span
                                class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        portfolio, exists := r.data[id]
        if !exists </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("UpdateAssets", fmt.Errorf("portfolio with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">portfolio.Assets = assets
        portfolio.UpdatedAt = time.Now()
        r.data[id] = portfolio
        return nil</span>
}
</pre>

                <pre class="file" id="file5" style="display: none">package asset

import (
        "time"
)

type Asset struct {
        ID           string
        UserID       string
        Type         Type
        Name         string
        Amount       float64
        CreatedAt    time.Time
        UpdatedAt    time.Time
        Transactions []Transaction
}

func (a *Asset) GetID() string <span class="cov8" title="1">{
        return a.ID
}</span>

func (a *Asset) GetCreatedAt() time.Time <span class="cov8" title="1">{
        return a.CreatedAt
}</span>

func (a *Asset) GetUpdatedAt() time.Time <span class="cov8" title="1">{
        return a.UpdatedAt
}</span>

type Type string

const (
        Cash       Type = "CASH"
        Stock      Type = "STOCK"
        Bond       Type = "BOND"
        RealEstate Type = "REAL_ESTATE"
        Crypto     Type = "CRYPTO"
)

type Transaction struct {
        ID          string
        AssetID     string
        Type        TransactionType
        Amount      float64
        Category    string
        Description string
        Date        time.Time
        CreatedAt   time.Time
}

func (t *Transaction) GetID() string <span class="cov8" title="1">{
        return t.ID
}</span>

func (t *Transaction) GetCreatedAt() time.Time <span class="cov8" title="1">{
        return t.CreatedAt
}</span>

func (t *Transaction) GetUpdatedAt() time.Time <span class="cov8" title="1">{
        return t.Date
}</span>

type TransactionType string

const (
        Income   TransactionType = "INCOME"
        Expense  TransactionType = "EXPENSE"
        Transfer TransactionType = "TRANSFER"
)

type Portfolio struct {
        ID        string
        UserID    string
        Assets    []PortfolioAsset
        CreatedAt time.Time
        UpdatedAt time.Time
}

func (p *Portfolio) GetID() string <span class="cov8" title="1">{
        return p.ID
}</span>

func (p *Portfolio) GetCreatedAt() time.Time <span class="cov8" title="1">{
        return p.CreatedAt
}</span>

func (p *Portfolio) GetUpdatedAt() time.Time <span class="cov8" title="1">{
        return p.UpdatedAt
}</span>

// PortfolioAsset 포트폴리오 내 자산
type PortfolioAsset struct {
        AssetID string
        Weight  float64
}

func NewAsset(userID string, assetType Type, name string, amount float64) *Asset <span class="cov8" title="1">{
        now := time.Now()
        return &amp;Asset{
                ID:        generateID(),
                UserID:    userID,
                Type:      assetType,
                Name:      name,
                Amount:    amount,
                CreatedAt: now,
                UpdatedAt: now,
        }
}</span>

func NewTransaction(assetID string, transactionType TransactionType, amount float64, category string, description string) *Transaction <span
                                class="cov8" title="1">{
        now := time.Now()
        return &amp;Transaction{
                ID:          generateID(),
                AssetID:     assetID,
                Type:        transactionType,
                Amount:      amount,
                Category:    category,
                Description: description,
                Date:        now,
                CreatedAt:   now,
        }
}</span>

func NewPortfolio(userID string, assets []PortfolioAsset) *Portfolio <span class="cov8" title="1">{
        now := time.Now()
        return &amp;Portfolio{
                ID:        generateID(),
                UserID:    userID,
                Assets:    assets,
                CreatedAt: now,
                UpdatedAt: now,
        }
}</span>
</pre>

                <pre class="file" id="file6" style="display: none">package asset

import (
        "time"
)

// TestFixture 테스트에 사용할 데이터 세트
type TestFixture struct {
        Assets       []*Asset
        Transactions []*Transaction
        Portfolios   []*Portfolio
}

// NewTestFixture 새로운 테스트 픽스처를 생성합니다.
func NewTestFixture() *TestFixture <span class="cov8" title="1">{
        now := time.Now()
        userID := "test-user-1"

        // 자산 데이터 생성
        assets := []*Asset{
                {
                        ID:        "asset-1",
                        UserID:    userID,
                        Type:      Cash,
                        Name:      "현금 자산",
                        Amount:    1000000,
                        CreatedAt: now,
                        UpdatedAt: now,
                },
                {
                        ID:        "asset-2",
                        UserID:    userID,
                        Type:      Stock,
                        Name:      "주식 투자",
                        Amount:    5000000,
                        CreatedAt: now,
                        UpdatedAt: now,
                },
                {
                        ID:        "asset-3",
                        UserID:    userID,
                        Type:      Bond,
                        Name:      "채권 투자",
                        Amount:    3000000,
                        CreatedAt: now,
                        UpdatedAt: now,
                },
        }

        // 거래 내역 데이터 생성
        transactions := []*Transaction{
                {
                        ID:          "tx-1",
                        AssetID:     "asset-1",
                        Type:        Income,
                        Amount:      500000,
                        Category:    "급여",
                        Description: "3월 급여",
                        Date:        now,
                        CreatedAt:   now,
                },
                {
                        ID:          "tx-2",
                        AssetID:     "asset-1",
                        Type:        Expense,
                        Amount:      100000,
                        Category:    "식비",
                        Description: "3월 식비",
                        Date:        now,
                        CreatedAt:   now,
                },
                {
                        ID:          "tx-3",
                        AssetID:     "asset-2",
                        Type:        Transfer,
                        Amount:      1000000,
                        Category:    "투자",
                        Description: "주식 매수",
                        Date:        now,
                        CreatedAt:   now,
                },
        }

        // 포트폴리오 데이터 생성
        portfolios := []*Portfolio{
                {
                        ID:     "portfolio-1",
                        UserID: userID,
                        Assets: []PortfolioAsset{
                                {
                                        AssetID: "asset-1",
                                        Weight:  0.2, // 20%
                                },
                                {
                                        AssetID: "asset-2",
                                        Weight:  0.5, // 50%
                                },
                                {
                                        AssetID: "asset-3",
                                        Weight:  0.3, // 30%
                                },
                        },
                        CreatedAt: now,
                        UpdatedAt: now,
                },
        }

        return &amp;TestFixture{
                Assets:       assets,
                Transactions: transactions,
                Portfolios:   portfolios,
        }
}</span>

// GetAssetByID 테스트 픽스처에서 ID로 Asset을 찾습니다.
func (f *TestFixture) GetAssetByID(id string) *Asset <span class="cov8" title="1">{
        for _, asset := range f.Assets </span><span class="cov8" title="1">{
                if asset.ID == id </span><span class="cov8" title="1">{
                        return asset
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetTransactionByID 테스트 픽스처에서 ID로 Transaction을 찾습니다.
func (f *TestFixture) GetTransactionByID(id string) *Transaction <span class="cov8" title="1">{
        for _, tx := range f.Transactions </span><span class="cov8" title="1">{
                if tx.ID == id </span><span class="cov8" title="1">{
                        return tx
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetPortfolioByID 테스트 픽스처에서 ID로 Portfolio를 찾습니다.
func (f *TestFixture) GetPortfolioByID(id string) *Portfolio <span class="cov8" title="1">{
        for _, portfolio := range f.Portfolios </span><span class="cov8" title="1">{
                if portfolio.ID == id </span><span class="cov8" title="1">{
                        return portfolio
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetAssetsByUserID 테스트 픽스처에서 UserID로 Asset 목록을 찾습니다.
func (f *TestFixture) GetAssetsByUserID(userID string) []*Asset <span class="cov8" title="1">{
        var result []*Asset
        for _, asset := range f.Assets </span><span class="cov8" title="1">{
                if asset.UserID == userID </span><span class="cov8" title="1">{
                        result = append(result, asset)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetTransactionsByAssetID 테스트 픽스처에서 AssetID로 Transaction 목록을 찾습니다.
func (f *TestFixture) GetTransactionsByAssetID(assetID string) []*Transaction <span class="cov8" title="1">{
        var result []*Transaction
        for _, tx := range f.Transactions </span><span class="cov8" title="1">{
                if tx.AssetID == assetID </span><span class="cov8" title="1">{
                        result = append(result, tx)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetPortfolioByUserID 테스트 픽스처에서 UserID로 Portfolio를 찾습니다.
func (f *TestFixture) GetPortfolioByUserID(userID string) *Portfolio <span class="cov8" title="1">{
        for _, portfolio := range f.Portfolios </span><span class="cov8" title="1">{
                if portfolio.UserID == userID </span><span class="cov8" title="1">{
                        return portfolio
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>

                <pre class="file" id="file7" style="display: none">package domain

import "fmt"

// Error 도메인 에러 인터페이스입니다.
type Error interface {
        error
        // Code 에러 코드를 반환합니다.
        Code() string
        // Domain 에러가 발생한 도메인을 반환합니다.
        Domain() string
}

// BaseError 기본 도메인 에러 구현체입니다.
type BaseError struct {
        domain string
        code   string
        msg    string
}

// NewError 새로운 도메인 에러를 생성합니다.
func NewError(domain string, code string, msg string) Error <span class="cov0" title="0">{
        return &amp;BaseError{
                domain: domain,
                code:   code,
                msg:    msg,
        }
}</span>

func (e *BaseError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("[%s] %s: %s", e.domain, e.code, e.msg)
}</span>

func (e *BaseError) Code() string <span class="cov0" title="0">{
        return e.code
}</span>

func (e *BaseError) Domain() string <span class="cov0" title="0">{
        return e.domain
}</span>

// 자주 사용되는 에러 코드 상수
const (
        ErrCodeNotFound         = "NOT_FOUND"
        ErrCodeAlreadyExists    = "ALREADY_EXISTS"
        ErrCodeInvalidArgument  = "INVALID_ARGUMENT"
        ErrCodeInvalidOperation = "INVALID_OPERATION"
        ErrCodeNotImplemented   = "NOT_IMPLEMENTED"
        ErrCodeInternal         = "INTERNAL"
)
</pre>

                <pre class="file" id="file8" style="display: none">package domain

import (
        "context"
        "time"
)

// Event 시스템에서 발생하는 이벤트를 나타냅니다.
type Event interface {
        // EventType 이벤트의 타입을 반환합니다.
        EventType() string
        // Timestamp 이벤트가 발생한 시간을 반환합니다.
        Timestamp() time.Time
        // Payload 이벤트의 페이로드를 반환합니다.
        Payload() interface{}
        // Source 이벤트의 발생 소스를 반환합니다.
        Source() string
        // Metadata 이벤트의 메타데이터를 반환합니다.
        Metadata() map[string]string
}

// Handler 이벤트를 처리하는 핸들러입니다.
type Handler interface {
        Handle(ctx context.Context, event Event) error
}

// Publisher 이벤트를 발행하는 발행자입니다.
type Publisher interface {
        Publish(ctx context.Context, event Event) error
        Subscribe(handler Handler) error
        Unsubscribe(handler Handler) error
}

// BaseEvent 기본 이벤트 구현체입니다.
type BaseEvent struct {
        Type string
        Time time.Time
        Data interface{}
        Src  string
        Meta map[string]string
}

func (e *BaseEvent) EventType() string <span class="cov0" title="0">{
        return e.Type
}</span>

func (e *BaseEvent) Timestamp() time.Time <span class="cov0" title="0">{
        return e.Time
}</span>

func (e *BaseEvent) Payload() interface{} <span class="cov0" title="0">{
        return e.Data
}</span>

func (e *BaseEvent) Source() string <span class="cov0" title="0">{
        return e.Src
}</span>

func (e *BaseEvent) Metadata() map[string]string <span class="cov0" title="0">{
        return e.Meta
}</span>

// MetricType 메트릭의 타입을 나타냅니다.
type MetricType string

const (
        MetricTypeCounter   MetricType = "counter"
        MetricTypeGauge     MetricType = "gauge"
        MetricTypeHistogram MetricType = "histogram"
        MetricTypeSummary   MetricType = "summary"
)

// Metric 모니터링 시스템의 메트릭을 나타냅니다.
type Metric struct {
        Name        string            `json:"name"`
        Type        MetricType        `json:"type"`
        Value       float64           `json:"value"`
        Labels      map[string]string `json:"labels,omitempty"`
        Timestamp   time.Time         `json:"timestamp"`
        Description string            `json:"description"`
}

// MetricPayload 메트릭 수집 이벤트의 페이로드입니다.
type MetricPayload struct {
        Metrics []Metric `json:"metrics"`
}

// MonitoringEvent 모니터링 시스템의 이벤트입니다.
type MonitoringEvent struct {
        BaseEvent
}

// NewMonitoringEvent 새로운 모니터링 이벤트를 생성합니다.
func NewMonitoringEvent(eventType string, source string, payload interface{}, metadata map[string]string) Event <span
                                class="cov0" title="0">{
        return &amp;MonitoringEvent{
                BaseEvent: BaseEvent{
                        Type: eventType,
                        Time: time.Now(),
                        Data: payload,
                        Src:  source,
                        Meta: metadata,
                },
        }
}</span>

// 이벤트 타입 상수
const (
        TypeMetricCollected = "metric.collected"
        TypeAlertTriggered  = "alert.triggered"
)
</pre>

                <pre class="file" id="file9" style="display: none">package domain

import (
        "context"
        "time"
)

// Entity 모든 엔티티가 구현해야 하는 기본 인터페이스
type Entity interface {
        GetID() string
        GetCreatedAt() time.Time
        GetUpdatedAt() time.Time
}

// SearchCriteria 검색 조건 인터페이스
type SearchCriteria interface {
        ToQuery() (string, []interface{})
}

// Repository 기본 레포지토리 인터페이스
type Repository[T Entity, ID comparable] interface {
        // 기본 CRUD 작업
        Save(ctx context.Context, entity T) error
        FindByID(ctx context.Context, id ID) (T, error)
        Update(ctx context.Context, entity T) error
        Delete(ctx context.Context, id ID) error

        // 검색 작업
        FindAll(ctx context.Context, criteria SearchCriteria) ([]T, error)
        FindOne(ctx context.Context, criteria SearchCriteria) (T, error)

        // 트랜잭션 관리
        WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error
}

// RepositoryError 레포지토리 관련 에러 타입
type RepositoryError struct {
        Op  string // 작업 종류 (예: Save, FindByID 등)
        Err error  // 원본 에러
}

func (e *RepositoryError) Error() string <span class="cov0" title="0">{
        if e.Err == nil </span><span class="cov0" title="0">{
                return e.Op
        }</span>
        <span class="cov0" title="0">return e.Op + ": " + e.Err.Error()</span>
}

// NewRepositoryError 새로운 레포지토리 에러 생성
func NewRepositoryError(op string, err error) error <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Op:  op,
                Err: err,
        }
}</span>
</pre>

                <pre class="file" id="file10" style="display: none">package events

import (
        "context"
        "sync"
        "time"

        "github.com/aske/go_fi_chart/internal/domain"
)

// BaseEvent 기본 이벤트 구현체입니다.
type BaseEvent struct {
        Type string
        Time time.Time
        Data interface{}
        Src  string
        Meta map[string]string
}

func (e *BaseEvent) EventType() string <span class="cov0" title="0">{
        return e.Type
}</span>

func (e *BaseEvent) Timestamp() time.Time <span class="cov0" title="0">{
        return e.Time
}</span>

func (e *BaseEvent) Payload() interface{} <span class="cov0" title="0">{
        return e.Data
}</span>

func (e *BaseEvent) Source() string <span class="cov0" title="0">{
        return e.Src
}</span>

func (e *BaseEvent) Metadata() map[string]string <span class="cov0" title="0">{
        return e.Meta
}</span>

// MonitoringEvent 모니터링 시스템의 이벤트입니다.
type MonitoringEvent struct {
        BaseEvent
}

// NewMonitoringEvent 새로운 모니터링 이벤트를 생성합니다.
func NewMonitoringEvent(eventType string, source string, payload interface{}, metadata map[string]string) domain.Event <span
                                class="cov0" title="0">{
        return &amp;MonitoringEvent{
                BaseEvent: BaseEvent{
                        Type: eventType,
                        Time: time.Now(),
                        Data: payload,
                        Src:  source,
                        Meta: metadata,
                },
        }
}</span>

// SimplePublisher 기본적인 이벤트 발행자 구현체입니다.
type SimplePublisher struct {
        mu       sync.RWMutex
        handlers []domain.Handler
}

// NewSimplePublisher 새로운 SimplePublisher를 생성합니다.
func NewSimplePublisher() *SimplePublisher <span class="cov0" title="0">{
        return &amp;SimplePublisher{
                handlers: make([]domain.Handler, 0),
        }
}</span>

// Publish 이벤트를 발행합니다.
func (p *SimplePublisher) Publish(ctx context.Context, event domain.Event) error <span class="cov0" title="0">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        for _, handler := range p.handlers </span><span class="cov0" title="0">{
                if err := handler.Handle(ctx, event); err != nil </span><span class="cov0" title="0">{
                        // 에러가 발생해도 다른 핸들러는 계속 실행
                        continue</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Subscribe 이벤트 핸들러를 등록합니다.
func (p *SimplePublisher) Subscribe(handler domain.Handler) error <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        p.handlers = append(p.handlers, handler)
        return nil
}</span>

// Unsubscribe 이벤트 핸들러를 제거합니다.
func (p *SimplePublisher) Unsubscribe(handler domain.Handler) error <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        for i, h := range p.handlers </span><span class="cov0" title="0">{
                if h == handler </span><span class="cov0" title="0">{
                        p.handlers = append(p.handlers[:i], p.handlers[i+1:]...)
                        break</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>

                <pre class="file" id="file11" style="display: none">package github

import (
        "context"
        "sync"

        "github.com/aske/go_fi_chart/internal/domain"
)

// ActionCollector GitHub 액션 메트릭을 수집하는 컬렉터입니다.
type ActionCollector struct {
        mu        sync.RWMutex
        metrics   []domain.Metric
        publisher domain.Publisher
}

// NewActionCollector 새로운 ActionCollector를 생성합니다.
func NewActionCollector(publisher domain.Publisher) *ActionCollector <span class="cov0" title="0">{
        return &amp;ActionCollector{
                metrics:   make([]domain.Metric, 0),
                publisher: publisher,
        }
}</span>

// AddMetric 메트릭을 추가합니다.
func (c *ActionCollector) AddMetric(metric domain.Metric) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.metrics = append(c.metrics, metric)
        return nil
}</span>

// Collect 수집된 메트릭을 반환하고 이벤트를 발행합니다.
func (c *ActionCollector) Collect(ctx context.Context) ([]domain.Metric, error) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        metrics := make([]domain.Metric, len(c.metrics))
        copy(metrics, c.metrics)

        event := domain.NewMonitoringEvent(domain.TypeMetricCollected, "github-collector", metrics, nil)
        if err := c.publisher.Publish(ctx, event); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c.metrics = make([]domain.Metric, 0)
        return metrics, nil</span>
}
</pre>

                <pre class="file" id="file12" style="display: none">package alerts

import (
        "context"
        "sync"
        "time"

        "github.com/aske/go_fi_chart/internal/domain"
)

// AlertLevel 알림의 심각도를 나타냅니다.
type AlertLevel string

const (
        LevelInfo     AlertLevel = "INFO"
        LevelWarning  AlertLevel = "WARNING"
        LevelError    AlertLevel = "ERROR"
        LevelCritical AlertLevel = "CRITICAL"
)

// Alert 모니터링 시스템의 알림을 나타냅니다.
type Alert struct {
        ID        string            `json:"id"`
        Level     AlertLevel        `json:"level"`
        Source    string            `json:"source"`
        Message   string            `json:"message"`
        Timestamp time.Time         `json:"timestamp"`
        Metadata  map[string]string `json:"metadata,omitempty"`
}

// Notifier 알림을 처리하는 인터페이스입니다.
type Notifier interface {
        Notify(ctx context.Context, alert Alert) error
}

// SimpleNotifier 기본적인 알림 처리자 구현체입니다.
type SimpleNotifier struct {
        mu        sync.RWMutex
        publisher domain.Publisher
        handlers  []Notifier
}

// NewSimpleNotifier 새로운 SimpleNotifier를 생성합니다.
func NewSimpleNotifier(publisher domain.Publisher) *SimpleNotifier <span class="cov8" title="1">{
        return &amp;SimpleNotifier{
                publisher: publisher,
                handlers:  make([]Notifier, 0),
        }
}</span>

// AddHandler 알림 핸들러를 추가합니다.
func (n *SimpleNotifier) AddHandler(handler Notifier) <span class="cov8" title="1">{
        n.mu.Lock()
        defer n.mu.Unlock()
        n.handlers = append(n.handlers, handler)
}</span>

// RemoveHandler 알림 핸들러를 제거합니다.
func (n *SimpleNotifier) RemoveHandler(handler Notifier) <span class="cov8" title="1">{
        n.mu.Lock()
        defer n.mu.Unlock()
        for i, h := range n.handlers </span><span class="cov8" title="1">{
                if h == handler </span><span class="cov8" title="1">{
                        n.handlers = append(n.handlers[:i], n.handlers[i+1:]...)
                        break</span>
                }
        }
}

// Notify 알림을 처리하고 이벤트를 발행합니다.
func (n *SimpleNotifier) Notify(ctx context.Context, alert Alert) error <span class="cov8" title="1">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        // 모든 핸들러에게 알림 전달
        for _, handler := range n.handlers </span><span class="cov8" title="1">{
                if err := handler.Notify(ctx, alert); err != nil </span><span class="cov0" title="0">{
                        // 에러가 발생해도 다른 핸들러는 계속 실행
                        continue</span>
                }
        }

        // 알림 이벤트 발행
        <span class="cov8" title="1">event := domain.NewMonitoringEvent(
                domain.TypeAlertTriggered,
                alert.Source,
                alert,
                alert.Metadata,
        )

        if err := n.publisher.Publish(ctx, event); err != nil </span><span class="cov0" title="0">{
                return domain.NewError("alerts", domain.ErrCodeInternal, "알림 이벤트 발행 실패")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>

                <pre class="file" id="file13" style="display: none">package prometheus

import (
        "context"
        "fmt"
        "sync"

        "github.com/aske/go_fi_chart/services/monitoring/internal/metrics"
        "github.com/prometheus/client_golang/prometheus"
)

// Exporter Prometheus 익스포터 구현체입니다.
type Exporter struct {
        mu       sync.RWMutex
        registry *prometheus.Registry
        metrics  map[string]prometheus.Collector
}

// NewExporter 새로운 Exporter를 생성합니다.
func NewExporter() *Exporter <span class="cov8" title="1">{
        return &amp;Exporter{
                registry: prometheus.NewRegistry(),
                metrics:  make(map[string]prometheus.Collector),
        }
}</span>

// Export 메트릭을 Prometheus 형식으로 변환하여 등록합니다.
func (e *Exporter) Export(_ context.Context, metrics []metrics.Metric) error <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()

        for _, m := range metrics </span><span class="cov8" title="1">{
                collector, err := e.getOrCreateCollector(m)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("메트릭 컬렉터 생성 실패: %w", err)
                }</span>

                <span class="cov8" title="1">switch m.Type </span>{
                case "counter":<span class="cov8" title="1">
                        if counter, ok := collector.(prometheus.Counter); ok </span><span class="cov8" title="1">{
                                counter.Add(m.Value)
                        }</span>
                case "gauge":<span class="cov8" title="1">
                        if gauge, ok := collector.(prometheus.Gauge); ok </span><span class="cov8" title="1">{
                                gauge.Set(m.Value)
                        }</span>
                case "histogram":<span class="cov8" title="1">
                        if histogram, ok := collector.(prometheus.Histogram); ok </span><span class="cov8" title="1">{
                                histogram.Observe(m.Value)
                        }</span>
                case "summary":<span class="cov8" title="1">
                        if summary, ok := collector.(prometheus.Summary); ok </span><span class="cov8" title="1">{
                                summary.Observe(m.Value)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// GetRegistry Prometheus 레지스트리를 반환합니다.
func (e *Exporter) GetRegistry() *prometheus.Registry <span class="cov0" title="0">{
        return e.registry
}</span>

// getOrCreateCollector 메트릭에 대한 Prometheus 컬렉터를 반환하거나 생성합니다.
func (e *Exporter) getOrCreateCollector(m metrics.Metric) (prometheus.Collector, error) <span class="cov8" title="1">{
        if collector, exists := e.metrics[m.Name]; exists </span><span class="cov8" title="1">{
                return collector, nil
        }</span>

        <span class="cov8" title="1">var collector prometheus.Collector

        switch m.Type </span>{
        case "counter":<span class="cov8" title="1">
                collector = prometheus.NewCounter(prometheus.CounterOpts{
                        Name: m.Name,
                        Help: m.Description,
                })</span>
        case "gauge":<span class="cov8" title="1">
                collector = prometheus.NewGauge(prometheus.GaugeOpts{
                        Name: m.Name,
                        Help: m.Description,
                })</span>
        case "histogram":<span class="cov8" title="1">
                collector = prometheus.NewHistogram(prometheus.HistogramOpts{
                        Name: m.Name,
                        Help: m.Description,
                })</span>
        case "summary":<span class="cov8" title="1">
                collector = prometheus.NewSummary(prometheus.SummaryOpts{
                        Name: m.Name,
                        Help: m.Description,
                })</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("지원하지 않는 메트릭 타입: %s", m.Type)</span>
        }

        <span class="cov8" title="1">if err := e.registry.Register(collector); err != nil </span><span class="cov0"
                                                                                                       title="0">{
                return nil, fmt.Errorf("메트릭 등록 실패: %w", err)
        }</span>

        <span class="cov8" title="1">e.metrics[m.Name] = collector
        return collector, nil</span>
}
</pre>

                <pre class="file" id="file14" style="display: none">package metrics

import (
        "context"
        "sync"
        "time"

        "github.com/aske/go_fi_chart/internal/domain"
)

// MetricType 메트릭의 타입을 나타냅니다.
type MetricType string

const (
        TypeCounter   MetricType = "counter"
        TypeGauge     MetricType = "gauge"
        TypeHistogram MetricType = "histogram"
        TypeSummary   MetricType = "summary"
)

// Metric 모니터링 시스템의 메트릭을 나타냅니다.
type Metric struct {
        Name        string            `json:"name"`
        Type        MetricType        `json:"type"`
        Value       float64           `json:"value"`
        Labels      map[string]string `json:"labels,omitempty"`
        Timestamp   time.Time         `json:"timestamp"`
        Description string            `json:"description"`
}

// Collector 메트릭을 수집하는 인터페이스입니다.
type Collector interface {
        // Collect 메트릭을 수집합니다.
        Collect(ctx context.Context) ([]domain.Metric, error)
}

// SimpleCollector 기본적인 메트릭 수집기 구현체입니다.
type SimpleCollector struct {
        mu        sync.RWMutex
        metrics   []domain.Metric
        publisher domain.Publisher
}

// NewSimpleCollector 새로운 SimpleCollector를 생성합니다.
func NewSimpleCollector(publisher domain.Publisher) *SimpleCollector <span class="cov8" title="1">{
        return &amp;SimpleCollector{
                metrics:   make([]domain.Metric, 0),
                publisher: publisher,
        }
}</span>

// Collect 수집된 메트릭을 반환합니다.
func (c *SimpleCollector) Collect(ctx context.Context) ([]domain.Metric, error) <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        metrics := make([]domain.Metric, len(c.metrics))
        copy(metrics, c.metrics)

        // 메트릭 수집 이벤트 발행
        event := domain.NewMonitoringEvent(
                domain.TypeMetricCollected,
                "collector",
                domain.MetricPayload{Metrics: metrics},
                nil,
        )

        if err := c.publisher.Publish(ctx, event); err != nil </span><span class="cov0" title="0">{
                return nil, domain.NewError("metrics", domain.ErrCodeInternal, "메트릭 수집 이벤트 발행 실패")
        }</span>

        <span class="cov8" title="1">return metrics, nil</span>
}

// AddMetric 메트릭을 추가합니다.
func (c *SimpleCollector) AddMetric(metric domain.Metric) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if metric.Timestamp.IsZero() </span><span class="cov8" title="1">{
                metric.Timestamp = time.Now()
        }</span>
        <span class="cov8" title="1">c.metrics = append(c.metrics, metric)</span>
}

// Reset 수집된 메트릭을 초기화합니다.
func (c *SimpleCollector) Reset() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.metrics = make([]domain.Metric, 0)
}</span>
</pre>

                <pre class="file" id="file15" style="display: none">package github

import (
        "context"
        "sync"
        "time"

        "github.com/aske/go_fi_chart/internal/domain"
)

// ActionStatus GitHub 액션의 상태를 나타냅니다.
type ActionStatus string

const (
        ActionStatusSuccess    ActionStatus = "success"
        ActionStatusFailure    ActionStatus = "failure"
        ActionStatusInProgress ActionStatus = "in_progress"
)

// statusToValue ActionStatus를 숫자로 변환합니다.
func (s ActionStatus) toValue() float64 <span class="cov8" title="1">{
        switch s </span>{
        case ActionStatusSuccess:<span class="cov8" title="1">
                return 0</span>
        case ActionStatusFailure:<span class="cov8" title="1">
                return 1</span>
        case ActionStatusInProgress:<span class="cov8" title="1">
                return 2</span>
        default:<span class="cov0" title="0">
                return -1</span>
        }
}

// ActionMetric GitHub Actions 실행 메트릭을 나타냅니다.
type ActionMetric struct {
        WorkflowName string
        Status       ActionStatus
        Duration     time.Duration
        StartedAt    time.Time
        FinishedAt   time.Time
}

// ActionCollector GitHub 액션 메트릭을 수집하는 컬렉터입니다.
type ActionCollector struct {
        mu        sync.RWMutex
        metrics   []domain.Metric
        publisher domain.Publisher
}

// NewActionCollector 새로운 ActionCollector를 생성합니다.
func NewActionCollector(publisher domain.Publisher) *ActionCollector <span class="cov8" title="1">{
        return &amp;ActionCollector{
                metrics:   make([]domain.Metric, 0),
                publisher: publisher,
        }
}</span>

// AddMetric 메트릭을 추가합니다.
func (c *ActionCollector) AddMetric(metric domain.Metric) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.metrics = append(c.metrics, metric)
        return nil
}</span>

// Collect 수집된 메트릭을 반환하고 이벤트를 발행합니다.
func (c *ActionCollector) Collect(ctx context.Context) ([]domain.Metric, error) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        metrics := make([]domain.Metric, len(c.metrics))
        copy(metrics, c.metrics)

        event := domain.NewMonitoringEvent(domain.TypeMetricCollected, "github-collector", metrics, nil)
        if err := c.publisher.Publish(ctx, event); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">c.metrics = make([]domain.Metric, 0)
        return metrics, nil</span>
}

// AddActionMetric GitHub 액션 메트릭을 추가합니다.
func (c *ActionCollector) AddActionMetric(name string, status ActionStatus) error <span class="cov8" title="1">{
        return c.AddMetric(domain.Metric{
                Name:        "github_action_status",
                Type:        domain.MetricTypeGauge,
                Value:       status.toValue(),
                Labels:      map[string]string{"action": name},
                Description: "GitHub 액션의 상태를 나타냅니다. 0: 성공, 1: 실패, 2: 진행 중",
        })
}</span>

// AddDurationMetric GitHub 액션 실행 시간 메트릭을 추가합니다.
func (c *ActionCollector) AddDurationMetric(name string, duration time.Duration) error <span class="cov8" title="1">{
        return c.AddMetric(domain.Metric{
                Name:        "github_action_duration_seconds",
                Type:        domain.MetricTypeGauge,
                Value:       duration.Seconds(),
                Labels:      map[string]string{"action": name},
                Description: "GitHub 액션의 실행 시간(초)입니다.",
        })
}</span>
</pre>

                <pre class="file" id="file16" style="display: none">package health

import (
        "context"
        "sync"
        "time"
)

// Status 서비스의 상태를 나타냅니다.
type Status string

const (
        StatusUp   Status = "UP"
        StatusDown Status = "DOWN"
)

// Check 헬스 체크 결과를 나타냅니다.
type Check struct {
        Status    Status    `json:"status"`
        Timestamp time.Time `json:"timestamp"`
        Error     string    `json:"error,omitempty"`
}

// Checker 서비스 상태를 체크하는 인터페이스입니다.
type Checker interface {
        // Check 현재 서비스의 상태를 확인합니다.
        Check(ctx context.Context) Check
}

// SimpleChecker 기본적인 상태 체크 구현체입니다.
type SimpleChecker struct {
        mu     sync.RWMutex
        status Status
        err    error
}

// NewSimpleChecker 새로운 SimpleChecker를 생성합니다.
func NewSimpleChecker() *SimpleChecker <span class="cov8" title="1">{
        return &amp;SimpleChecker{
                status: StatusUp,
        }
}</span>

// Check 현재 서비스의 상태를 반환합니다.
func (c *SimpleChecker) Check(_ context.Context) Check <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        var errStr string
        if c.err != nil </span><span class="cov8" title="1">{
                errStr = c.err.Error()
        }</span>

        <span class="cov8" title="1">return Check{
                Status:    c.status,
                Timestamp: time.Now(),
                Error:     errStr,
        }</span>
}

// SetStatus 서비스의 상태를 설정합니다.
func (c *SimpleChecker) SetStatus(status Status, err error) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.status = status
        c.err = err
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
