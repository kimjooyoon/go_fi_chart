
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/aske/go_fi_chart/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">github.com/aske/go_fi_chart/internal/domain/asset/id_generator.go (100.0%)</option>
				
				<option value="file2">github.com/aske/go_fi_chart/internal/domain/asset/memory_repository.go (76.0%)</option>

                        <option value="file3">github.com/aske/go_fi_chart/internal/domain/asset/model.go (100.0%)
                        </option>
				
				<option value="file4">github.com/aske/go_fi_chart/internal/domain/asset/test_fixture.go (100.0%)</option>
				
				<option value="file5">github.com/aske/go_fi_chart/internal/domain/repository.go (0.0%)</option>

                        <option value="file6">
                                github.com/aske/go_fi_chart/services/monitoring/internal/metrics/collector.go (100.0%)
                        </option>

                        <option value="file7">
                                github.com/aske/go_fi_chart/services/monitoring/internal/metrics/github/collector.go
                                (100.0%)
                        </option>

                        <option value="file8">github.com/aske/go_fi_chart/services/monitoring/pkg/health/checker.go
                                (100.0%)
                        </option>

                </select>
			</div>
			<div id="legend">
				<span>not tracked</span>

                    <span class="cov0">not covered</span>
                    <span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"
        "net/http"
        "time"
)

func main() <span class="cov0" title="0">{
        log.Println("FIN-RPG 서버 시작 중...")

        // TODO: 의존성 주입 설정
        // TODO: 라우터 설정
        // TODO: 미들웨어 설정
        // TODO: 데이터베이스 연결

        srv := &amp;http.Server{
                Addr:              ":8080",
                ReadTimeout:       5 * time.Second,
                WriteTimeout:      10 * time.Second,
                IdleTimeout:       120 * time.Second,
                ReadHeaderTimeout: 2 * time.Second,
        }

        log.Println("서버가 시작되었습니다. :8080 포트에서 대기 중...")
        if err := srv.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("서버 시작 실패: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package asset

import (
        "github.com/google/uuid"
)

// generateID는 UUID v4를 사용하여 고유한 ID를 생성합니다.
// UUID v4는 랜덤하게 생성되며, 충돌 가능성이 극히 낮습니다.
// 또한 내부적으로 동시성을 지원하므로 별도의 동기화가 필요하지 않습니다.
func generateID() string <span class="cov8" title="1">{
        return uuid.New().String()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package asset

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/aske/go_fi_chart/internal/domain"
)

// MemoryRepository 인메모리 저장소 구현체
type MemoryRepository[T domain.Entity] struct {
        data  map[string]T
        mutex sync.RWMutex
}

// NewMemoryRepository 새로운 인메모리 저장소를 생성합니다.
func NewMemoryRepository[T domain.Entity]() *MemoryRepository[T] <span class="cov8" title="1">{
        return &amp;MemoryRepository[T]{
                data: make(map[string]T),
        }
}</span>

// Save 엔티티를 저장합니다.
func (r *MemoryRepository[T]) Save(_ context.Context, entity T) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.data[entity.GetID()]; exists </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("Save", fmt.Errorf("entity with ID %s already exists", entity.GetID()))
        }</span>

        <span class="cov8" title="1">r.data[entity.GetID()] = entity
        return nil</span>
}

// FindByID ID로 엔티티를 조회합니다.
func (r *MemoryRepository[T]) FindByID(_ context.Context, id string) (T, error) <span class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        if entity, exists := r.data[id]; exists </span><span class="cov8" title="1">{
                return entity, nil
        }</span>

        <span class="cov8" title="1">var zero T
        return zero, domain.NewRepositoryError("FindByID", fmt.Errorf("entity with ID %s not found", id))</span>
}

// Update 엔티티를 업데이트합니다.
func (r *MemoryRepository[T]) Update(_ context.Context, entity T) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.data[entity.GetID()]; !exists </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("Update", fmt.Errorf("entity with ID %s not found", entity.GetID()))
        }</span>

        <span class="cov8" title="1">r.data[entity.GetID()] = entity
        return nil</span>
}

// Delete ID로 엔티티를 삭제합니다.
func (r *MemoryRepository[T]) Delete(_ context.Context, id string) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.data[id]; !exists </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("Delete", fmt.Errorf("entity with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">delete(r.data, id)
        return nil</span>
}

// FindAll 검색 조건에 맞는 모든 엔티티를 조회합니다.
func (r *MemoryRepository[T]) FindAll(_ context.Context, _ domain.SearchCriteria) ([]T, error) <span class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var result []T
        for _, entity := range r.data </span><span class="cov0" title="0">{
                result = append(result, entity)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// FindOne 검색 조건에 맞는 하나의 엔티티를 조회합니다.
func (r *MemoryRepository[T]) FindOne(_ context.Context, _ domain.SearchCriteria) (T, error) <span class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var zero T
        return zero, domain.NewRepositoryError("FindOne", fmt.Errorf("not implemented"))
}</span>

// WithTransaction 트랜잭션을 실행합니다.
func (r *MemoryRepository[T]) WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error <span class="cov0" title="0">{
        return fn(ctx)
}</span>

// MemoryAssetRepository Asset 도메인의 인메모리 저장소
type MemoryAssetRepository struct {
        *MemoryRepository[*Asset]
}

// NewMemoryAssetRepository 새로운 Asset 인메모리 저장소를 생성합니다.
func NewMemoryAssetRepository() *MemoryAssetRepository <span class="cov8" title="1">{
        return &amp;MemoryAssetRepository{
                MemoryRepository: NewMemoryRepository[*Asset](),
        }
}</span>

// FindByUserID 사용자 ID로 Asset 목록을 조회합니다.
func (r *MemoryAssetRepository) FindByUserID(_ context.Context, userID string) ([]*Asset, error) <span class="cov8"
                                                                                                       title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var result []*Asset
        for _, asset := range r.data </span><span class="cov8" title="1">{
                if asset.UserID == userID </span><span class="cov8" title="1">{
                        result = append(result, asset)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// FindByType Asset 유형으로 Asset 목록을 조회합니다.
func (r *MemoryAssetRepository) FindByType(_ context.Context, assetType Type) ([]*Asset, error) <span class="cov8"
                                                                                                      title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var result []*Asset
        for _, asset := range r.data </span><span class="cov8" title="1">{
                if asset.Type == assetType </span><span class="cov8" title="1">{
                        result = append(result, asset)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// UpdateAmount Asset의 금액을 업데이트합니다.
func (r *MemoryAssetRepository) UpdateAmount(_ context.Context, id string, amount float64) error <span class="cov8"
                                                                                                       title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        asset, exists := r.data[id]
        if !exists </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("UpdateAmount", fmt.Errorf("asset with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">asset.Amount = amount
        asset.UpdatedAt = time.Now()
        r.data[id] = asset
        return nil</span>
}

// MemoryTransactionRepository Transaction 도메인의 인메모리 저장소
type MemoryTransactionRepository struct {
        *MemoryRepository[*Transaction]
}

// NewMemoryTransactionRepository 새로운 Transaction 인메모리 저장소를 생성합니다.
func NewMemoryTransactionRepository() *MemoryTransactionRepository <span class="cov8" title="1">{
        return &amp;MemoryTransactionRepository{
                MemoryRepository: NewMemoryRepository[*Transaction](),
        }
}</span>

// FindByAssetID 자산 ID로 Transaction 목록을 조회합니다.
func (r *MemoryTransactionRepository) FindByAssetID(_ context.Context, assetID string) ([]*Transaction, error) <span
                        class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var result []*Transaction
        for _, tx := range r.data </span><span class="cov0" title="0">{
                if tx.AssetID == assetID </span><span class="cov0" title="0">{
                        result = append(result, tx)
                }</span>
        }
        <span class="cov0" title="0">return result, nil</span>
}

// FindByDateRange 날짜 범위로 Transaction 목록을 조회합니다.
func (r *MemoryTransactionRepository) FindByDateRange(_ context.Context, start, end time.Time) ([]*Transaction, error) <span
                        class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var result []*Transaction
        for _, tx := range r.data </span><span class="cov8" title="1">{
                if (tx.Date.Equal(start) || tx.Date.After(start)) &amp;&amp; (tx.Date.Equal(end) || tx.Date.Before(end)) </span><span
                        class="cov8" title="1">{
                        result = append(result, tx)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// GetTotalAmount 자산 ID에 대한 총 거래 금액을 계산합니다.
func (r *MemoryTransactionRepository) GetTotalAmount(_ context.Context, assetID string) (float64, error) <span
                        class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var total float64
        for _, tx := range r.data </span><span class="cov8" title="1">{
                if tx.AssetID == assetID </span><span class="cov8" title="1">{
                        switch tx.Type </span>{
                        case Income:<span class="cov8" title="1">
                                total += tx.Amount</span>
                        case Expense:<span class="cov8" title="1">
                                total -= tx.Amount</span>
                        case Transfer:<span class="cov0" title="0"></span>
                                // Transfer는 별도 처리 필요
                        }
                }
        }
        <span class="cov8" title="1">return total, nil</span>
}

// MemoryPortfolioRepository Portfolio 도메인의 인메모리 저장소
type MemoryPortfolioRepository struct {
        *MemoryRepository[*Portfolio]
}

// NewMemoryPortfolioRepository 새로운 Portfolio 인메모리 저장소를 생성합니다.
func NewMemoryPortfolioRepository() *MemoryPortfolioRepository <span class="cov8" title="1">{
        return &amp;MemoryPortfolioRepository{
                MemoryRepository: NewMemoryRepository[*Portfolio](),
        }
}</span>

// FindByUserID 사용자 ID로 Portfolio를 조회합니다.
func (r *MemoryPortfolioRepository) FindByUserID(_ context.Context, userID string) (*Portfolio, error) <span
                        class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        for _, portfolio := range r.data </span><span class="cov8" title="1">{
                if portfolio.UserID == userID </span><span class="cov8" title="1">{
                        return portfolio, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, domain.NewRepositoryError("FindByUserID", fmt.Errorf("portfolio for user %s not found", userID))</span>
}

// UpdateAssets Portfolio의 자산 구성을 업데이트합니다.
func (r *MemoryPortfolioRepository) UpdateAssets(_ context.Context, id string, assets []PortfolioAsset) error <span
                        class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        portfolio, exists := r.data[id]
        if !exists </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("UpdateAssets", fmt.Errorf("portfolio with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">portfolio.Assets = assets
        portfolio.UpdatedAt = time.Now()
        r.data[id] = portfolio
        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package asset

import (
        "time"
)

type Asset struct {
        ID           string
        UserID       string
        Type         Type
        Name         string
        Amount       float64
        CreatedAt    time.Time
        UpdatedAt    time.Time
        Transactions []Transaction
}

func (a *Asset) GetID() string <span class="cov8" title="1">{
        return a.ID
}</span>

func (a *Asset) GetCreatedAt() time.Time <span class="cov8" title="1">{
        return a.CreatedAt
}</span>

func (a *Asset) GetUpdatedAt() time.Time <span class="cov8" title="1">{
        return a.UpdatedAt
}</span>

type Type string

const (
        Cash       Type = "CASH"
        Stock      Type = "STOCK"
        Bond       Type = "BOND"
        RealEstate Type = "REAL_ESTATE"
        Crypto     Type = "CRYPTO"
)

type Transaction struct {
        ID          string
        AssetID     string
        Type        TransactionType
        Amount      float64
        Category    string
        Description string
        Date        time.Time
        CreatedAt   time.Time
}

func (t *Transaction) GetID() string <span class="cov8" title="1">{
        return t.ID
}</span>

func (t *Transaction) GetCreatedAt() time.Time <span class="cov8" title="1">{
        return t.CreatedAt
}</span>

func (t *Transaction) GetUpdatedAt() time.Time <span class="cov8" title="1">{
        return t.Date
}</span>

type TransactionType string

const (
        Income   TransactionType = "INCOME"
        Expense  TransactionType = "EXPENSE"
        Transfer TransactionType = "TRANSFER"
)

type Portfolio struct {
        ID        string
        UserID    string
        Assets    []PortfolioAsset
        CreatedAt time.Time
        UpdatedAt time.Time
}

func (p *Portfolio) GetID() string <span class="cov8" title="1">{
        return p.ID
}</span>

func (p *Portfolio) GetCreatedAt() time.Time <span class="cov8" title="1">{
        return p.CreatedAt
}</span>

func (p *Portfolio) GetUpdatedAt() time.Time <span class="cov8" title="1">{
        return p.UpdatedAt
}</span>

// PortfolioAsset 포트폴리오 내 자산
type PortfolioAsset struct {
        AssetID string
        Weight  float64
}

func NewAsset(userID string, assetType Type, name string, amount float64) *Asset <span class="cov8" title="1">{
        now := time.Now()
        return &amp;Asset{
                ID:        generateID(),
                UserID:    userID,
                Type:      assetType,
                Name:      name,
                Amount:    amount,
                CreatedAt: now,
                UpdatedAt: now,
        }
}</span>

func NewTransaction(assetID string, transactionType TransactionType, amount float64, category string, description string) *Transaction <span
                        class="cov8" title="1">{
        now := time.Now()
        return &amp;Transaction{
                ID:          generateID(),
                AssetID:     assetID,
                Type:        transactionType,
                Amount:      amount,
                Category:    category,
                Description: description,
                Date:        now,
                CreatedAt:   now,
        }
}</span>

func NewPortfolio(userID string, assets []PortfolioAsset) *Portfolio <span class="cov8" title="1">{
        now := time.Now()
        return &amp;Portfolio{
                ID:        generateID(),
                UserID:    userID,
                Assets:    assets,
                CreatedAt: now,
                UpdatedAt: now,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package asset

import (
        "time"
)

// TestFixture 테스트에 사용할 데이터 세트
type TestFixture struct {
        Assets       []*Asset
        Transactions []*Transaction
        Portfolios   []*Portfolio
}

// NewTestFixture 새로운 테스트 픽스처를 생성합니다.
func NewTestFixture() *TestFixture <span class="cov8" title="1">{
        now := time.Now()
        userID := "test-user-1"

        // 자산 데이터 생성
        assets := []*Asset{
                {
                        ID:        "asset-1",
                        UserID:    userID,
                        Type:      Cash,
                        Name:      "현금 자산",
                        Amount:    1000000,
                        CreatedAt: now,
                        UpdatedAt: now,
                },
                {
                        ID:        "asset-2",
                        UserID:    userID,
                        Type:      Stock,
                        Name:      "주식 투자",
                        Amount:    5000000,
                        CreatedAt: now,
                        UpdatedAt: now,
                },
                {
                        ID:        "asset-3",
                        UserID:    userID,
                        Type:      Bond,
                        Name:      "채권 투자",
                        Amount:    3000000,
                        CreatedAt: now,
                        UpdatedAt: now,
                },
        }

        // 거래 내역 데이터 생성
        transactions := []*Transaction{
                {
                        ID:          "tx-1",
                        AssetID:     "asset-1",
                        Type:        Income,
                        Amount:      500000,
                        Category:    "급여",
                        Description: "3월 급여",
                        Date:        now,
                        CreatedAt:   now,
                },
                {
                        ID:          "tx-2",
                        AssetID:     "asset-1",
                        Type:        Expense,
                        Amount:      100000,
                        Category:    "식비",
                        Description: "3월 식비",
                        Date:        now,
                        CreatedAt:   now,
                },
                {
                        ID:          "tx-3",
                        AssetID:     "asset-2",
                        Type:        Transfer,
                        Amount:      1000000,
                        Category:    "투자",
                        Description: "주식 매수",
                        Date:        now,
                        CreatedAt:   now,
                },
        }

        // 포트폴리오 데이터 생성
        portfolios := []*Portfolio{
                {
                        ID:     "portfolio-1",
                        UserID: userID,
                        Assets: []PortfolioAsset{
                                {
                                        AssetID: "asset-1",
                                        Weight:  0.2, // 20%
                                },
                                {
                                        AssetID: "asset-2",
                                        Weight:  0.5, // 50%
                                },
                                {
                                        AssetID: "asset-3",
                                        Weight:  0.3, // 30%
                                },
                        },
                        CreatedAt: now,
                        UpdatedAt: now,
                },
        }

        return &amp;TestFixture{
                Assets:       assets,
                Transactions: transactions,
                Portfolios:   portfolios,
        }
}</span>

// GetAssetByID 테스트 픽스처에서 ID로 Asset을 찾습니다.
func (f *TestFixture) GetAssetByID(id string) *Asset <span class="cov8" title="1">{
        for _, asset := range f.Assets </span><span class="cov8" title="1">{
                if asset.ID == id </span><span class="cov8" title="1">{
                        return asset
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetTransactionByID 테스트 픽스처에서 ID로 Transaction을 찾습니다.
func (f *TestFixture) GetTransactionByID(id string) *Transaction <span class="cov8" title="1">{
        for _, tx := range f.Transactions </span><span class="cov8" title="1">{
                if tx.ID == id </span><span class="cov8" title="1">{
                        return tx
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetPortfolioByID 테스트 픽스처에서 ID로 Portfolio를 찾습니다.
func (f *TestFixture) GetPortfolioByID(id string) *Portfolio <span class="cov8" title="1">{
        for _, portfolio := range f.Portfolios </span><span class="cov8" title="1">{
                if portfolio.ID == id </span><span class="cov8" title="1">{
                        return portfolio
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetAssetsByUserID 테스트 픽스처에서 UserID로 Asset 목록을 찾습니다.
func (f *TestFixture) GetAssetsByUserID(userID string) []*Asset <span class="cov8" title="1">{
        var result []*Asset
        for _, asset := range f.Assets </span><span class="cov8" title="1">{
                if asset.UserID == userID </span><span class="cov8" title="1">{
                        result = append(result, asset)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetTransactionsByAssetID 테스트 픽스처에서 AssetID로 Transaction 목록을 찾습니다.
func (f *TestFixture) GetTransactionsByAssetID(assetID string) []*Transaction <span class="cov8" title="1">{
        var result []*Transaction
        for _, tx := range f.Transactions </span><span class="cov8" title="1">{
                if tx.AssetID == assetID </span><span class="cov8" title="1">{
                        result = append(result, tx)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetPortfolioByUserID 테스트 픽스처에서 UserID로 Portfolio를 찾습니다.
func (f *TestFixture) GetPortfolioByUserID(userID string) *Portfolio <span class="cov8" title="1">{
        for _, portfolio := range f.Portfolios </span><span class="cov8" title="1">{
                if portfolio.UserID == userID </span><span class="cov8" title="1">{
                        return portfolio
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package domain

import (
        "context"
        "time"
)

// Entity 모든 엔티티가 구현해야 하는 기본 인터페이스
type Entity interface {
        GetID() string
        GetCreatedAt() time.Time
        GetUpdatedAt() time.Time
}

// SearchCriteria 검색 조건 인터페이스
type SearchCriteria interface {
        ToQuery() (string, []interface{})
}

// Repository 기본 레포지토리 인터페이스
type Repository[T Entity, ID comparable] interface {
        // 기본 CRUD 작업
        Save(ctx context.Context, entity T) error
        FindByID(ctx context.Context, id ID) (T, error)
        Update(ctx context.Context, entity T) error
        Delete(ctx context.Context, id ID) error

        // 검색 작업
        FindAll(ctx context.Context, criteria SearchCriteria) ([]T, error)
        FindOne(ctx context.Context, criteria SearchCriteria) (T, error)

        // 트랜잭션 관리
        WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error
}

// RepositoryError 레포지토리 관련 에러 타입
type RepositoryError struct {
        Op  string // 작업 종류 (예: Save, FindByID 등)
        Err error  // 원본 에러
}

func (e *RepositoryError) Error() string <span class="cov0" title="0">{
        if e.Err == nil </span><span class="cov0" title="0">{
                return e.Op
        }</span>
        <span class="cov0" title="0">return e.Op + ": " + e.Err.Error()</span>
}

// NewRepositoryError 새로운 레포지토리 에러 생성
func NewRepositoryError(op string, err error) error <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Op:  op,
                Err: err,
        }
}</span>
</pre>

                <pre class="file" id="file6" style="display: none">package metrics

import (
        "context"
        "sync"
        "time"
)

// MetricType 메트릭의 종류를 나타냅니다.
type MetricType string

const (
        TypeGauge   MetricType = "GAUGE"
        TypeCounter MetricType = "COUNTER"
)

// Metric 수집된 메트릭을 나타냅니다.
type Metric struct {
        Name      string            `json:"name"`
        Type      MetricType        `json:"type"`
        Value     float64           `json:"value"`
        Labels    map[string]string `json:"labels"`
        Timestamp time.Time         `json:"timestamp"`
}

// Collector 메트릭을 수집하는 인터페이스입니다.
type Collector interface {
        // Collect 메트릭을 수집합니다.
        Collect(ctx context.Context) ([]Metric, error)
}

// SimpleCollector 기본적인 메트릭 수집 구현체입니다.
type SimpleCollector struct {
        mu      sync.RWMutex
        metrics []Metric
}

// NewSimpleCollector 새로운 SimpleCollector를 생성합니다.
func NewSimpleCollector() *SimpleCollector <span class="cov8" title="1">{
        return &amp;SimpleCollector{
                metrics: make([]Metric, 0),
        }
}</span>

// Collect 현재 저장된 메트릭을 반환합니다.
func (c *SimpleCollector) Collect(_ context.Context) ([]Metric, error) <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        result := make([]Metric, len(c.metrics))
        copy(result, c.metrics)
        return result, nil
}</span>

// AddMetric 새로운 메트릭을 추가합니다.
func (c *SimpleCollector) AddMetric(metric Metric) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        metric.Timestamp = time.Now()
        c.metrics = append(c.metrics, metric)
}</span>

// Reset 저장된 메트릭을 초기화합니다.
func (c *SimpleCollector) Reset() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.metrics = make([]Metric, 0)
}</span>
</pre>

                <pre class="file" id="file7" style="display: none">package github

import (
        "context"
        "time"

        "github.com/aske/go_fi_chart/services/monitoring/internal/metrics"
)

// ActionStatus GitHub Actions의 실행 상태를 나타냅니다.
type ActionStatus string

const (
        StatusSuccess ActionStatus = "success"
        StatusFailure ActionStatus = "failure"
        StatusRunning ActionStatus = "running"
)

// ActionMetric GitHub Actions 실행 메트릭을 나타냅니다.
type ActionMetric struct {
        WorkflowName string
        Status       ActionStatus
        Duration     time.Duration
        StartedAt    time.Time
        FinishedAt   time.Time
}

// ActionCollector GitHub Actions 메트릭을 수집하는 컬렉터입니다.
type ActionCollector struct {
        baseCollector *metrics.SimpleCollector
}

// NewActionCollector 새로운 GitHub Actions 메트릭 컬렉터를 생성합니다.
func NewActionCollector() *ActionCollector <span class="cov8" title="1">{
        return &amp;ActionCollector{
                baseCollector: metrics.NewSimpleCollector(),
        }
}</span>

// Collect GitHub Actions 메트릭을 수집합니다.
func (c *ActionCollector) Collect(ctx context.Context) ([]metrics.Metric, error) <span class="cov8" title="1">{
        return c.baseCollector.Collect(ctx)
}</span>

// AddActionMetric GitHub Actions 메트릭을 추가합니다.
func (c *ActionCollector) AddActionMetric(actionMetric ActionMetric) <span class="cov8" title="1">{
        c.baseCollector.AddMetric(metrics.Metric{
                Name:  "github_action_duration_seconds",
                Type:  metrics.TypeGauge,
                Value: actionMetric.Duration.Seconds(),
                Labels: map[string]string{
                        "workflow": actionMetric.WorkflowName,
                        "status":   string(actionMetric.Status),
                },
                Timestamp: actionMetric.FinishedAt,
        })

        c.baseCollector.AddMetric(metrics.Metric{
                Name: "github_action_status",
                Type: metrics.TypeGauge,
                Value: map[ActionStatus]float64{
                        StatusSuccess: 1.0,
                        StatusFailure: 0.0,
                        StatusRunning: 0.5,
                }[actionMetric.Status],
                Labels: map[string]string{
                        "workflow": actionMetric.WorkflowName,
                },
                Timestamp: actionMetric.FinishedAt,
        })
}</span>
</pre>

                <pre class="file" id="file8" style="display: none">package health

import (
        "context"
        "sync"
        "time"
)

// Status 서비스의 상태를 나타냅니다.
type Status string

const (
        StatusUp   Status = "UP"
        StatusDown Status = "DOWN"
)

// Check 헬스 체크 결과를 나타냅니다.
type Check struct {
        Status    Status    `json:"status"`
        Timestamp time.Time `json:"timestamp"`
        Error     string    `json:"error,omitempty"`
}

// Checker 서비스 상태를 체크하는 인터페이스입니다.
type Checker interface {
        // Check 현재 서비스의 상태를 확인합니다.
        Check(ctx context.Context) Check
}

// SimpleChecker 기본적인 상태 체크 구현체입니다.
type SimpleChecker struct {
        mu     sync.RWMutex
        status Status
        err    error
}

// NewSimpleChecker 새로운 SimpleChecker를 생성합니다.
func NewSimpleChecker() *SimpleChecker <span class="cov8" title="1">{
        return &amp;SimpleChecker{
                status: StatusUp,
        }
}</span>

// Check 현재 서비스의 상태를 반환합니다.
func (c *SimpleChecker) Check(_ context.Context) Check <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        var errStr string
        if c.err != nil </span><span class="cov8" title="1">{
                errStr = c.err.Error()
        }</span>

        <span class="cov8" title="1">return Check{
                Status:    c.status,
                Timestamp: time.Now(),
                Error:     errStr,
        }</span>
}

// SetStatus 서비스의 상태를 설정합니다.
func (c *SimpleChecker) SetStatus(status Status, err error) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.status = status
        c.err = err
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
