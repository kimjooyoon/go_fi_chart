
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/aske/go_fi_chart/cmd/server/main.go (0.0%)</option>

                        <option value="file1">github.com/aske/go_fi_chart/internal/api/handler.go (0.0%)</option>

                        <option value="file2">github.com/aske/go_fi_chart/internal/config/config.go (0.0%)</option>

                        <option value="file3">github.com/aske/go_fi_chart/internal/di/container.go (0.0%)</option>

                        <option value="file4">github.com/aske/go_fi_chart/internal/domain/asset/id_generator.go
                                (100.0%)
                        </option>

                        <option value="file5">github.com/aske/go_fi_chart/internal/domain/asset/memory_repository.go
                                (52.8%)
                        </option>

                        <option value="file6">github.com/aske/go_fi_chart/internal/domain/asset/model.go (59.3%)
                        </option>

                        <option value="file7">github.com/aske/go_fi_chart/internal/domain/asset/test_fixture.go
                                (72.7%)
                        </option>

                        <option value="file8">github.com/aske/go_fi_chart/internal/domain/error.go (0.0%)</option>

                        <option value="file9">github.com/aske/go_fi_chart/internal/domain/event/event.go (88.9%)
                        </option>

                        <option value="file10">
                                github.com/aske/go_fi_chart/internal/domain/gamification/memory_repository.go (78.9%)
                        </option>

                        <option value="file11">github.com/aske/go_fi_chart/internal/domain/gamification/model.go
                                (87.8%)
                        </option>

                        <option value="file12">github.com/aske/go_fi_chart/internal/domain/repository.go (0.0%)</option>

                        <option value="file13">github.com/aske/go_fi_chart/internal/domain/utils.go (0.0%)</option>

                        <option value="file14">
                                github.com/aske/go_fi_chart/internal/infrastructure/events/memory/event_bus.go (100.0%)
                        </option>

                        <option value="file15">
                                github.com/aske/go_fi_chart/internal/infrastructure/events/memory/event_store.go
                                (100.0%)
                        </option>

                </select>
			</div>
			<div id="legend">
				<span>not tracked</span>

                    <span class="cov0">not covered</span>
                    <span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/aske/go_fi_chart/internal/api"
        "github.com/aske/go_fi_chart/internal/config"
        "github.com/aske/go_fi_chart/internal/domain/asset"
        "github.com/aske/go_fi_chart/internal/domain/gamification"
        chi "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
)

func main() <span class="cov0" title="0">{
        log.Println("FIN-RPG 서버 시작 중...")

        // 설정 로드
        cfg := config.NewDefaultConfig()

        // 저장소 생성
        assetRepo := asset.NewMemoryAssetRepository()
        transactionRepo := asset.NewMemoryTransactionRepository()
        portfolioRepo := asset.NewMemoryPortfolioRepository()
        gamificationRepo := gamification.NewMemoryRepository()

        // API 핸들러 생성
        apiHandler := api.NewHandler(assetRepo, transactionRepo, portfolioRepo, gamificationRepo)

        // 라우터 설정
        r := chi.NewRouter()
        r.Use(middleware.Logger)
        r.Use(middleware.Recoverer)
        r.Use(middleware.RequestID)
        r.Use(middleware.RealIP)
        r.Use(middleware.Timeout(60 * time.Second))

        // 헬스 체크
        r.Get("/health", func(w http.ResponseWriter, _ *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                if _, err := w.Write([]byte("OK")); err != nil </span><span class="cov0" title="0">{
                        log.Printf("헬스 체크 응답 작성 실패: %v", err)
                }</span>
        })

        // API 라우터 그룹
        <span class="cov0" title="0">r.Route("/api", func(r chi.Router) </span><span class="cov0" title="0">{
                apiHandler.RegisterRoutes(r)
        }</span>)

        // 서버 설정
        <span class="cov0" title="0">srv := &amp;http.Server{
                Addr:              fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port),
                Handler:           r,
                ReadTimeout:       cfg.Server.ReadTimeout,
                WriteTimeout:      cfg.Server.WriteTimeout,
                IdleTimeout:       cfg.Server.IdleTimeout,
                ReadHeaderTimeout: 2 * time.Second,
        }

        // 종료 시그널 처리
        done := make(chan os.Signal, 1)
        signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                log.Printf("서버가 시작되었습니다. %s에서 대기 중...", srv.Addr)
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span
                        class="cov0" title="0">{
                        log.Fatalf("서버 시작 실패: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">&lt;-done
        log.Println("서버 종료 중...")

        ctx, cancel := context.WithTimeout(context.Background(), cfg.Server.ShutdownTimeout)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("서버 종료 실패: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("서버가 정상적으로 종료되었습니다.")</span>
}
</pre>

                <pre class="file" id="file1" style="display: none">package api

import (
        "encoding/json"
        "net/http"
        "time"

        "github.com/aske/go_fi_chart/internal/domain/asset"
        "github.com/aske/go_fi_chart/internal/domain/gamification"
        chi "github.com/go-chi/chi/v5"
)

// CreateAssetRequest 자산 생성 요청
type CreateAssetRequest struct {
        UserID   string  `json:"userId"`
        Type     string  `json:"type"`
        Name     string  `json:"name"`
        Amount   float64 `json:"amount"`
        Currency string  `json:"currency"`
}

// UpdateAssetAmountRequest 자산 금액 업데이트 요청
type UpdateAssetAmountRequest struct {
        Amount   float64 `json:"amount"`
        Currency string  `json:"currency"`
}

// AssetResponse 자산 응답
type AssetResponse struct {
        ID        string    `json:"id"`
        UserID    string    `json:"userId"`
        Type      string    `json:"type"`
        Name      string    `json:"name"`
        Amount    float64   `json:"amount"`
        Currency  string    `json:"currency"`
        CreatedAt time.Time `json:"createdAt"`
        UpdatedAt time.Time `json:"updatedAt"`
}

// ErrorResponse API 에러 응답 구조체
type ErrorResponse struct {
        Code    string `json:"code"`
        Message string `json:"message"`
}

// API 에러 코드 상수
const (
        ErrInvalidRequest = "INVALID_REQUEST"
        ErrNotFound       = "NOT_FOUND"
        ErrInternalServer = "INTERNAL_SERVER_ERROR"
        ErrValidation     = "VALIDATION_ERROR"
        ErrNotImplemented = "NOT_IMPLEMENTED"
)

// Handler API 핸들러입니다.
type Handler struct {
        assetRepo        asset.Repository
        transactionRepo  asset.TransactionRepository
        portfolioRepo    asset.PortfolioRepository
        gamificationRepo gamification.Repository
}

// NewHandler 새로운 API 핸들러를 생성합니다.
func NewHandler(
        assetRepo asset.Repository,
        transactionRepo asset.TransactionRepository,
        portfolioRepo asset.PortfolioRepository,
        gamificationRepo gamification.Repository,
) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                assetRepo:        assetRepo,
                transactionRepo:  transactionRepo,
                portfolioRepo:    portfolioRepo,
                gamificationRepo: gamificationRepo,
        }
}</span>

// RegisterRoutes 라우터에 API 핸들러를 등록합니다.
func (h *Handler) RegisterRoutes(r chi.Router) <span class="cov0" title="0">{
        // 자산 관리 API
        r.Route("/assets", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Get("/", h.ListAssets)
                r.Post("/", h.CreateAsset)
                r.Get("/{id}", h.GetAsset)
                r.Put("/{id}", h.UpdateAsset)
                r.Delete("/{id}", h.DeleteAsset)
        }</span>)

        // 거래 내역 API
        <span class="cov0" title="0">r.Route("/transactions", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Get("/", h.ListTransactions)
                r.Post("/", h.CreateTransaction)
                r.Get("/{id}", h.GetTransaction)
        }</span>)

        // 포트폴리오 API
        <span class="cov0" title="0">r.Route("/portfolios", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Get("/", h.GetPortfolio)
                r.Put("/", h.UpdatePortfolio)
        }</span>)

        // 게임화 API
        <span class="cov0" title="0">r.Route("/gamification", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Get("/profile", h.GetProfile)
                r.Get("/badges", h.ListBadges)
                r.Get("/streaks", h.ListStreaks)
                r.Get("/stats", h.GetStats)
        }</span>)
}

// 응답 헬퍼 함수
func respondJSON(w http.ResponseWriter, status int, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        if data != nil </span><span class="cov0" title="0">{
                if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                        respondError(w, http.StatusInternalServerError, ErrInternalServer, "응답 생성 중 오류가 발생했습니다")
                }</span>
        }
}

func respondError(w http.ResponseWriter, status int, code string, message string) <span class="cov0" title="0">{
        respondJSON(w, status, ErrorResponse{
                Code:    code,
                Message: message,
        })
}</span>

// 요청/응답 구조체
type UpdateAssetRequest struct {
        Name     string  `json:"name,omitempty"`
        Amount   float64 `json:"amount,omitempty"`
        Currency string  `json:"currency,omitempty"`
}

// ListAssets godoc
// @Summary 사용자의 자산 목록을 조회합니다
// @Description 특정 사용자의 모든 자산 목록을 반환합니다
// @Tags assets
// @Accept json
// @Produce json
// @Param userId query string true "사용자 ID"
// @Success 200 {array} AssetResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /assets [get]
func (h *Handler) ListAssets(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.URL.Query().Get("userId")
        if userID == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, ErrInvalidRequest, "사용자 ID가 필요합니다")
                return
        }</span>

        <span class="cov0" title="0">assets, err := h.assetRepo.FindByUserID(r.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, ErrInternalServer, "자산 목록 조회 실패")
                return
        }</span>

        <span class="cov0" title="0">response := make([]AssetResponse, len(assets))
        for i, asset := range assets </span><span class="cov0" title="0">{
                response[i] = AssetResponse{
                        ID:        asset.ID,
                        UserID:    asset.UserID,
                        Type:      string(asset.Type),
                        Name:      asset.Name,
                        Amount:    asset.Amount.Amount,
                        Currency:  asset.Amount.Currency,
                        CreatedAt: asset.CreatedAt,
                        UpdatedAt: asset.UpdatedAt,
                }
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, response)</span>
}

func (h *Handler) CreateAsset(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req CreateAssetRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, ErrInvalidRequest, "잘못된 요청 형식")
                return
        }</span>

        <span class="cov0" title="0">newAsset, err := asset.NewAsset(req.UserID, asset.Type(req.Type), req.Name, req.Amount, req.Currency)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, ErrValidation, err.Error())
                return
        }</span>

        <span class="cov0" title="0">if err := h.assetRepo.Save(r.Context(), newAsset); err != nil </span><span
                                class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, ErrInternalServer, "자산 생성 실패")
                return
        }</span>

        <span class="cov0" title="0">response := AssetResponse{
                ID:        newAsset.ID,
                UserID:    newAsset.UserID,
                Type:      string(newAsset.Type),
                Name:      newAsset.Name,
                Amount:    newAsset.Amount.Amount,
                Currency:  newAsset.Amount.Currency,
                CreatedAt: newAsset.CreatedAt,
                UpdatedAt: newAsset.UpdatedAt,
        }

        respondJSON(w, http.StatusCreated, response)</span>
}

func (h *Handler) GetAsset(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := chi.URLParam(r, "id")
        if id == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, ErrInvalidRequest, "자산 ID가 필요합니다")
                return
        }</span>

        <span class="cov0" title="0">asset, err := h.assetRepo.FindByID(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, ErrNotFound, "자산을 찾을 수 없습니다")
                return
        }</span>

        <span class="cov0" title="0">response := AssetResponse{
                ID:        asset.ID,
                UserID:    asset.UserID,
                Type:      string(asset.Type),
                Name:      asset.Name,
                Amount:    asset.Amount.Amount,
                Currency:  asset.Amount.Currency,
                CreatedAt: asset.CreatedAt,
                UpdatedAt: asset.UpdatedAt,
        }

        respondJSON(w, http.StatusOK, response)</span>
}

func (h *Handler) UpdateAsset(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := chi.URLParam(r, "id")
        if id == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, ErrInvalidRequest, "자산 ID가 필요합니다")
                return
        }</span>

        <span class="cov0" title="0">var req UpdateAssetRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, ErrInvalidRequest, "잘못된 요청 형식")
                return
        }</span>

        <span class="cov0" title="0">asset, err := h.assetRepo.FindByID(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, ErrNotFound, "자산을 찾을 수 없습니다")
                return
        }</span>

        <span class="cov0" title="0">if req.Name != "" </span><span class="cov0" title="0">{
                asset.Name = req.Name
        }</span>
        <span class="cov0" title="0">if req.Amount != 0 </span><span class="cov0" title="0">{
                asset.Amount.Amount = req.Amount
        }</span>
        <span class="cov0" title="0">if req.Currency != "" </span><span class="cov0" title="0">{
                asset.Amount.Currency = req.Currency
        }</span>
        <span class="cov0" title="0">asset.UpdatedAt = time.Now()

        if err := h.assetRepo.Update(r.Context(), asset); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, ErrInternalServer, "자산 업데이트 실패")
                return
        }</span>

        <span class="cov0" title="0">response := AssetResponse{
                ID:        asset.ID,
                UserID:    asset.UserID,
                Type:      string(asset.Type),
                Name:      asset.Name,
                Amount:    asset.Amount.Amount,
                Currency:  asset.Amount.Currency,
                CreatedAt: asset.CreatedAt,
                UpdatedAt: asset.UpdatedAt,
        }

        respondJSON(w, http.StatusOK, response)</span>
}

func (h *Handler) DeleteAsset(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := chi.URLParam(r, "id")
        if id == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, ErrInvalidRequest, "자산 ID가 필요합니다")
                return
        }</span>

        <span class="cov0" title="0">if err := h.assetRepo.Delete(r.Context(), id); err != nil </span><span class="cov0"
                                                                                                            title="0">{
                respondError(w, http.StatusInternalServerError, ErrInternalServer, "자산 삭제 실패")
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusNoContent, nil)</span>
}

// 거래 내역 요청/응답 구조체
type CreateTransactionRequest struct {
        AssetID     string  `json:"assetId"`
        Type        string  `json:"type"`
        Amount      float64 `json:"amount"`
        Currency    string  `json:"currency"`
        Category    string  `json:"category"`
        Description string  `json:"description"`
}

type TransactionResponse struct {
        ID          string    `json:"id"`
        AssetID     string    `json:"assetId"`
        Type        string    `json:"type"`
        Amount      float64   `json:"amount"`
        Currency    string    `json:"currency"`
        Category    string    `json:"category"`
        Description string    `json:"description"`
        Date        time.Time `json:"date"`
        CreatedAt   time.Time `json:"createdAt"`
}

func (h *Handler) ListTransactions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        assetID := r.URL.Query().Get("assetId")
        if assetID == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, ErrInvalidRequest, "자산 ID가 필요합니다")
                return
        }</span>

        <span class="cov0" title="0">transactions, err := h.transactionRepo.FindByAssetID(r.Context(), assetID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, ErrInternalServer, "거래 내역 조회 실패")
                return
        }</span>

        <span class="cov0" title="0">response := make([]TransactionResponse, len(transactions))
        for i, tx := range transactions </span><span class="cov0" title="0">{
                response[i] = TransactionResponse{
                        ID:          tx.ID,
                        AssetID:     tx.AssetID,
                        Type:        string(tx.Type),
                        Amount:      tx.Amount.Amount,
                        Currency:    tx.Amount.Currency,
                        Category:    tx.Category,
                        Description: tx.Description,
                        Date:        tx.Date,
                        CreatedAt:   tx.CreatedAt,
                }
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, response)</span>
}

func (h *Handler) CreateTransaction(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req CreateTransactionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, ErrInvalidRequest, "잘못된 요청 형식")
                return
        }</span>

        // 자산 존재 여부 확인
        <span class="cov0" title="0">targetAsset, err := h.assetRepo.FindByID(r.Context(), req.AssetID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, ErrNotFound, "자산을 찾을 수 없습니다")
                return
        }</span>

        // 거래 생성
        <span class="cov0" title="0">money, err := asset.NewMoney(req.Amount, req.Currency)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, ErrValidation, err.Error())
                return
        }</span>
        <span class="cov0" title="0">tx, err := asset.NewTransaction(
                req.AssetID,
                asset.TransactionType(req.Type),
                money,
                req.Category,
                req.Description,
        )
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, ErrValidation, err.Error())
                return
        }</span>

        // 거래 유효성 검증
        <span class="cov0" title="0">if err := targetAsset.ValidateTransaction(tx); err != nil </span><span class="cov0"
                                                                                                            title="0">{
                respondError(w, http.StatusBadRequest, ErrValidation, err.Error())
                return
        }</span>

        // 거래 처리 및 자산 업데이트
        <span class="cov0" title="0">if err := targetAsset.ProcessTransaction(tx); err != nil </span><span class="cov0"
                                                                                                           title="0">{
                respondError(w, http.StatusBadRequest, ErrValidation, err.Error())
                return
        }</span>

        // 트랜잭션 저장
        <span class="cov0" title="0">if err := h.transactionRepo.Save(r.Context(), tx); err != nil </span><span
                                class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, ErrInternalServer, "거래 생성 실패")
                return
        }</span>

        // 자산 상태 저장
        <span class="cov0" title="0">if err := h.assetRepo.Update(r.Context(), targetAsset); err != nil </span><span
                                class="cov0" title="0">{
                // 롤백 처리가 필요할 수 있음
                respondError(w, http.StatusInternalServerError, ErrInternalServer, "자산 상태 업데이트 실패")
                return
        }</span>

        <span class="cov0" title="0">response := TransactionResponse{
                ID:          tx.ID,
                AssetID:     tx.AssetID,
                Type:        string(tx.Type),
                Amount:      tx.Amount.Amount,
                Currency:    tx.Amount.Currency,
                Category:    tx.Category,
                Description: tx.Description,
                Date:        tx.Date,
                CreatedAt:   tx.CreatedAt,
        }

        respondJSON(w, http.StatusCreated, response)</span>
}

func (h *Handler) GetTransaction(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := chi.URLParam(r, "id")
        if id == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, ErrInvalidRequest, "거래 ID가 필요합니다")
                return
        }</span>

        <span class="cov0" title="0">tx, err := h.transactionRepo.FindByID(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, ErrNotFound, "거래를 찾을 수 없습니다")
                return
        }</span>

        <span class="cov0" title="0">response := TransactionResponse{
                ID:          tx.ID,
                AssetID:     tx.AssetID,
                Type:        string(tx.Type),
                Amount:      tx.Amount.Amount,
                Currency:    tx.Amount.Currency,
                Category:    tx.Category,
                Description: tx.Description,
                Date:        tx.Date,
                CreatedAt:   tx.CreatedAt,
        }

        respondJSON(w, http.StatusOK, response)</span>
}

// GetPortfolio godoc
// @Summary 포트폴리오를 조회합니다
// @Description 사용자의 포트폴리오 정보를 반환합니다
// @Tags portfolios
// @Accept json
// @Produce json
// @Param userId query string true "사용자 ID"
// @Success 200 {object} PortfolioResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Router /portfolios [get]
func (h *Handler) GetPortfolio(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        respondError(w, http.StatusNotImplemented, ErrNotImplemented, "이 기능은 아직 구현되지 않았습니다")
}</span>

func (h *Handler) UpdatePortfolio(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        respondError(w, http.StatusNotImplemented, ErrNotImplemented, "이 기능은 아직 구현되지 않았습니다")
}</span>

// GetProfile godoc
// @Summary 사용자 프로필을 조회합니다
// @Description 사용자의 게임화 프로필 정보를 반환합니다
// @Tags gamification
// @Accept json
// @Produce json
// @Param userId query string true "사용자 ID"
// @Success 200 {object} ProfileResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Router /gamification/profile [get]
func (h *Handler) GetProfile(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        respondError(w, http.StatusNotImplemented, ErrNotImplemented, "이 기능은 아직 구현되지 않았습니다")
}</span>

func (h *Handler) ListBadges(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        respondError(w, http.StatusNotImplemented, ErrNotImplemented, "이 기능은 아직 구현되지 않았습니다")
}</span>

func (h *Handler) ListStreaks(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        respondError(w, http.StatusNotImplemented, ErrNotImplemented, "이 기능은 아직 구현되지 않았습니다")
}</span>

func (h *Handler) GetStats(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        respondError(w, http.StatusNotImplemented, ErrNotImplemented, "이 기능은 아직 구현되지 않았습니다")
}</span>

// UpdateAssetAmount 자산의 금액을 업데이트합니다.
func (h *Handler) UpdateAssetAmount(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req UpdateAssetAmountRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, ErrInvalidRequest, "잘못된 요청 형식")
                return
        }</span>

        <span class="cov0" title="0">money := asset.NewTestMoney(req.Amount, req.Currency)

        id := chi.URLParam(r, "id")
        if err := h.assetRepo.UpdateAmount(r.Context(), id, money); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, ErrInternalServer, "자산 금액 업데이트 실패")
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, nil)</span>
}
</pre>

                <pre class="file" id="file2" style="display: none">package config

import "time"

// Config 애플리케이션 전체 설정입니다.
type Config struct {
        Server   ServerConfig   `yaml:"server"`
        Metrics  MetricsConfig  `yaml:"metrics"`
        Database DatabaseConfig `yaml:"database"`
}

// ServerConfig HTTP 서버 설정입니다.
type ServerConfig struct {
        Host            string        `yaml:"host"`
        Port            int           `yaml:"port"`
        ReadTimeout     time.Duration `yaml:"readTimeout"`
        WriteTimeout    time.Duration `yaml:"writeTimeout"`
        IdleTimeout     time.Duration `yaml:"idleTimeout"`
        ShutdownTimeout time.Duration `yaml:"shutdownTimeout"`
}

// MetricsConfig 메트릭 설정입니다.
type MetricsConfig struct {
        Enabled         bool          `yaml:"enabled"`
        CollectInterval time.Duration `yaml:"collectInterval"`
        ExportInterval  time.Duration `yaml:"exportInterval"`
        RetentionPeriod time.Duration `yaml:"retentionPeriod"`
}

// DatabaseConfig 데이터베이스 설정입니다.
type DatabaseConfig struct {
        Driver          string        `yaml:"driver"`
        Host            string        `yaml:"host"`
        Port            int           `yaml:"port"`
        Name            string        `yaml:"name"`
        User            string        `yaml:"user"`
        Password        string        `yaml:"password"`
        ConnectTimeout  time.Duration `yaml:"connectTimeout"`
        MaxOpenConns    int           `yaml:"maxOpenConns"`
        MaxIdleConns    int           `yaml:"maxIdleConns"`
        ConnMaxLifetime time.Duration `yaml:"connMaxLifetime"`
}

// NewDefaultConfig 기본 설정값을 가진 Config를 생성합니다.
func NewDefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Server: ServerConfig{
                        Host:            "localhost",
                        Port:            8080,
                        ReadTimeout:     5 * time.Second,
                        WriteTimeout:    10 * time.Second,
                        IdleTimeout:     120 * time.Second,
                        ShutdownTimeout: 5 * time.Second,
                },
                Metrics: MetricsConfig{
                        Enabled:         true,
                        CollectInterval: 10 * time.Second,
                        ExportInterval:  30 * time.Second,
                        RetentionPeriod: 24 * time.Hour,
                },
                Database: DatabaseConfig{
                        Driver:          "postgres",
                        Host:            "localhost",
                        Port:            5432,
                        ConnectTimeout:  5 * time.Second,
                        MaxOpenConns:    25,
                        MaxIdleConns:    5,
                        ConnMaxLifetime: 5 * time.Minute,
                },
        }
}</span>
</pre>

                <pre class="file" id="file3" style="display: none">package di

import (
        "fmt"
        "reflect"
        "sync"
)

// Container 의존성 주입 컨테이너 인터페이스입니다.
type Container interface {
        // Register 의존성을 등록합니다.
        Register(name string, constructor interface{}) error
        // Resolve 의존성을 해결합니다.
        Resolve(name string) (interface{}, error)
}

// SimpleContainer 기본 의존성 주입 컨테이너 구현체입니다.
type SimpleContainer struct {
        mu           sync.RWMutex
        constructors map[string]interface{}
        instances    map[string]interface{}
}

// NewSimpleContainer 새로운 SimpleContainer를 생성합니다.
func NewSimpleContainer() *SimpleContainer <span class="cov0" title="0">{
        return &amp;SimpleContainer{
                constructors: make(map[string]interface{}),
                instances:    make(map[string]interface{}),
        }
}</span>

// Register 의존성 생성자를 등록합니다.
func (c *SimpleContainer) Register(name string, constructor interface{}) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if constructor == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("constructor cannot be nil")
        }</span>

        <span class="cov0" title="0">if _, exists := c.constructors[name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("dependency %s already registered", name)
        }</span>

        <span class="cov0" title="0">c.constructors[name] = constructor
        return nil</span>
}

// Resolve 의존성을 해결하고 인스턴스를 반환합니다.
func (c *SimpleContainer) Resolve(name string) (interface{}, error) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // 이미 생성된 인스턴스가 있는지 확인
        if instance, exists := c.instances[name]; exists </span><span class="cov0" title="0">{
                return instance, nil
        }</span>

        // 생성자 찾기
        <span class="cov0" title="0">constructor, exists := c.constructors[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dependency %s not registered", name)
        }</span>

        // 생성자 호출
        <span class="cov0" title="0">constructorValue := reflect.ValueOf(constructor)
        if constructorValue.Kind() != reflect.Func </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("constructor for %s must be a function", name)
        }</span>

        // 생성자 파라미터 해결
        <span class="cov0" title="0">params := make([]reflect.Value, constructorValue.Type().NumIn())
        for i := 0; i &lt; constructorValue.Type().NumIn(); i++ </span><span class="cov0" title="0">{
                paramType := constructorValue.Type().In(i)
                // TODO: 파라미터 의존성 해결 로직 구현
                params[i] = reflect.New(paramType).Elem()
        }</span>

        // 인스턴스 생성
        <span class="cov0" title="0">results := constructorValue.Call(params)
        if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("constructor for %s must return at least one value", name)
        }</span>

        <span class="cov0" title="0">instance := results[0].Interface()
        c.instances[name] = instance

        return instance, nil</span>
}
</pre>

                <pre class="file" id="file4" style="display: none">package asset

import (
        "github.com/google/uuid"
)

// generateID는 UUID v4를 사용하여 고유한 ID를 생성합니다.
// UUID v4는 랜덤하게 생성되며, 충돌 가능성이 극히 낮습니다.
// 또한 내부적으로 동시성을 지원하므로 별도의 동기화가 필요하지 않습니다.
func generateID() string <span class="cov8" title="1">{
        return uuid.New().String()
}</span>
</pre>

                <pre class="file" id="file5" style="display: none">package asset

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/aske/go_fi_chart/internal/domain"
)

// MemoryRepository 인메모리 저장소 구현체
type MemoryRepository[T any] struct {
        data  map[string]T
        mutex sync.RWMutex
}

// NewMemoryRepository 새로운 인메모리 저장소를 생성합니다.
func NewMemoryRepository[T any]() *MemoryRepository[T] <span class="cov8" title="1">{
        return &amp;MemoryRepository[T]{
                data: make(map[string]T),
        }
}</span>

// Save 엔티티를 저장합니다.
func (r *MemoryRepository[T]) Save(_ context.Context, entity interface{}) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if e, ok := entity.(domain.Entity); ok </span><span class="cov8" title="1">{
                if _, exists := r.data[e.GetID()]; exists </span><span class="cov0" title="0">{
                        return domain.NewRepositoryError("Save", fmt.Errorf("entity with ID %s already exists", e.GetID()))
                }</span>

                <span class="cov8" title="1">if t, ok := entity.(T); ok </span><span class="cov8" title="1">{
                        r.data[e.GetID()] = t
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return domain.NewRepositoryError("Save", fmt.Errorf("invalid entity type"))</span>
}

// FindByID ID로 엔티티를 조회합니다.
func (r *MemoryRepository[T]) FindByID(_ context.Context, id string) (T, error) <span class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        if entity, exists := r.data[id]; exists </span><span class="cov8" title="1">{
                return entity, nil
        }</span>

        <span class="cov8" title="1">var zero T
        return zero, domain.NewRepositoryError("FindByID", fmt.Errorf("entity with ID %s not found", id))</span>
}

// Update 엔티티를 업데이트합니다.
func (r *MemoryRepository[T]) Update(_ context.Context, entity interface{}) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if e, ok := entity.(domain.Entity); ok </span><span class="cov8" title="1">{
                if _, exists := r.data[e.GetID()]; !exists </span><span class="cov0" title="0">{
                        return domain.NewRepositoryError("Update", fmt.Errorf("entity with ID %s not found", e.GetID()))
                }</span>

                <span class="cov8" title="1">if t, ok := entity.(T); ok </span><span class="cov8" title="1">{
                        r.data[e.GetID()] = t
                        return nil
                }</span>
        }
        <span class="cov0"
              title="0">return domain.NewRepositoryError("Update", fmt.Errorf("invalid entity type"))</span>
}

// Delete ID로 엔티티를 삭제합니다.
func (r *MemoryRepository[T]) Delete(_ context.Context, id string) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.data[id]; !exists </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("Delete", fmt.Errorf("entity with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">delete(r.data, id)
        return nil</span>
}

// FindAll 검색 조건에 맞는 모든 엔티티를 조회합니다.
func (r *MemoryRepository[T]) FindAll(_ context.Context, _ domain.SearchCriteria) ([]T, error) <span class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var result []T
        for _, entity := range r.data </span><span class="cov0" title="0">{
                result = append(result, entity)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// FindOne 검색 조건에 맞는 하나의 엔티티를 조회합니다.
func (r *MemoryRepository[T]) FindOne(_ context.Context, _ domain.SearchCriteria) (T, error) <span class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var zero T
        return zero, domain.NewRepositoryError("FindOne", fmt.Errorf("not implemented"))
}</span>

// WithTransaction 트랜잭션을 실행합니다.
func (r *MemoryRepository[T]) WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error <span class="cov0" title="0">{
        return fn(ctx)
}</span>

// MemoryAssetRepository Asset 도메인의 인메모리 저장소 구현체입니다.
type MemoryAssetRepository struct {
        repo         *MemoryRepository[*Asset]
        transactions map[string]*Transaction
        mutex        sync.RWMutex
}

// NewMemoryAssetRepository 새로운 MemoryAssetRepository를 생성합니다.
func NewMemoryAssetRepository() *MemoryAssetRepository <span class="cov8" title="1">{
        return &amp;MemoryAssetRepository{
                repo:         NewMemoryRepository[*Asset](),
                transactions: make(map[string]*Transaction),
        }
}</span>

// Save Asset을 저장합니다.
func (r *MemoryAssetRepository) Save(ctx context.Context, asset *Asset) error <span class="cov8" title="1">{
        return r.repo.Save(ctx, asset)
}</span>

// FindByID ID로 Asset을 조회합니다.
func (r *MemoryAssetRepository) FindByID(ctx context.Context, id string) (*Asset, error) <span class="cov8" title="1">{
        return r.repo.FindByID(ctx, id)
}</span>

// Update Asset을 업데이트합니다.
func (r *MemoryAssetRepository) Update(ctx context.Context, asset *Asset) error <span class="cov8" title="1">{
        return r.repo.Update(ctx, asset)
}</span>

// Delete ID로 Asset을 삭제합니다.
func (r *MemoryAssetRepository) Delete(ctx context.Context, id string) error <span class="cov8" title="1">{
        return r.repo.Delete(ctx, id)
}</span>

// FindByUserID 사용자 ID로 Asset 목록을 조회합니다.
func (r *MemoryAssetRepository) FindByUserID(_ context.Context, userID string) ([]*Asset, error) <span class="cov8"
                                                                                                       title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var result []*Asset
        for _, asset := range r.repo.data </span><span class="cov8" title="1">{
                if asset.UserID == userID </span><span class="cov8" title="1">{
                        result = append(result, asset)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// FindByType Asset 유형으로 Asset 목록을 조회합니다.
func (r *MemoryAssetRepository) FindByType(_ context.Context, assetType Type) ([]*Asset, error) <span class="cov8"
                                                                                                      title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var result []*Asset
        for _, asset := range r.repo.data </span><span class="cov8" title="1">{
                if asset.Type == assetType </span><span class="cov8" title="1">{
                        result = append(result, asset)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// UpdateAmount 자산의 금액을 업데이트합니다.
func (r *MemoryAssetRepository) UpdateAmount(_ context.Context, id string, amount Money) error <span class="cov8"
                                                                                                     title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        asset, exists := r.repo.data[id]
        if !exists </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("UpdateAmount", fmt.Errorf("asset with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">asset.Amount = amount
        asset.UpdatedAt = time.Now()
        r.repo.data[id] = asset

        return nil</span>
}

// FindAll 검색 조건에 맞는 모든 Asset을 조회합니다.
func (r *MemoryAssetRepository) FindAll(_ context.Context, _ domain.SearchCriteria) ([]*Asset, error) <span class="cov0"
                                                                                                            title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var result []*Asset
        for _, asset := range r.repo.data </span><span class="cov0" title="0">{
                result = append(result, asset)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// FindOne 검색 조건에 맞는 하나의 Asset을 조회합니다.
func (r *MemoryAssetRepository) FindOne(ctx context.Context, criteria domain.SearchCriteria) (*Asset, error) <span
                                class="cov0" title="0">{
        return r.repo.FindOne(ctx, criteria)
}</span>

// WithTransaction 트랜잭션을 실행합니다.
func (r *MemoryAssetRepository) WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error <span
                                class="cov0" title="0">{
        return r.repo.WithTransaction(ctx, fn)
}</span>

// SaveTransaction 거래를 저장합니다.
func (r *MemoryAssetRepository) SaveTransaction(_ context.Context, tx *Transaction) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        r.transactions[tx.ID] = tx
        return nil
}</span>

// FindTransactionByID ID로 거래를 찾습니다.
func (r *MemoryAssetRepository) FindTransactionByID(_ context.Context, id string) (*Transaction, error) <span
                                class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        tx, exists := r.transactions[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, domain.NewRepositoryError("FindTransactionByID", fmt.Errorf("transaction with ID %s not found", id))
        }</span>
        <span class="cov8" title="1">return tx, nil</span>
}

// FindTransactionsByDateRange 날짜 범위로 거래를 찾습니다.
func (r *MemoryAssetRepository) FindTransactionsByDateRange(_ context.Context, start, end time.Time) ([]*Transaction, error) <span
                                class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var result []*Transaction
        for _, tx := range r.transactions </span><span class="cov8" title="1">{
                if (tx.Date.Equal(start) || tx.Date.After(start)) &amp;&amp; (tx.Date.Equal(end) || tx.Date.Before(end)) </span><span
                                class="cov8" title="1">{
                        result = append(result, tx)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// CalculateTotalAmount 특정 통화의 총 금액을 계산합니다.
func (r *MemoryAssetRepository) CalculateTotalAmount(_ context.Context, currency string) (Money, error) <span
                                class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        total := NewTestMoney(0, currency)
        for _, tx := range r.transactions </span><span class="cov8" title="1">{
                if tx.Amount.Currency == currency </span><span class="cov8" title="1">{
                        switch tx.Type </span>{
                        case Income:<span class="cov8" title="1">
                                result, err := total.Add(tx.Amount)
                                if err != nil </span><span class="cov0" title="0">{
                                        return Money{}, err
                                }</span>
                                <span class="cov8" title="1">total = result</span>
                        case Expense:<span class="cov0" title="0">
                                result, err := total.Subtract(tx.Amount)
                                if err != nil </span><span class="cov0" title="0">{
                                        return Money{}, err
                                }</span>
                                <span class="cov0" title="0">total = result</span>
                        }
                }
        }
        <span class="cov8" title="1">return total, nil</span>
}

// MemoryTransactionRepository Transaction 도메인의 인메모리 저장소 구현체입니다.
type MemoryTransactionRepository struct {
        repo *MemoryRepository[*Transaction]
}

// NewMemoryTransactionRepository 새로운 인메모리 Transaction 저장소를 생성합니다.
func NewMemoryTransactionRepository() *MemoryTransactionRepository <span class="cov0" title="0">{
        return &amp;MemoryTransactionRepository{
                repo: NewMemoryRepository[*Transaction](),
        }
}</span>

// Save Transaction을 저장합니다.
func (r *MemoryTransactionRepository) Save(ctx context.Context, tx *Transaction) error <span class="cov0" title="0">{
        return r.repo.Save(ctx, tx)
}</span>

// FindByID ID로 Transaction을 조회합니다.
func (r *MemoryTransactionRepository) FindByID(ctx context.Context, id string) (*Transaction, error) <span class="cov0"
                                                                                                           title="0">{
        return r.repo.FindByID(ctx, id)
}</span>

// Update Transaction을 업데이트합니다.
func (r *MemoryTransactionRepository) Update(ctx context.Context, tx *Transaction) error <span class="cov0" title="0">{
        return r.repo.Update(ctx, tx)
}</span>

// Delete ID로 Transaction을 삭제합니다.
func (r *MemoryTransactionRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        return r.repo.Delete(ctx, id)
}</span>

// FindByAssetID AssetID로 Transaction 목록을 조회합니다.
func (r *MemoryTransactionRepository) FindByAssetID(_ context.Context, assetID string) ([]*Transaction, error) <span
                                class="cov0" title="0">{
        r.repo.mutex.RLock()
        defer r.repo.mutex.RUnlock()

        var result []*Transaction
        for _, tx := range r.repo.data </span><span class="cov0" title="0">{
                if tx.AssetID == assetID </span><span class="cov0" title="0">{
                        result = append(result, tx)
                }</span>
        }
        <span class="cov0" title="0">return result, nil</span>
}

// FindByDateRange 날짜 범위로 Transaction 목록을 조회합니다.
func (r *MemoryTransactionRepository) FindByDateRange(_ context.Context, start, end time.Time) ([]*Transaction, error) <span
                                class="cov0" title="0">{
        r.repo.mutex.RLock()
        defer r.repo.mutex.RUnlock()

        var result []*Transaction
        for _, tx := range r.repo.data </span><span class="cov0" title="0">{
                if (tx.Date.Equal(start) || tx.Date.After(start)) &amp;&amp;
                        (tx.Date.Equal(end) || tx.Date.Before(end)) </span><span class="cov0" title="0">{
                        result = append(result, tx)
                }</span>
        }
        <span class="cov0" title="0">return result, nil</span>
}

// GetTotalAmount 특정 기간 동안의 총 거래 금액을 계산합니다.
func (r *MemoryTransactionRepository) GetTotalAmount(_ context.Context, assetID string) (Money, error) <span
                                class="cov0" title="0">{
        r.repo.mutex.RLock()
        defer r.repo.mutex.RUnlock()

        total := Money{Amount: 0, Currency: "KRW"}
        for _, tx := range r.repo.data </span><span class="cov0" title="0">{
                if tx.AssetID == assetID </span><span class="cov0" title="0">{
                        switch tx.Type </span>{
                        case Income:<span class="cov0" title="0">
                                result, err := total.Add(tx.Amount)
                                if err != nil </span><span class="cov0" title="0">{
                                        return Money{}, err
                                }</span>
                                <span class="cov0" title="0">total = result</span>
                        case Expense:<span class="cov0" title="0">
                                result, err := total.Subtract(tx.Amount)
                                if err != nil </span><span class="cov0" title="0">{
                                        return Money{}, err
                                }</span>
                                <span class="cov0" title="0">total = result</span>
                        }
                }
        }
        <span class="cov0" title="0">return total, nil</span>
}

// FindAll 검색 조건에 맞는 모든 Transaction을 조회합니다.
func (r *MemoryTransactionRepository) FindAll(_ context.Context, _ domain.SearchCriteria) ([]*Transaction, error) <span
                                class="cov0" title="0">{
        r.repo.mutex.RLock()
        defer r.repo.mutex.RUnlock()

        var result []*Transaction
        for _, tx := range r.repo.data </span><span class="cov0" title="0">{
                result = append(result, tx)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// FindOne 검색 조건에 맞는 하나의 Transaction을 조회합니다.
func (r *MemoryTransactionRepository) FindOne(ctx context.Context, criteria domain.SearchCriteria) (*Transaction, error) <span
                                class="cov0" title="0">{
        return r.repo.FindOne(ctx, criteria)
}</span>

// WithTransaction 트랜잭션을 실행합니다.
func (r *MemoryTransactionRepository) WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error <span
                                class="cov0" title="0">{
        return r.repo.WithTransaction(ctx, fn)
}</span>

// MemoryPortfolioRepository Portfolio 도메인의 인메모리 저장소 구현체입니다.
type MemoryPortfolioRepository struct {
        repo *MemoryRepository[*Portfolio]
}

// NewMemoryPortfolioRepository 새로운 인메모리 Portfolio 저장소를 생성합니다.
func NewMemoryPortfolioRepository() *MemoryPortfolioRepository <span class="cov8" title="1">{
        return &amp;MemoryPortfolioRepository{
                repo: NewMemoryRepository[*Portfolio](),
        }
}</span>

// Save Portfolio를 저장합니다.
func (r *MemoryPortfolioRepository) Save(ctx context.Context, portfolio *Portfolio) error <span class="cov8" title="1">{
        return r.repo.Save(ctx, portfolio)
}</span>

// FindByID ID로 Portfolio를 조회합니다.
func (r *MemoryPortfolioRepository) FindByID(ctx context.Context, id string) (*Portfolio, error) <span class="cov8"
                                                                                                       title="1">{
        return r.repo.FindByID(ctx, id)
}</span>

// Update Portfolio를 업데이트합니다.
func (r *MemoryPortfolioRepository) Update(ctx context.Context, portfolio *Portfolio) error <span class="cov0"
                                                                                                  title="0">{
        return r.repo.Update(ctx, portfolio)
}</span>

// Delete ID로 Portfolio를 삭제합니다.
func (r *MemoryPortfolioRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        return r.repo.Delete(ctx, id)
}</span>

// FindByUserID 사용자 ID로 Portfolio를 조회합니다.
func (r *MemoryPortfolioRepository) FindByUserID(_ context.Context, userID string) (*Portfolio, error) <span
                                class="cov8" title="1">{
        r.repo.mutex.RLock()
        defer r.repo.mutex.RUnlock()

        for _, portfolio := range r.repo.data </span><span class="cov8" title="1">{
                if portfolio.UserID == userID </span><span class="cov8" title="1">{
                        return portfolio, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, domain.NewRepositoryError("FindByUserID", fmt.Errorf("portfolio for user %s not found", userID))</span>
}

// UpdateAssets Portfolio의 자산 구성을 업데이트합니다.
func (r *MemoryPortfolioRepository) UpdateAssets(_ context.Context, id string, assets []PortfolioAsset) error <span
                                class="cov8" title="1">{
        r.repo.mutex.Lock()
        defer r.repo.mutex.Unlock()

        portfolio, ok := r.repo.data[id]
        if !ok </span><span class="cov0" title="0">{
                return domain.NewRepositoryError("UpdateAssets", fmt.Errorf("portfolio with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">portfolio.Assets = assets
        portfolio.UpdatedAt = time.Now()
        r.repo.data[id] = portfolio

        return nil</span>
}

// FindAll 검색 조건에 맞는 모든 Portfolio를 조회합니다.
func (r *MemoryPortfolioRepository) FindAll(_ context.Context, _ domain.SearchCriteria) ([]*Portfolio, error) <span
                                class="cov0" title="0">{
        r.repo.mutex.RLock()
        defer r.repo.mutex.RUnlock()

        var result []*Portfolio
        for _, portfolio := range r.repo.data </span><span class="cov0" title="0">{
                result = append(result, portfolio)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// FindOne 검색 조건에 맞는 하나의 Portfolio를 조회합니다.
func (r *MemoryPortfolioRepository) FindOne(ctx context.Context, criteria domain.SearchCriteria) (*Portfolio, error) <span
                                class="cov0" title="0">{
        return r.repo.FindOne(ctx, criteria)
}</span>

// WithTransaction 트랜잭션을 실행합니다.
func (r *MemoryPortfolioRepository) WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error <span
                                class="cov0" title="0">{
        return r.repo.WithTransaction(ctx, fn)
}</span>
</pre>

                <pre class="file" id="file6" style="display: none">package asset

import (
        "fmt"
        "time"

        "github.com/aske/go_fi_chart/internal/domain/event"
        "github.com/google/uuid"
)

// Money 화폐 값을 나타냅니다.
type Money struct {
        Amount   float64
        Currency string
}

// NewMoney Money 값 객체를 생성합니다.
func NewMoney(amount float64, currency string) (Money, error) <span class="cov8" title="1">{
        if amount &lt; 0 </span><span class="cov8" title="1">{
                return Money{}, fmt.Errorf("금액은 음수가 될 수 없습니다: %f", amount)
        }</span>
        <span class="cov8" title="1">if currency == "" </span><span class="cov8" title="1">{
                return Money{}, fmt.Errorf("통화는 비어있을 수 없습니다")
        }</span>
        <span class="cov8" title="1">return Money{
                Amount:   amount,
                Currency: currency,
        }, nil</span>
}

// Add 두 Money 값을 더합니다.
func (m Money) Add(other Money) (Money, error) <span class="cov8" title="1">{
        if m.Currency != other.Currency </span><span class="cov8" title="1">{
                return Money{}, fmt.Errorf("통화가 일치하지 않습니다: %s != %s", m.Currency, other.Currency)
        }</span>
        <span class="cov8" title="1">return NewMoney(m.Amount+other.Amount, m.Currency)</span>
}

// Subtract 두 Money 값을 뺍니다.
func (m Money) Subtract(other Money) (Money, error) <span class="cov8" title="1">{
        if m.Currency != other.Currency </span><span class="cov8" title="1">{
                return Money{}, fmt.Errorf("통화가 일치하지 않습니다: %s != %s", m.Currency, other.Currency)
        }</span>
        <span class="cov8" title="1">result := m.Amount - other.Amount
        return NewMoney(result, m.Currency)</span>
}

// Multiply Money 값을 주어진 배수로 곱합니다.
func (m Money) Multiply(multiplier float64) (Money, error) <span class="cov8" title="1">{
        if multiplier &lt; 0 </span><span class="cov8" title="1">{
                return Money{}, fmt.Errorf("음수 배수는 사용할 수 없습니다: %f", multiplier)
        }</span>
        <span class="cov8" title="1">return NewMoney(m.Amount*multiplier, m.Currency)</span>
}

// Divide Money 값을 주어진 제수로 나눕니다.
func (m Money) Divide(divisor float64) (Money, error) <span class="cov8" title="1">{
        if divisor == 0 </span><span class="cov8" title="1">{
                return Money{}, fmt.Errorf("0으로 나눌 수 없습니다")
        }</span>
        <span class="cov8" title="1">if divisor &lt; 0 </span><span class="cov8" title="1">{
                return Money{}, fmt.Errorf("음수로 나눌 수 없습니다: %f", divisor)
        }</span>
        <span class="cov8" title="1">return NewMoney(m.Amount/divisor, m.Currency)</span>
}

// IsZero Money 값이 0인지 확인합니다.
func (m Money) IsZero() bool <span class="cov8" title="1">{
        return m.Amount == 0
}</span>

// IsNegative Money 값이 음수인지 확인합니다.
func (m Money) IsNegative() bool <span class="cov8" title="1">{
        return m.Amount &lt; 0
}</span>

// IsPositive Money 값이 양수인지 확인합니다.
func (m Money) IsPositive() bool <span class="cov8" title="1">{
        return m.Amount &gt; 0
}</span>

// Equals 두 Money 값이 같은지 확인합니다.
func (m Money) Equals(other Money) bool <span class="cov8" title="1">{
        return m.Amount == other.Amount &amp;&amp; m.Currency == other.Currency
}</span>

// GreaterThan 현재 Money 값이 다른 Money 값보다 큰지 확인합니다.
func (m Money) GreaterThan(other Money) (bool, error) <span class="cov8" title="1">{
        if m.Currency != other.Currency </span><span class="cov8" title="1">{
                return false, fmt.Errorf("통화가 일치하지 않습니다: %s != %s", m.Currency, other.Currency)
        }</span>
        <span class="cov8" title="1">return m.Amount &gt; other.Amount, nil</span>
}

// LessThan 현재 Money 값이 다른 Money 값보다 작은지 확인합니다.
func (m Money) LessThan(other Money) (bool, error) <span class="cov8" title="1">{
        if m.Currency != other.Currency </span><span class="cov8" title="1">{
                return false, fmt.Errorf("통화가 일치하지 않습니다: %s != %s", m.Currency, other.Currency)
        }</span>
        <span class="cov8" title="1">return m.Amount &lt; other.Amount, nil</span>
}

// String Money 값을 문자열로 변환합니다.
func (m Money) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%.2f %s", m.Amount, m.Currency)
}</span>

// Performance 자산의 성과를 나타냅니다.
type Performance struct {
        StartValue     Money
        CurrentValue   Money
        GrowthRate     float64
        RiskScore      float64
        LastUpdateTime time.Time
}

// Goal 재무 목표를 나타냅니다.
type Goal struct {
        ID        string
        Type      GoalType
        Target    Money
        Deadline  time.Time
        Progress  float64
        Rewards   []Reward
        CreatedAt time.Time
        UpdatedAt time.Time
}

// GoalType 목표의 유형을 나타냅니다.
type GoalType string

const (
        GoalTypeSaving    GoalType = "SAVING"
        GoalTypeInvesting GoalType = "INVESTING"
        GoalTypeDebtFree  GoalType = "DEBT_FREE"
)

// Achievement 업적을 나타냅니다.
type Achievement struct {
        ID         string
        Type       AchievementType
        Progress   float64
        Conditions []Condition
        Rewards    []Reward
        UnlockedAt *time.Time
        CreatedAt  time.Time
        UpdatedAt  time.Time
}

// AchievementType 업적의 유형을 나타냅니다.
type AchievementType string

const (
        AchievementTypeSaving    AchievementType = "SAVING_MASTER"
        AchievementTypeInvesting AchievementType = "INVESTING_GURU"
        AchievementTypeCommunity AchievementType = "COMMUNITY_STAR"
)

// Condition 업적 달성 조건을 나타냅니다.
type Condition struct {
        Type      ConditionType
        Target    interface{}
        Current   interface{}
        Completed bool
}

// ConditionType 조건의 유형을 나타냅니다.
type ConditionType string

const (
        ConditionTypeAmount      ConditionType = "AMOUNT"
        ConditionTypeDuration    ConditionType = "DURATION"
        ConditionTypeStreak      ConditionType = "STREAK"
        ConditionTypeInteraction ConditionType = "INTERACTION"
)

// Reward 보상을 나타냅니다.
type Reward struct {
        Type    RewardType
        Value   interface{}
        Claimed bool
        ClaimBy time.Time
}

// RewardType 보상의 유형을 나타냅니다.
type RewardType string

const (
        RewardTypeBadge   RewardType = "BADGE"
        RewardTypeTitle   RewardType = "TITLE"
        RewardTypeFeature RewardType = "FEATURE"
)

// Percentage 퍼센트 값을 나타냅니다.
type Percentage struct {
        Value float64
}

// NewPercentage Percentage 값 객체를 생성합니다.
func NewPercentage(value float64) (Percentage, error) <span class="cov8" title="1">{
        if value &lt; 0 || value &gt; 100 </span><span class="cov8" title="1">{
                return Percentage{}, fmt.Errorf("퍼센트 값은 0에서 100 사이여야 합니다: %f", value)
        }</span>
        <span class="cov8" title="1">return Percentage{Value: value}, nil</span>
}

// Add 두 Percentage 값을 더합니다.
func (p Percentage) Add(other Percentage) (Percentage, error) <span class="cov8" title="1">{
        sum := p.Value + other.Value
        return NewPercentage(sum)
}</span>

// Subtract 두 Percentage 값을 뺍니다.
func (p Percentage) Subtract(other Percentage) (Percentage, error) <span class="cov8" title="1">{
        diff := p.Value - other.Value
        return NewPercentage(diff)
}</span>

// Multiply Percentage 값을 주어진 배수로 곱합니다.
func (p Percentage) Multiply(multiplier float64) (Percentage, error) <span class="cov8" title="1">{
        result := p.Value * multiplier
        return NewPercentage(result)
}</span>

// IsZero Percentage 값이 0인지 확인합니다.
func (p Percentage) IsZero() bool <span class="cov8" title="1">{
        return p.Value == 0
}</span>

// IsComplete Percentage 값이 100%인지 확인합니다.
func (p Percentage) IsComplete() bool <span class="cov8" title="1">{
        return p.Value == 100
}</span>

// ToDecimal Percentage 값을 소수로 변환합니다.
func (p Percentage) ToDecimal() float64 <span class="cov8" title="1">{
        return p.Value / 100
}</span>

// FromDecimal 소수를 Percentage로 변환합니다.
func FromDecimal(decimal float64) (Percentage, error) <span class="cov8" title="1">{
        return NewPercentage(decimal * 100)
}</span>

// Asset 자산을 나타냅니다.
type Asset struct {
        ID           string
        UserID       string
        Type         Type
        Name         string
        Amount       Money
        Performance  *Performance
        Goals        []*Goal
        Achievements []*Achievement
        CreatedAt    time.Time
        UpdatedAt    time.Time
        events       []event.Event // 미발행 이벤트 저장
}

// GetID Entity 인터페이스 구현
func (a Asset) GetID() string <span class="cov8" title="1">{
        return a.ID
}</span>

// GetCreatedAt Entity 인터페이스 구현
func (a Asset) GetCreatedAt() time.Time <span class="cov8" title="1">{
        return a.CreatedAt
}</span>

// GetUpdatedAt Entity 인터페이스 구현
func (a Asset) GetUpdatedAt() time.Time <span class="cov8" title="1">{
        return a.UpdatedAt
}</span>

// Type 자산의 유형을 나타냅니다.
type Type string

const (
        Cash       Type = "CASH"
        Stock      Type = "STOCK"
        Bond       Type = "BOND"
        RealEstate Type = "REAL_ESTATE"
        Crypto     Type = "CRYPTO"
)

// NewAsset 새로운 자산을 생성합니다.
func NewAsset(userID string, assetType Type, name string, amount float64, currency string) (*Asset, error) <span
                                class="cov8" title="1">{
        money, err := NewMoney(amount, currency)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("자산 생성 실패: %w", err)
        }</span>

        <span class="cov8" title="1">now := time.Now()
        return &amp;Asset{
                ID:     generateID(),
                UserID: userID,
                Type:   assetType,
                Name:   name,
                Amount: money,
                Performance: &amp;Performance{
                        StartValue:     money,
                        CurrentValue:   money,
                        LastUpdateTime: now,
                },
                Goals:        make([]*Goal, 0),
                Achievements: make([]*Achievement, 0),
                CreatedAt:    now,
                UpdatedAt:    now,
        }, nil</span>
}

// AddGoal 자산에 새로운 목표를 추가합니다.
func (a *Asset) AddGoal(goalType GoalType, target Money, deadline time.Time) *Goal <span class="cov0" title="0">{
        now := time.Now()
        goal := &amp;Goal{
                ID:        generateID(),
                Type:      goalType,
                Target:    target,
                Deadline:  deadline,
                Progress:  0,
                Rewards:   make([]Reward, 0),
                CreatedAt: now,
                UpdatedAt: now,
        }
        a.Goals = append(a.Goals, goal)
        return goal
}</span>

// UpdateProgress 목표의 진행률을 업데이트합니다.
func (g *Goal) UpdateProgress(current Money) <span class="cov0" title="0">{
        g.Progress = (current.Amount / g.Target.Amount) * 100
        g.UpdatedAt = time.Now()
}</span>

// IsAchieved 목표가 달성되었는지 확인합니다.
func (g *Goal) IsAchieved() bool <span class="cov0" title="0">{
        return g.Progress &gt;= 100
}</span>

// AddAchievement 자산에 새로운 업적을 추가합니다.
func (a *Asset) AddAchievement(achievementType AchievementType, conditions []Condition) *Achievement <span class="cov0"
                                                                                                           title="0">{
        now := time.Now()
        achievement := &amp;Achievement{
                ID:         generateID(),
                Type:       achievementType,
                Progress:   0,
                Conditions: conditions,
                Rewards:    make([]Reward, 0),
                CreatedAt:  now,
                UpdatedAt:  now,
        }
        a.Achievements = append(a.Achievements, achievement)
        return achievement
}</span>

// UpdateAchievementProgress 업적의 진행률을 업데이트합니다.
func (a *Achievement) UpdateProgress() <span class="cov0" title="0">{
        var completed int
        for _, condition := range a.Conditions </span><span class="cov0" title="0">{
                if condition.Completed </span><span class="cov0" title="0">{
                        completed++
                }</span>
        }
        <span class="cov0" title="0">a.Progress = float64(completed) / float64(len(a.Conditions)) * 100

        if a.Progress &gt;= 100 &amp;&amp; a.UnlockedAt == nil </span><span class="cov0" title="0">{
                now := time.Now()
                a.UnlockedAt = &amp;now
        }</span>

        <span class="cov0" title="0">a.UpdatedAt = time.Now()</span>
}

// IsUnlocked 업적이 해금되었는지 확인합니다.
func (a *Achievement) IsUnlocked() bool <span class="cov0" title="0">{
        return a.UnlockedAt != nil
}</span>

// TransactionType 거래의 유형을 나타냅니다.
type TransactionType string

const (
        Income   TransactionType = "INCOME"
        Expense  TransactionType = "EXPENSE"
        Transfer TransactionType = "TRANSFER"
)

// Transaction 거래 내역을 나타냅니다.
type Transaction struct {
        ID          string
        AssetID     string
        Type        TransactionType
        Amount      Money
        Category    string
        Description string
        Date        time.Time
        CreatedAt   time.Time
}

// NewTransaction 새로운 Transaction 값 객체를 생성합니다.
func NewTransaction(assetID string, transactionType TransactionType, amount Money, category string, description string) (*Transaction, error) <span
                                class="cov8" title="1">{
        if amount.IsZero() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("거래 금액은 0이 될 수 없습니다")
        }</span>
        <span class="cov8" title="1">if amount.IsNegative() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("거래 금액은 음수가 될 수 없습니다")
        }</span>

        <span class="cov8" title="1">now := time.Now()
        return &amp;Transaction{
                ID:          uuid.New().String(),
                AssetID:     assetID,
                Type:        transactionType,
                Amount:      amount,
                Category:    category,
                Description: description,
                Date:        now,
                CreatedAt:   now,
        }, nil</span>
}

// GetID 거래의 ID를 반환합니다.
func (t *Transaction) GetID() string <span class="cov8" title="1">{
        return t.ID
}</span>

// GetAmount 거래 금액을 반환합니다.
func (t *Transaction) GetAmount() Money <span class="cov0" title="0">{
        return t.Amount
}</span>

// GetDate 거래 일자를 반환합니다.
func (t *Transaction) GetDate() time.Time <span class="cov0" title="0">{
        return t.Date
}</span>

// GetCreatedAt 거래 생성 일자를 반환합니다.
func (t *Transaction) GetCreatedAt() time.Time <span class="cov8" title="1">{
        return t.CreatedAt
}</span>

// GetUpdatedAt 거래의 업데이트 일자를 반환합니다.
func (t *Transaction) GetUpdatedAt() time.Time <span class="cov8" title="1">{
        return t.Date
}</span>

// Portfolio 포트폴리오를 나타냅니다.
type Portfolio struct {
        ID        string
        UserID    string
        Assets    []PortfolioAsset
        CreatedAt time.Time
        UpdatedAt time.Time
}

// GetID 포트폴리오의 ID를 반환합니다.
func (p *Portfolio) GetID() string <span class="cov8" title="1">{
        return p.ID
}</span>

// GetCreatedAt 포트폴리오의 생성 일자를 반환합니다.
func (p *Portfolio) GetCreatedAt() time.Time <span class="cov8" title="1">{
        return p.CreatedAt
}</span>

// GetUpdatedAt 포트폴리오의 업데이트 일자를 반환합니다.
func (p *Portfolio) GetUpdatedAt() time.Time <span class="cov8" title="1">{
        return p.UpdatedAt
}</span>

// PortfolioAsset 포트폴리오의 자산 구성을 나타냅니다.
type PortfolioAsset struct {
        AssetID string
        Weight  float64
}

func NewPortfolio(userID string, assets []PortfolioAsset) *Portfolio <span class="cov8" title="1">{
        now := time.Now()
        return &amp;Portfolio{
                ID:        generateID(),
                UserID:    userID,
                Assets:    assets,
                CreatedAt: now,
                UpdatedAt: now,
        }
}</span>

// AddEvent 이벤트를 추가합니다.
func (a *Asset) AddEvent(evt event.Event) <span class="cov0" title="0">{
        if a.events == nil </span><span class="cov0" title="0">{
                a.events = make([]event.Event, 0)
        }</span>
        <span class="cov0" title="0">a.events = append(a.events, evt)</span>
}

// GetUncommittedEvents 미발행 이벤트를 반환합니다.
func (a *Asset) GetUncommittedEvents() []event.Event <span class="cov0" title="0">{
        return a.events
}</span>

// ClearEvents 이벤트를 초기화합니다.
func (a *Asset) ClearEvents() <span class="cov0" title="0">{
        a.events = make([]event.Event, 0)
}</span>

// ProcessTransaction 거래를 처리합니다.
func (a *Asset) ProcessTransaction(tx *Transaction) error <span class="cov0" title="0">{
        if err := a.ValidateTransaction(tx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch tx.Type </span>{
        case Income:<span class="cov0" title="0">
                result, err := a.Amount.Add(tx.Amount)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">a.Amount = result</span>
        case Expense:<span class="cov0" title="0">
                result, err := a.Amount.Subtract(tx.Amount)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">a.Amount = result</span>
        case Transfer:<span class="cov0" title="0">
                result, err := a.Amount.Subtract(tx.Amount)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">a.Amount = result</span>
        }

        <span class="cov0" title="0">a.UpdatedAt = time.Now()

        // 거래 처리 이벤트 발행
        a.AddEvent(event.NewEvent(
                event.TypeTransactionRecorded,
                a.ID,
                "asset",
                map[string]interface{}{
                        "transactionID": tx.ID,
                        "type":          tx.Type,
                        "amount":        tx.Amount,
                },
                map[string]string{
                        "userID": a.UserID,
                },
                1,
        ))

        return nil</span>
}

// ValidateTransaction 거래가 유효한지 검증합니다.
func (a *Asset) ValidateTransaction(tx *Transaction) error <span class="cov0" title="0">{
        if tx.Amount.IsZero() </span><span class="cov0" title="0">{
                return fmt.Errorf("거래 금액은 0이 될 수 없습니다")
        }</span>

        <span class="cov0" title="0">if tx.Amount.IsNegative() </span><span class="cov0" title="0">{
                return fmt.Errorf("거래 금액은 음수가 될 수 없습니다")
        }</span>

        <span class="cov0" title="0">if tx.Type == Expense &amp;&amp; a.Amount.Amount &lt; tx.Amount.Amount </span><span
                                class="cov0" title="0">{
                return fmt.Errorf("잔액이 부족합니다")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// TimeRange 시간 범위를 나타냅니다.
type TimeRange struct {
        Start time.Time
        End   time.Time
}

// NewTimeRange TimeRange 값 객체를 생성합니다.
func NewTimeRange(start, end time.Time) (TimeRange, error) <span class="cov8" title="1">{
        if end.Before(start) </span><span class="cov8" title="1">{
                return TimeRange{}, fmt.Errorf("종료 시간은 시작 시간보다 이후여야 합니다: %v &gt; %v", start, end)
        }</span>
        <span class="cov8" title="1">return TimeRange{
                Start: start,
                End:   end,
        }, nil</span>
}

// Duration 기간을 반환합니다.
func (tr TimeRange) Duration() time.Duration <span class="cov8" title="1">{
        return tr.End.Sub(tr.Start)
}</span>

// Contains 주어진 시간이 범위 내에 있는지 확인합니다.
func (tr TimeRange) Contains(t time.Time) bool <span class="cov8" title="1">{
        return (t.Equal(tr.Start) || t.After(tr.Start)) &amp;&amp; (t.Equal(tr.End) || t.Before(tr.End))
}</span>

// Overlaps 다른 TimeRange와 겹치는지 확인합니다.
func (tr TimeRange) Overlaps(other TimeRange) bool <span class="cov8" title="1">{
        return tr.Contains(other.Start) || tr.Contains(other.End) ||
                other.Contains(tr.Start) || other.Contains(tr.End)
}</span>

// IsZero TimeRange가 zero value인지 확인합니다.
func (tr TimeRange) IsZero() bool <span class="cov0" title="0">{
        return tr.Start.IsZero() &amp;&amp; tr.End.IsZero()
}</span>

// Split TimeRange를 주어진 간격으로 분할합니다.
func (tr TimeRange) Split(interval time.Duration) []TimeRange <span class="cov8" title="1">{
        if interval &lt;= 0 </span><span class="cov8" title="1">{
                return []TimeRange{tr}
        }</span>

        <span class="cov8" title="1">var ranges []TimeRange
        current := tr.Start
        for current.Before(tr.End) </span><span class="cov8" title="1">{
                next := current.Add(interval)
                if next.After(tr.End) </span><span class="cov8" title="1">{
                        next = tr.End
                }</span>
                <span class="cov8" title="1">if r, err := NewTimeRange(current, next); err == nil </span><span
                                class="cov8" title="1">{
                        ranges = append(ranges, r)
                }</span>
                <span class="cov8" title="1">current = next</span>
        }
        <span class="cov8" title="1">return ranges</span>
}

// Extend TimeRange를 주어진 기간만큼 확장합니다.
func (tr TimeRange) Extend(d time.Duration) (TimeRange, error) <span class="cov8" title="1">{
        return NewTimeRange(tr.Start, tr.End.Add(d))
}</span>

// Shift TimeRange를 주어진 기간만큼 이동합니다.
func (tr TimeRange) Shift(d time.Duration) TimeRange <span class="cov8" title="1">{
        return TimeRange{
                Start: tr.Start.Add(d),
                End:   tr.End.Add(d),
        }
}</span>
</pre>

                <pre class="file" id="file7" style="display: none">package asset

import (
        "time"
)

// TestFixture 테스트에 사용할 데이터 세트
type TestFixture struct {
        assets       map[string]*Asset
        transactions map[string]*Transaction
        portfolios   map[string]*Portfolio
}

// NewTestFixture 새로운 테스트 픽스처를 생성합니다.
func NewTestFixture() *TestFixture <span class="cov8" title="1">{
        return &amp;TestFixture{
                assets:       make(map[string]*Asset),
                transactions: make(map[string]*Transaction),
                portfolios:   make(map[string]*Portfolio),
        }
}</span>

// GetAssetByID 테스트 픽스처에서 ID로 Asset을 찾습니다.
func (f *TestFixture) GetAssetByID(id string) *Asset <span class="cov8" title="1">{
        return f.assets[id]
}</span>

// GetTransactionByID 테스트 픽스처에서 ID로 Transaction을 찾습니다.
func (f *TestFixture) GetTransactionByID(id string) *Transaction <span class="cov8" title="1">{
        return f.transactions[id]
}</span>

// GetPortfolioByID 테스트 픽스처에서 ID로 Portfolio를 찾습니다.
func (f *TestFixture) GetPortfolioByID(id string) *Portfolio <span class="cov8" title="1">{
        return f.portfolios[id]
}</span>

// GetAssetsByUserID 테스트 픽스처에서 UserID로 Asset 목록을 찾습니다.
func (f *TestFixture) GetAssetsByUserID(userID string) []*Asset <span class="cov8" title="1">{
        var result []*Asset
        for _, asset := range f.assets </span><span class="cov8" title="1">{
                if asset.UserID == userID </span><span class="cov8" title="1">{
                        result = append(result, asset)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetTransactionsByAssetID 테스트 픽스처에서 AssetID로 Transaction 목록을 찾습니다.
func (f *TestFixture) GetTransactionsByAssetID(assetID string) []*Transaction <span class="cov8" title="1">{
        var result []*Transaction
        for _, tx := range f.transactions </span><span class="cov8" title="1">{
                if tx.AssetID == assetID </span><span class="cov8" title="1">{
                        result = append(result, tx)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetPortfolioByUserID 테스트 픽스처에서 UserID로 Portfolio를 찾습니다.
func (f *TestFixture) GetPortfolioByUserID(userID string) *Portfolio <span class="cov8" title="1">{
        for _, portfolio := range f.portfolios </span><span class="cov8" title="1">{
                if portfolio.UserID == userID </span><span class="cov8" title="1">{
                        return portfolio
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// CreateTestAsset 테스트용 자산을 생성합니다.
func CreateTestAsset() *Asset <span class="cov0" title="0">{
        money := NewTestMoney(500000, "KRW")
        asset := &amp;Asset{
                ID:        "test-asset-1",
                UserID:    "test-user-1",
                Type:      Stock,
                Name:      "삼성전자",
                Amount:    money,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }
        return asset
}</span>

// CreateTestTransaction 테스트용 거래 내역을 생성합니다.
func CreateTestTransaction() *Transaction <span class="cov0" title="0">{
        money := NewTestMoney(100000, "KRW")
        tx, _ := NewTransaction(
                "test-asset-1",
                Income,
                money,
                "급여",
                "2월 급여",
        )
        return tx
}</span>

// CreateTestPortfolio 테스트용 포트폴리오를 생성합니다.
func CreateTestPortfolio() *Portfolio <span class="cov0" title="0">{
        return &amp;Portfolio{
                ID:        "test-portfolio-1",
                UserID:    "test-user-1",
                Assets:    []PortfolioAsset{},
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }
}</span>

// NewTestMoney 테스트용 Money 값을 생성합니다.
func NewTestMoney(amount float64, currency string) Money <span class="cov8" title="1">{
        money, err := NewMoney(amount, currency)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return money</span>
}

// NewTestAsset 테스트용 자산을 생성합니다.
func NewTestAsset() *Asset <span class="cov0" title="0">{
        asset, err := NewAsset("test-user", Cash, "Test Asset", 1000000, "KRW")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return asset</span>
}

// NewTestTransaction 테스트용 거래를 생성합니다.
func NewTestTransaction() *Transaction <span class="cov8" title="1">{
        money := NewTestMoney(500000, "KRW")
        tx, err := NewTransaction("test-asset", Income, money, "Test", "Test Transaction")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return tx</span>
}

// NewTestPortfolio 테스트용 포트폴리오를 생성합니다.
func NewTestPortfolio() *Portfolio <span class="cov8" title="1">{
        return NewPortfolio("test-user", []PortfolioAsset{
                {
                        AssetID: "test-asset-1",
                        Weight:  0.6,
                },
                {
                        AssetID: "test-asset-2",
                        Weight:  0.4,
                },
        })
}</span>

// CreateFixture 테스트 데이터를 생성합니다.
func CreateFixture() *TestFixture <span class="cov8" title="1">{
        fixture := NewTestFixture()

        // 자산 생성
        asset1, err := NewAsset("user-1", Cash, "현금 자산", 1000000, "KRW")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">asset2, err := NewAsset("user-1", Stock, "주식 자산", 2000000, "KRW")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">fixture.assets[asset1.ID] = asset1
        fixture.assets[asset2.ID] = asset2

        // 거래 생성
        money1 := NewTestMoney(500000, "KRW")
        tx1, err := NewTransaction(asset1.ID, Income, money1, "급여", "2월 급여")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">money2 := NewTestMoney(300000, "KRW")
        tx2, err := NewTransaction(asset1.ID, Expense, money2, "식비", "2월 식비")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">money3 := NewTestMoney(200000, "KRW")
        tx3, err := NewTransaction(asset2.ID, Income, money3, "배당금", "2월 배당금")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">fixture.transactions[tx1.ID] = tx1
        fixture.transactions[tx2.ID] = tx2
        fixture.transactions[tx3.ID] = tx3

        // 포트폴리오 생성
        portfolio := NewPortfolio("user-1", []PortfolioAsset{
                {AssetID: asset1.ID, Weight: 0.6},
                {AssetID: asset2.ID, Weight: 0.4},
        })
        fixture.portfolios[portfolio.ID] = portfolio

        return fixture</span>
}
</pre>

                <pre class="file" id="file8" style="display: none">package domain

import "fmt"

// Error 도메인 에러 인터페이스입니다.
type Error interface {
        error
        // Code 에러 코드를 반환합니다.
        Code() string
        // Domain 에러가 발생한 도메인을 반환합니다.
        Domain() string
}

// BaseError 기본 도메인 에러 구현체입니다.
type BaseError struct {
        domain string
        code   string
        msg    string
}

// NewError 새로운 도메인 에러를 생성합니다.
func NewError(domain string, code string, msg string) Error <span class="cov0" title="0">{
        return &amp;BaseError{
                domain: domain,
                code:   code,
                msg:    msg,
        }
}</span>

func (e *BaseError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("[%s] %s: %s", e.domain, e.code, e.msg)
}</span>

func (e *BaseError) Code() string <span class="cov0" title="0">{
        return e.code
}</span>

func (e *BaseError) Domain() string <span class="cov0" title="0">{
        return e.domain
}</span>

// 자주 사용되는 에러 코드 상수
const (
        ErrCodeNotFound         = "NOT_FOUND"
        ErrCodeAlreadyExists    = "ALREADY_EXISTS"
        ErrCodeInvalidArgument  = "INVALID_ARGUMENT"
        ErrCodeInvalidOperation = "INVALID_OPERATION"
        ErrCodeNotImplemented   = "NOT_IMPLEMENTED"
        ErrCodeInternal         = "INTERNAL"
)
</pre>

                <pre class="file" id="file9" style="display: none">package event

import (
        "context"
        "time"
)

// Type 이벤트의 타입을 나타냅니다.
type Type string

// 시스템에서 사용되는 이벤트 타입 상수들
const (
        TypeAssetCreated        Type = "asset.created"
        TypeAssetUpdated        Type = "asset.updated"
        TypeAssetDeleted        Type = "asset.deleted"
        TypeTransactionRecorded Type = "transaction.recorded"
        TypePortfolioRebalanced Type = "portfolio.rebalanced"
        TypeMetricCollected     Type = "metric.collected"
        TypeAlertTriggered      Type = "alert.triggered"
)

// Event 도메인 이벤트 인터페이스
type Event interface {
        // EventType 이벤트의 타입을 반환합니다.
        EventType() Type
        // AggregateID 이벤트가 발생한 애그리게잇의 ID를 반환합니다.
        AggregateID() string
        // AggregateType 이벤트가 발생한 애그리게잇의 타입을 반환합니다.
        AggregateType() string
        // Payload 이벤트의 페이로드를 반환합니다.
        Payload() interface{}
        // Metadata 이벤트의 메타데이터를 반환합니다.
        Metadata() map[string]string
        // Timestamp 이벤트가 발생한 시간을 반환합니다.
        Timestamp() time.Time
        // Version 이벤트의 버전을 반환합니다.
        Version() int
}

// Handler 이벤트를 처리하는 핸들러 인터페이스
type Handler interface {
        // HandleEvent 이벤트를 처리합니다.
        HandleEvent(ctx context.Context, event Event) error
        // HandlerName 핸들러의 이름을 반환합니다.
        HandlerName() string
}

// Bus 이벤트 버스 인터페이스입니다.
type Bus interface {
        // Publish 이벤트를 발행합니다.
        Publish(ctx context.Context, event Event) error
        // Subscribe 이벤트 핸들러를 등록합니다.
        Subscribe(handler Handler) error
        // Unsubscribe 이벤트 핸들러를 제거합니다.
        Unsubscribe(handler Handler) error
}

// Store 이벤트를 저장하는 저장소 인터페이스
type Store interface {
        // Save 이벤트를 저장합니다.
        Save(ctx context.Context, events ...Event) error
        // Load 특정 애그리게잇의 이벤트들을 로드합니다.
        Load(ctx context.Context, aggregateID string) ([]Event, error)
}

// BaseEvent 기본 이벤트 구현체
type BaseEvent struct {
        eventType     Type
        aggregateID   string
        aggregateType string
        payload       interface{}
        metadata      map[string]string
        timestamp     time.Time
        version       int
}

// NewEvent 새로운 이벤트를 생성합니다.
func NewEvent(
        eventType Type,
        aggregateID string,
        aggregateType string,
        payload interface{},
        metadata map[string]string,
        version int,
) Event <span class="cov8" title="1">{
        return &amp;BaseEvent{
                eventType:     eventType,
                aggregateID:   aggregateID,
                aggregateType: aggregateType,
                payload:       payload,
                metadata:      metadata,
                timestamp:     time.Now(),
                version:       version,
        }
}</span>

func (e *BaseEvent) EventType() Type <span class="cov8" title="1">{
        return e.eventType
}</span>

func (e *BaseEvent) AggregateID() string <span class="cov8" title="1">{
        return e.aggregateID
}</span>

func (e *BaseEvent) AggregateType() string <span class="cov8" title="1">{
        return e.aggregateType
}</span>

func (e *BaseEvent) Payload() interface{} <span class="cov8" title="1">{
        return e.payload
}</span>

func (e *BaseEvent) Metadata() map[string]string <span class="cov8" title="1">{
        return e.metadata
}</span>

func (e *BaseEvent) Timestamp() time.Time <span class="cov8" title="1">{
        return e.timestamp
}</span>

func (e *BaseEvent) Version() int <span class="cov8" title="1">{
        return e.version
}</span>

// SimpleBus 기본 이벤트 버스 구현체
type SimpleBus struct {
        handlers []Handler
}

// NewSimpleBus 새로운 SimpleBus를 생성합니다.
func NewSimpleBus() *SimpleBus <span class="cov0" title="0">{
        return &amp;SimpleBus{
                handlers: make([]Handler, 0),
        }
}</span>
</pre>

                <pre class="file" id="file10" style="display: none">package gamification

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/aske/go_fi_chart/internal/domain"
)

// MemoryRepository 게임화 프로필의 인메모리 저장소 구현체입니다.
type MemoryRepository struct {
        data  map[string]*Profile
        mutex sync.RWMutex
}

// NewMemoryRepository 새로운 인메모리 저장소를 생성합니다.
func NewMemoryRepository() *MemoryRepository <span class="cov8" title="1">{
        return &amp;MemoryRepository{
                data: make(map[string]*Profile),
        }
}</span>

// Save 프로필을 저장합니다.
func (r *MemoryRepository) Save(_ context.Context, profile *Profile) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.data[profile.ID]; exists </span><span class="cov0" title="0">{
                return domain.NewError("gamification", domain.ErrCodeAlreadyExists, fmt.Sprintf("profile with ID %s already exists", profile.ID))
        }</span>

        <span class="cov8" title="1">r.data[profile.ID] = profile
        return nil</span>
}

// FindByID ID로 프로필을 조회합니다.
func (r *MemoryRepository) FindByID(_ context.Context, id string) (*Profile, error) <span class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        if profile, exists := r.data[id]; exists </span><span class="cov8" title="1">{
                return profile, nil
        }</span>

        <span class="cov8" title="1">return nil, domain.NewError("gamification", domain.ErrCodeNotFound, fmt.Sprintf("profile with ID %s not found", id))</span>
}

// Update 프로필을 업데이트합니다.
func (r *MemoryRepository) Update(_ context.Context, profile *Profile) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.data[profile.ID]; !exists </span><span class="cov0" title="0">{
                return domain.NewError("gamification", domain.ErrCodeNotFound, fmt.Sprintf("profile with ID %s not found", profile.ID))
        }</span>

        <span class="cov8" title="1">profile.UpdatedAt = time.Now()
        r.data[profile.ID] = profile
        return nil</span>
}

// Delete ID로 프로필을 삭제합니다.
func (r *MemoryRepository) Delete(_ context.Context, id string) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.data[id]; !exists </span><span class="cov0" title="0">{
                return domain.NewError("gamification", domain.ErrCodeNotFound, fmt.Sprintf("profile with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">delete(r.data, id)
        return nil</span>
}

// FindAll 검색 조건에 맞는 모든 프로필을 조회합니다.
func (r *MemoryRepository) FindAll(_ context.Context, _ domain.SearchCriteria) ([]*Profile, error) <span class="cov0"
                                                                                                         title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        profiles := make([]*Profile, 0, len(r.data))
        for _, profile := range r.data </span><span class="cov0" title="0">{
                profiles = append(profiles, profile)
        }</span>
        <span class="cov0" title="0">return profiles, nil</span>
}

// FindOne 검색 조건에 맞는 하나의 프로필을 조회합니다.
func (r *MemoryRepository) FindOne(_ context.Context, _ domain.SearchCriteria) (*Profile, error) <span class="cov0"
                                                                                                       title="0">{
        return nil, domain.NewError("gamification", domain.ErrCodeNotImplemented, "FindOne not implemented")
}</span>

// WithTransaction 트랜잭션을 실행합니다.
func (r *MemoryRepository) WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error <span
                                class="cov0" title="0">{
        return fn(ctx)
}</span>

// FindByUserID 사용자 ID로 프로필을 조회합니다.
func (r *MemoryRepository) FindByUserID(_ context.Context, userID string) (*Profile, error) <span class="cov8"
                                                                                                  title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        for _, profile := range r.data </span><span class="cov8" title="1">{
                if profile.UserID == userID </span><span class="cov8" title="1">{
                        return profile, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, domain.NewError("gamification", domain.ErrCodeNotFound, fmt.Sprintf("profile for user %s not found", userID))</span>
}

// UpdateExperience 사용자의 경험치를 업데이트합니다.
func (r *MemoryRepository) UpdateExperience(_ context.Context, id string, exp int) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        profile, exists := r.data[id]
        if !exists </span><span class="cov0" title="0">{
                return domain.NewError("gamification", domain.ErrCodeNotFound, fmt.Sprintf("profile with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">leveledUp := profile.AddExperience(exp)
        if leveledUp </span><span class="cov8" title="1">{
                profile.UpdatedAt = time.Now()
        }</span>

        <span class="cov8" title="1">r.data[id] = profile
        return nil</span>
}

// UpdateStats 사용자의 통계를 업데이트합니다.
func (r *MemoryRepository) UpdateStats(_ context.Context, id string, stats Statistics) error <span class="cov8"
                                                                                                   title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        profile, exists := r.data[id]
        if !exists </span><span class="cov0" title="0">{
                return domain.NewError("gamification", domain.ErrCodeNotFound, fmt.Sprintf("profile with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">profile.Stats = stats
        profile.UpdatedAt = time.Now()
        r.data[id] = profile
        return nil</span>
}

// AddBadge 사용자에게 뱃지를 추가합니다.
func (r *MemoryRepository) AddBadge(_ context.Context, id string, badge Badge) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        profile, exists := r.data[id]
        if !exists </span><span class="cov0" title="0">{
                return domain.NewError("gamification", domain.ErrCodeNotFound, fmt.Sprintf("profile with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">profile.Badges = append(profile.Badges, badge)
        profile.Stats.BadgesEarned++
        profile.UpdatedAt = time.Now()
        r.data[id] = profile
        return nil</span>
}

// UpdateStreak 사용자의 연속 달성을 업데이트합니다.
func (r *MemoryRepository) UpdateStreak(_ context.Context, id string, streakType StreakType) error <span class="cov8"
                                                                                                         title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        profile, exists := r.data[id]
        if !exists </span><span class="cov0" title="0">{
                return domain.NewError("gamification", domain.ErrCodeNotFound, fmt.Sprintf("profile with ID %s not found", id))
        }</span>

        <span class="cov8" title="1">profile.UpdateStreak(streakType)
        r.data[id] = profile
        return nil</span>
}
</pre>

                <pre class="file" id="file11" style="display: none">package gamification

import (
        "time"

        "github.com/aske/go_fi_chart/internal/domain"
)

// Level 사용자의 레벨을 나타냅니다.
type Level struct {
        Value       int
        Experience  int
        NextLevel   int
        Title       string
        UnlockedAt  time.Time
        Description string
}

// Profile 사용자의 게임화 프로필을 나타냅니다.
type Profile struct {
        ID           string
        UserID       string
        Level        Level
        Experience   int
        Achievements []string // Achievement IDs
        Badges       []Badge
        Streaks      []Streak
        Stats        Statistics
        CreatedAt    time.Time
        UpdatedAt    time.Time
}

func (p *Profile) GetID() string <span class="cov0" title="0">{
        return p.ID
}</span>

func (p *Profile) GetCreatedAt() time.Time <span class="cov0" title="0">{
        return p.CreatedAt
}</span>

func (p *Profile) GetUpdatedAt() time.Time <span class="cov0" title="0">{
        return p.UpdatedAt
}</span>

// Badge 사용자가 획득한 뱃지를 나타냅니다.
type Badge struct {
        ID          string
        Type        BadgeType
        Title       string
        Description string
        Tier        BadgeTier
        UnlockedAt  time.Time
}

// BadgeType 뱃지의 유형을 나타냅니다.
type BadgeType string

const (
        BadgeTypeSaving    BadgeType = "SAVING"
        BadgeTypeInvesting BadgeType = "INVESTING"
        BadgeTypeCommunity BadgeType = "COMMUNITY"
        BadgeTypeChallenge BadgeType = "CHALLENGE"
)

// BadgeTier 뱃지의 등급을 나타냅니다.
type BadgeTier string

const (
        BadgeTierBronze  BadgeTier = "BRONZE"
        BadgeTierSilver  BadgeTier = "SILVER"
        BadgeTierGold    BadgeTier = "GOLD"
        BadgeTierDiamond BadgeTier = "DIAMOND"
)

// Streak 연속 달성을 나타냅니다.
type Streak struct {
        Type        StreakType
        Count       int
        LastUpdated time.Time
        MaxCount    int
}

// StreakType 연속 달성의 유형을 나타냅니다.
type StreakType string

const (
        StreakTypeDaily   StreakType = "DAILY"
        StreakTypeWeekly  StreakType = "WEEKLY"
        StreakTypeMonthly StreakType = "MONTHLY"
)

// Statistics 사용자의 게임화 통계를 나타냅니다.
type Statistics struct {
        TotalSavings      float64
        TotalInvestments  float64
        GoalsCompleted    int
        BadgesEarned      int
        LongestStreak     int
        CommunityRanking  int
        ContributionScore float64
}

// NewProfile 새로운 게임화 프로필을 생성합니다.
func NewProfile(userID string) *Profile <span class="cov8" title="1">{
        now := time.Now()
        return &amp;Profile{
                ID:     domain.GenerateID(),
                UserID: userID,
                Level: Level{
                        Value:       1,
                        Experience:  0,
                        NextLevel:   100,
                        Title:       "초보 투자자",
                        UnlockedAt:  now,
                        Description: "자산 관리의 첫 걸음을 내딛었습니다.",
                },
                Experience:   0,
                Achievements: make([]string, 0),
                Badges:       make([]Badge, 0),
                Streaks:      make([]Streak, 0),
                Stats:        Statistics{},
                CreatedAt:    now,
                UpdatedAt:    now,
        }
}</span>

// AddExperience 경험치를 추가하고 레벨업 여부를 반환합니다.
func (p *Profile) AddExperience(exp int) bool <span class="cov8" title="1">{
        p.Experience += exp
        p.UpdatedAt = time.Now()

        leveledUp := false
        for p.Experience &gt;= p.Level.NextLevel </span><span class="cov8" title="1">{
                p.levelUp()
                leveledUp = true
        }</span>
        <span class="cov8" title="1">return leveledUp</span>
}

// levelUp 레벨을 올립니다.
func (p *Profile) levelUp() <span class="cov8" title="1">{
        p.Level.Value++
        p.Level.Experience = p.Experience
        p.Level.NextLevel = calculateNextLevelExp(p.Level.Value)
        p.Level.UnlockedAt = time.Now()
        p.updateLevelTitle()
}</span>

// calculateNextLevelExp 다음 레벨에 필요한 경험치를 계산합니다.
func calculateNextLevelExp(level int) int <span class="cov8" title="1">{
        return level * level * 100
}</span>

// updateLevelTitle 레벨에 따른 타이틀을 업데이트합니다.
func (p *Profile) updateLevelTitle() <span class="cov8" title="1">{
        switch </span>{
        case p.Level.Value &gt;= 50:<span class="cov8" title="1">
                p.Level.Title = "투자의 신"
                p.Level.Description = "최고 수준의 투자 전문가입니다."</span>
        case p.Level.Value &gt;= 40:<span class="cov8" title="1">
                p.Level.Title = "투자 마스터"
                p.Level.Description = "뛰어난 투자 실력을 보유하고 있습니다."</span>
        case p.Level.Value &gt;= 30:<span class="cov8" title="1">
                p.Level.Title = "숙련된 투자자"
                p.Level.Description = "안정적인 투자 능력을 보유하고 있습니다."</span>
        case p.Level.Value &gt;= 20:<span class="cov8" title="1">
                p.Level.Title = "중급 투자자"
                p.Level.Description = "투자의 기본을 완벽히 이해했습니다."</span>
        default:<span class="cov8" title="1">
                p.Level.Title = "초보 투자자"
                p.Level.Description = "투자의 기초를 배우고 있습니다."</span>
        }
}

// AddBadge 뱃지를 추가합니다.
func (p *Profile) AddBadge(badgeType BadgeType, tier BadgeTier, title, description string) <span class="cov8" title="1">{
        badge := Badge{
                ID:          domain.GenerateID(),
                Type:        badgeType,
                Title:       title,
                Description: description,
                Tier:        tier,
                UnlockedAt:  time.Now(),
        }
        p.Badges = append(p.Badges, badge)
        p.Stats.BadgesEarned++
        p.UpdatedAt = time.Now()
}</span>

// UpdateStreak 연속 달성을 업데이트합니다.
func (p *Profile) UpdateStreak(streakType StreakType) <span class="cov8" title="1">{
        now := time.Now()
        for i, streak := range p.Streaks </span><span class="cov8" title="1">{
                if streak.Type == streakType </span><span class="cov8" title="1">{
                        if now.Sub(streak.LastUpdated) &lt;= getStreakTimeout(streakType) </span><span class="cov8"
                                                                                                       title="1">{
                                p.Streaks[i].Count++
                                if p.Streaks[i].Count &gt; p.Streaks[i].MaxCount </span><span class="cov8" title="1">{
                                        p.Streaks[i].MaxCount = p.Streaks[i].Count
                                }</span>
                        } else<span class="cov8" title="1"> {
                                p.Streaks[i].Count = 1
                        }</span>
                        <span class="cov8" title="1">p.Streaks[i].LastUpdated = now
                        return</span>
                }
        }

        // 새로운 스트릭 추가
        <span class="cov8" title="1">p.Streaks = append(p.Streaks, Streak{
                Type:        streakType,
                Count:       1,
                LastUpdated: now,
                MaxCount:    1,
        })</span>
}

// getStreakTimeout 스트릭 타임아웃을 반환합니다.
func getStreakTimeout(streakType StreakType) time.Duration <span class="cov8" title="1">{
        switch streakType </span>{
        case StreakTypeDaily:<span class="cov8" title="1">
                return 24 * time.Hour</span>
        case StreakTypeWeekly:<span class="cov0" title="0">
                return 7 * 24 * time.Hour</span>
        case StreakTypeMonthly:<span class="cov0" title="0">
                return 30 * 24 * time.Hour</span>
        default:<span class="cov0" title="0">
                return 24 * time.Hour</span>
        }
}
</pre>

                <pre class="file" id="file12" style="display: none">package domain

import (
        "context"
        "time"
)

// Entity 모든 엔티티가 구현해야 하는 기본 인터페이스
type Entity interface {
        GetID() string
        GetCreatedAt() time.Time
        GetUpdatedAt() time.Time
}

// SearchCriteria 검색 조건 인터페이스
type SearchCriteria interface {
        ToQuery() (string, []interface{})
}

// Repository 기본 레포지토리 인터페이스
type Repository[T Entity, ID comparable] interface {
        // 기본 CRUD 작업
        Save(ctx context.Context, entity T) error
        FindByID(ctx context.Context, id ID) (T, error)
        Update(ctx context.Context, entity T) error
        Delete(ctx context.Context, id ID) error

        // 검색 작업
        FindAll(ctx context.Context, criteria SearchCriteria) ([]T, error)
        FindOne(ctx context.Context, criteria SearchCriteria) (T, error)

        // 트랜잭션 관리
        WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error
}

// RepositoryError 레포지토리 관련 에러 타입
type RepositoryError struct {
        Op  string // 작업 종류 (예: Save, FindByID 등)
        Err error  // 원본 에러
}

func (e *RepositoryError) Error() string <span class="cov0" title="0">{
        if e.Err == nil </span><span class="cov0" title="0">{
                return e.Op
        }</span>
        <span class="cov0" title="0">return e.Op + ": " + e.Err.Error()</span>
}

// NewRepositoryError 새로운 레포지토리 에러 생성
func NewRepositoryError(op string, err error) error <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Op:  op,
                Err: err,
        }
}</span>
</pre>

                <pre class="file" id="file13" style="display: none">package domain

import (
        "github.com/google/uuid"
)

// GenerateID UUID v4를 사용하여 고유한 ID를 생성합니다.
func GenerateID() string <span class="cov0" title="0">{
        return uuid.New().String()
}</span>
</pre>

                <pre class="file" id="file14" style="display: none">package memory

import (
        "context"
        "sync"

        "github.com/aske/go_fi_chart/internal/domain/event"
)

// EventBus 인메모리 이벤트 버스 구현체
type EventBus struct {
        handlers map[string][]event.Handler
        mu       sync.RWMutex
        closed   bool
}

// NewEventBus 새로운 인메모리 이벤트 버스를 생성합니다.
func NewEventBus() *EventBus <span class="cov8" title="1">{
        return &amp;EventBus{
                handlers: make(map[string][]event.Handler),
        }
}</span>

// Publish 이벤트를 발행합니다.
func (b *EventBus) Publish(ctx context.Context, evt event.Event) error <span class="cov8" title="1">{
        b.mu.RLock()
        defer b.mu.RUnlock()

        if b.closed </span><span class="cov8" title="1">{
                return event.ErrEventBusClosed
        }</span>

        // 모든 핸들러에게 이벤트 전달
        <span class="cov8" title="1">for _, handlers := range b.handlers </span><span class="cov8" title="1">{
                for _, handler := range handlers </span><span class="cov8" title="1">{
                        if err := handler.HandleEvent(ctx, evt); err != nil </span><span class="cov8" title="1">{
                                // 에러가 발생해도 다른 핸들러는 계속 실행
                                continue</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// Subscribe 이벤트 핸들러를 등록합니다.
func (b *EventBus) Subscribe(handler event.Handler) error <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()

        if b.closed </span><span class="cov8" title="1">{
                return event.ErrEventBusClosed
        }</span>

        <span class="cov8" title="1">handlerName := handler.HandlerName()
        b.handlers[handlerName] = append(b.handlers[handlerName], handler)
        return nil</span>
}

// Unsubscribe 이벤트 핸들러를 제거합니다.
func (b *EventBus) Unsubscribe(handler event.Handler) error <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()

        if b.closed </span><span class="cov8" title="1">{
                return event.ErrEventBusClosed
        }</span>

        <span class="cov8" title="1">handlerName := handler.HandlerName()
        handlers := b.handlers[handlerName]
        for i, h := range handlers </span><span class="cov8" title="1">{
                if h == handler </span><span class="cov8" title="1">{
                        b.handlers[handlerName] = append(handlers[:i], handlers[i+1:]...)
                        break</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// Close 이벤트 버스를 종료합니다.
func (b *EventBus) Close() error <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()

        b.closed = true
        b.handlers = nil
        return nil
}</span>
</pre>

                <pre class="file" id="file15" style="display: none">package memory

import (
        "context"
        "sync"

        "github.com/aske/go_fi_chart/internal/domain/event"
)

// EventStore 인메모리 이벤트 저장소 구현체
type EventStore struct {
        events map[string][]event.Event
        mu     sync.RWMutex
}

// NewEventStore 새로운 인메모리 이벤트 저장소를 생성합니다.
func NewEventStore() *EventStore <span class="cov8" title="1">{
        return &amp;EventStore{
                events: make(map[string][]event.Event),
        }
}</span>

// Save 이벤트를 저장합니다.
func (s *EventStore) Save(_ context.Context, events ...event.Event) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        for _, evt := range events </span><span class="cov8" title="1">{
                aggregateID := evt.AggregateID()
                s.events[aggregateID] = append(s.events[aggregateID], evt)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Load 특정 애그리게잇의 이벤트들을 로드합니다.
func (s *EventStore) Load(_ context.Context, aggregateID string) ([]event.Event, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        events, exists := s.events[aggregateID]
        if !exists </span><span class="cov8" title="1">{
                return []event.Event{}, nil
        }</span>

        <span class="cov8" title="1">result := make([]event.Event, len(events))
        copy(result, events)
        return result, nil</span>
}

// Clear 모든 이벤트를 삭제합니다.
func (s *EventStore) Clear() <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.events = make(map[string][]event.Event)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
