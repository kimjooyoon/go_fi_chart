
<!DOCTYPE html>
<html>
<head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>alerts: Go Coverage Report</title>
        <style>
                body {
                        background: black;
                        color: rgb(80, 80, 80);
                }

                body, pre, #legend span {
                        font-family: Menlo, monospace;
                        font-weight: bold;
                }

                #topbar {
                        background: black;
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        height: 42px;
                        border-bottom: 1px solid rgb(80, 80, 80);
                }

                #content {
                        margin-top: 50px;
                }

                #nav, #legend {
                        float: left;
                        margin-left: 10px;
                }

                #legend {
                        margin-top: 12px;
                }

                #nav {
                        margin-top: 10px;
                }

                #legend span {
                        margin: 0 5px;
                }

                .cov0 {
                        color: rgb(192, 0, 0)
                }

                .cov1 {
                        color: rgb(128, 128, 128)
                }

                .cov2 {
                        color: rgb(116, 140, 131)
                }

                .cov3 {
                        color: rgb(104, 152, 134)
                }

                .cov4 {
                        color: rgb(92, 164, 137)
                }

                .cov5 {
                        color: rgb(80, 176, 140)
                }

                .cov6 {
                        color: rgb(68, 188, 143)
                }

                .cov7 {
                        color: rgb(56, 200, 146)
                }

                .cov8 {
                        color: rgb(44, 212, 149)
                }

                .cov9 {
                        color: rgb(32, 224, 152)
                }

                .cov10 {
                        color: rgb(20, 236, 155)
                }

        </style>
</head>
<body>
<div id="topbar">
        <div id="nav">
                <select id="files">

                        <option value="file0">github.com/aske/go_fi_chart/services/monitoring/internal/alerts/alert.go
                                (89.5%)
                        </option>

                        <option value="file1">github.com/aske/go_fi_chart/services/monitoring/internal/domain/types.go
                                (0.0%)
                        </option>

                        <option value="file2">
                                github.com/aske/go_fi_chart/services/monitoring/internal/exporters/prometheus/exporter.go
                                (93.5%)
                        </option>

                        <option value="file3">
                                github.com/aske/go_fi_chart/services/monitoring/internal/github/collector.go (0.0%)
                        </option>

                        <option value="file4">github.com/aske/go_fi_chart/services/monitoring/internal/github/types.go
                                (0.0%)
                        </option>

                        <option value="file5">
                                github.com/aske/go_fi_chart/services/monitoring/internal/metrics/collector.go (100.0%)
                        </option>

                        <option value="file6">
                                github.com/aske/go_fi_chart/services/monitoring/internal/metrics/github/collector.go
                                (84.0%)
                        </option>

                        <option value="file7">
                                github.com/aske/go_fi_chart/services/monitoring/internal/metrics/github/model.go
                                (100.0%)
                        </option>

                        <option value="file8">
                                github.com/aske/go_fi_chart/services/monitoring/internal/metrics/simple/metric.go (0.0%)
                        </option>

                        <option value="file9">github.com/aske/go_fi_chart/services/monitoring/internal/metrics/types.go
                                (0.0%)
                        </option>

                        <option value="file10">
                                github.com/aske/go_fi_chart/services/monitoring/metrics/collectors/base.go (93.8%)
                        </option>

                        <option value="file11">
                                github.com/aske/go_fi_chart/services/monitoring/metrics/collectors/simple.go (100.0%)
                        </option>

                        <option value="file12">github.com/aske/go_fi_chart/services/monitoring/metrics/domain/metric.go
                                (100.0%)
                        </option>

                        <option value="file13">github.com/aske/go_fi_chart/services/monitoring/metrics/domain/types.go
                                (100.0%)
                        </option>

                        <option value="file14">github.com/aske/go_fi_chart/services/monitoring/pkg/domain/types.go
                                (0.0%)
                        </option>

                        <option value="file15">github.com/aske/go_fi_chart/services/monitoring/pkg/health/checker.go
                                (100.0%)
                        </option>

                </select>
        </div>
        <div id="legend">
                <span>not tracked</span>

                <span class="cov0">not covered</span>
                <span class="cov8">covered</span>

        </div>
</div>
<div id="content">
		
		<pre class="file" id="file0" style="display: none">package alerts

import (
        "context"
        "sync"

        "github.com/aske/go_fi_chart/services/monitoring/pkg/domain"
)

// AlertLevel 알림의 심각도를 나타냅니다.
type AlertLevel = domain.AlertLevel

const (
        LevelInfo     = domain.LevelInfo
        LevelWarning  = domain.LevelWarning
        LevelError    = domain.LevelError
        LevelCritical = domain.LevelCritical
)

// Alert 모니터링 시스템의 알림을 나타냅니다.
type Alert = domain.Alert

// Notifier 알림을 처리하는 인터페이스입니다.
type Notifier interface {
        Notify(ctx context.Context, alert Alert) error
}

// SimpleNotifier 기본적인 알림 처리자 구현체입니다.
type SimpleNotifier struct {
        mu        sync.RWMutex
        publisher domain.Publisher
        handlers  []Notifier
}

// NewSimpleNotifier 새로운 SimpleNotifier를 생성합니다.
func NewSimpleNotifier(publisher domain.Publisher) *SimpleNotifier <span class="cov8" title="1">{
        return &amp;SimpleNotifier{
                publisher: publisher,
                handlers:  make([]Notifier, 0),
        }
}</span>

// AddHandler 알림 핸들러를 추가합니다.
func (n *SimpleNotifier) AddHandler(handler Notifier) <span class="cov8" title="1">{
        n.mu.Lock()
        defer n.mu.Unlock()
        n.handlers = append(n.handlers, handler)
}</span>

// RemoveHandler 알림 핸들러를 제거합니다.
func (n *SimpleNotifier) RemoveHandler(handler Notifier) <span class="cov8" title="1">{
        n.mu.Lock()
        defer n.mu.Unlock()
        for i, h := range n.handlers </span><span class="cov8" title="1">{
                if h == handler </span><span class="cov8" title="1">{
                        n.handlers = append(n.handlers[:i], n.handlers[i+1:]...)
                        break</span>
                }
        }
}

// Notify 알림을 처리하고 이벤트를 발행합니다.
func (n *SimpleNotifier) Notify(ctx context.Context, alert Alert) error <span class="cov8" title="1">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        // 모든 핸들러에게 알림 전달
        for _, handler := range n.handlers </span><span class="cov8" title="1">{
                if err := handler.Notify(ctx, alert); err != nil </span><span class="cov0" title="0">{
                        // 에러가 발생해도 다른 핸들러는 계속 실행
                        continue</span>
                }
        }

        // 알림 이벤트 발행
        <span class="cov8" title="1">evt := domain.NewMonitoringEvent(domain.TypeAlertTriggered, alert)
        if err := n.publisher.Publish(ctx, evt); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>

        <pre class="file" id="file1" style="display: none">package domain

import "time"

// EventType 이벤트 타입입니다.
type EventType string

const (
        TypeMetricCollected EventType = "metric_collected"
        TypeAlertTriggered  EventType = "alert_triggered"
)

// Event 모니터링 이벤트입니다.
type Event struct {
        Type      EventType
        Timestamp time.Time
        Data      interface{}
}

// NewMonitoringEvent 새로운 모니터링 이벤트를 생성합니다.
func NewMonitoringEvent(eventType EventType, data interface{}) Event <span class="cov0" title="0">{
        return Event{
                Type:      eventType,
                Timestamp: time.Now(),
                Data:      data,
        }
}</span>

// Handler 이벤트 핸들러 인터페이스입니다.
type Handler interface {
        Handle(event Event) error
}

// Publisher 이벤트 발행자 인터페이스입니다.
type Publisher interface {
        Publish(event Event) error
}
</pre>

        <pre class="file" id="file2" style="display: none">package prometheus

import (
        "context"
        "fmt"
        "sync"

        "github.com/aske/go_fi_chart/services/monitoring/metrics/domain"
        "github.com/prometheus/client_golang/prometheus"
)

// Exporter Prometheus 익스포터 구현체입니다.
type Exporter struct {
        mu       sync.RWMutex
        registry *prometheus.Registry
        metrics  map[string]prometheus.Collector
}

// NewExporter 새로운 Exporter를 생성합니다.
func NewExporter() *Exporter <span class="cov8" title="1">{
        return &amp;Exporter{
                registry: prometheus.NewRegistry(),
                metrics:  make(map[string]prometheus.Collector),
        }
}</span>

// Export 메트릭을 Prometheus 형식으로 변환하여 등록합니다.
func (e *Exporter) Export(_ context.Context, metrics []domain.Metric) error <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()

        for _, m := range metrics </span><span class="cov8" title="1">{
                collector, err := e.getOrCreateCollector(m)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("메트릭 컬렉터 생성 실패: %w", err)
                }</span>

                <span class="cov8" title="1">switch m.Type() </span>{
                case "counter":<span class="cov8" title="1">
                        if counter, ok := collector.(prometheus.Counter); ok </span><span class="cov8" title="1">{
                                counter.Add(m.Value().Raw)
                        }</span>
                case "gauge":<span class="cov8" title="1">
                        if gauge, ok := collector.(prometheus.Gauge); ok </span><span class="cov8" title="1">{
                                gauge.Set(m.Value().Raw)
                        }</span>
                case "histogram":<span class="cov8" title="1">
                        if histogram, ok := collector.(prometheus.Histogram); ok </span><span class="cov8" title="1">{
                                histogram.Observe(m.Value().Raw)
                        }</span>
                case "summary":<span class="cov8" title="1">
                        if summary, ok := collector.(prometheus.Summary); ok </span><span class="cov8" title="1">{
                                summary.Observe(m.Value().Raw)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// GetRegistry Prometheus 레지스트리를 반환합니다.
func (e *Exporter) GetRegistry() *prometheus.Registry <span class="cov0" title="0">{
        return e.registry
}</span>

// getOrCreateCollector 메트릭에 대한 Prometheus 컬렉터를 반환하거나 생성합니다.
func (e *Exporter) getOrCreateCollector(m domain.Metric) (prometheus.Collector, error) <span class="cov8" title="1">{
        if collector, exists := e.metrics[m.Name()]; exists </span><span class="cov8" title="1">{
                return collector, nil
        }</span>

        <span class="cov8" title="1">var collector prometheus.Collector

        switch m.Type() </span>{
        case "counter":<span class="cov8" title="1">
                collector = prometheus.NewCounter(prometheus.CounterOpts{
                        Name: m.Name(),
                        Help: m.Description(),
                })</span>
        case "gauge":<span class="cov8" title="1">
                collector = prometheus.NewGauge(prometheus.GaugeOpts{
                        Name: m.Name(),
                        Help: m.Description(),
                })</span>
        case "histogram":<span class="cov8" title="1">
                collector = prometheus.NewHistogram(prometheus.HistogramOpts{
                        Name: m.Name(),
                        Help: m.Description(),
                })</span>
        case "summary":<span class="cov8" title="1">
                collector = prometheus.NewSummary(prometheus.SummaryOpts{
                        Name: m.Name(),
                        Help: m.Description(),
                })</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("지원하지 않는 메트릭 타입: %s", m.Type())</span>
        }

        <span class="cov8" title="1">if err := e.registry.Register(collector); err != nil </span><span class="cov0"
                                                                                                       title="0">{
                return nil, fmt.Errorf("메트릭 등록 실패: %w", err)
        }</span>

        <span class="cov8" title="1">e.metrics[m.Name()] = collector
        return collector, nil</span>
}
</pre>

        <pre class="file" id="file3" style="display: none">package github

import (
        "context"
        "sync"

        "github.com/aske/go_fi_chart/services/monitoring/metrics/domain"
        pkgdomain "github.com/aske/go_fi_chart/services/monitoring/pkg/domain"
)

// Collector GitHub 메트릭 수집기입니다.
type Collector struct {
        metrics   []domain.Metric
        publisher pkgdomain.Publisher
        mu        sync.RWMutex
}

// NewCollector 새로운 GitHub 메트릭 수집기를 생성합니다.
func NewCollector(publisher pkgdomain.Publisher) *Collector <span class="cov0" title="0">{
        return &amp;Collector{
                publisher: publisher,
        }
}</span>

// Add 메트릭을 추가합니다.
func (c *Collector) Add(metric domain.Metric) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.metrics = append(c.metrics, metric)
}</span>

// Collect 메트릭을 수집하고 이벤트를 발행합니다.
func (c *Collector) Collect(ctx context.Context) ([]domain.Metric, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        result := make([]domain.Metric, len(c.metrics))
        copy(result, c.metrics)

        for _, metric := range c.metrics </span><span class="cov0" title="0">{
                event := pkgdomain.NewMonitoringEvent(pkgdomain.TypeMetricCollected, metric)
                if err := c.publisher.Publish(ctx, event); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">c.metrics = make([]domain.Metric, 0)
        return result, nil</span>
}

// Metrics 수집된 메트릭 목록을 반환합니다.
func (c *Collector) Metrics() []domain.Metric <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        result := make([]domain.Metric, len(c.metrics))
        copy(result, c.metrics)
        return result
}</span>
</pre>

        <pre class="file" id="file4" style="display: none">package github

import (
        "time"

        "github.com/aske/go_fi_chart/services/monitoring/metrics/domain"
)

// ActionStatus GitHub 액션의 상태입니다.
type ActionStatus string

const (
        ActionStatusSuccess    ActionStatus = "success"
        ActionStatusFailure    ActionStatus = "failure"
        ActionStatusInProgress ActionStatus = "in_progress"
)

// ActionMetric GitHub Actions 실행 메트릭을 나타냅니다.
type ActionMetric struct {
        WorkflowName string
        Status       ActionStatus
        Duration     time.Duration
        StartedAt    time.Time
        FinishedAt   time.Time
}

// NewActionMetric 새로운 액션 메트릭을 생성합니다.
func NewActionMetric(name string, status ActionStatus, duration time.Duration) ActionMetric <span class="cov0"
                                                                                                  title="0">{
        now := time.Now()
        return ActionMetric{
                WorkflowName: name,
                Status:       status,
                Duration:     duration,
                StartedAt:    now.Add(-duration),
                FinishedAt:   now,
        }
}</span>

// ToMetric 액션 메트릭을 일반 메트릭으로 변환합니다.
func (m ActionMetric) ToMetric() domain.Metric <span class="cov0" title="0">{
        var value float64
        switch m.Status </span>{
        case ActionStatusSuccess:<span class="cov0" title="0">
                value = 1</span>
        case ActionStatusFailure:<span class="cov0" title="0">
                value = 0</span>
        case ActionStatusInProgress:<span class="cov0" title="0">
                value = 2</span>
        default:<span class="cov0" title="0">
                value = -1</span>
        }

        <span class="cov0" title="0">return domain.NewBaseMetric(
                m.WorkflowName,
                domain.TypeGauge,
                domain.NewValue(value, map[string]string{
                        "status": string(m.Status),
                }),
                "GitHub 액션 실행 상태",
        )</span>
}

// ToDurationMetric 액션 실행 시간 메트릭을 생성합니다.
func (m ActionMetric) ToDurationMetric() domain.Metric <span class="cov0" title="0">{
        return domain.NewBaseMetric(
                m.WorkflowName+"_duration",
                domain.TypeGauge,
                domain.NewValue(m.Duration.Seconds(), map[string]string{
                        "action": m.WorkflowName,
                }),
                "GitHub 액션 실행 시간 (초)",
        )
}</span>
</pre>

        <pre class="file" id="file5" style="display: none">package metrics

import (
        "context"

        "github.com/aske/go_fi_chart/services/monitoring/metrics/collectors"
        "github.com/aske/go_fi_chart/services/monitoring/metrics/domain"
        pkgdomain "github.com/aske/go_fi_chart/services/monitoring/pkg/domain"
)

// DomainPublisherAdapter pkg/domain.Publisher를 metrics/domain.Publisher로 변환합니다.
type DomainPublisherAdapter struct {
        publisher pkgdomain.Publisher
}

// NewDomainPublisherAdapter 새로운 DomainPublisherAdapter를 생성합니다.
func NewDomainPublisherAdapter(publisher pkgdomain.Publisher) *DomainPublisherAdapter <span class="cov8" title="1">{
        return &amp;DomainPublisherAdapter{
                publisher: publisher,
        }
}</span>

// Publish 메트릭 이벤트를 발행합니다.
func (a *DomainPublisherAdapter) Publish(ctx context.Context, metrics []domain.Metric) error <span class="cov8"
                                                                                                   title="1">{
        event := pkgdomain.NewMonitoringEvent(pkgdomain.TypeMetricCollected, metrics)
        return a.publisher.Publish(ctx, event)
}</span>

// SimpleCollector 기본적인 메트릭 수집기 구현체입니다.
type SimpleCollector struct {
        *collectors.BaseCollector
}

// NewSimpleCollector 새로운 SimpleCollector를 생성합니다.
func NewSimpleCollector(publisher pkgdomain.Publisher) *SimpleCollector <span class="cov8" title="1">{
        adapter := NewDomainPublisherAdapter(publisher)
        return &amp;SimpleCollector{
                BaseCollector: collectors.NewBaseCollector(adapter),
        }
}</span>
</pre>

        <pre class="file" id="file6" style="display: none">package github

import (
        "context"
        "sync"
        "time"

        "github.com/aske/go_fi_chart/services/monitoring/metrics/domain"
        pkgdomain "github.com/aske/go_fi_chart/services/monitoring/pkg/domain"
)

// Collector GitHub 메트릭을 수집하는 컬렉터입니다.
type Collector struct {
        mu        sync.RWMutex
        metrics   []domain.Metric
        publisher pkgdomain.Publisher
}

// NewCollector 새로운 GitHub 메트릭 컬렉터를 생성합니다.
func NewCollector(publisher pkgdomain.Publisher) *Collector <span class="cov8" title="1">{
        return &amp;Collector{
                metrics:   make([]domain.Metric, 0),
                publisher: publisher,
        }
}</span>

// AddActionStatusMetric GitHub 액션 상태 메트릭을 추가합니다.
func (c *Collector) AddActionStatusMetric(name string, status ActionStatus) error <span class="cov8" title="1">{
        metric := NewActionMetric(name, status, 0)
        c.mu.Lock()
        defer c.mu.Unlock()
        c.metrics = append(c.metrics, metric.ToMetric())
        return nil
}</span>

// AddActionDurationMetric GitHub 액션 실행 시간 메트릭을 추가합니다.
func (c *Collector) AddActionDurationMetric(name string, duration time.Duration) error <span class="cov8" title="1">{
        metric := NewActionMetric(name, ActionStatusSuccess, duration)
        c.mu.Lock()
        defer c.mu.Unlock()
        c.metrics = append(c.metrics, metric.ToMetric())
        if metric.Duration &gt; 0 </span><span class="cov8" title="1">{
                c.metrics = append(c.metrics, metric.ToDurationMetric())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Collect 수집된 메트릭을 반환하고 이벤트를 발행합니다.
func (c *Collector) Collect(ctx context.Context) ([]domain.Metric, error) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        metrics := make([]domain.Metric, len(c.metrics))
        copy(metrics, c.metrics)

        evt := pkgdomain.NewMonitoringEvent(pkgdomain.TypeMetricCollected, metrics)
        if err := c.publisher.Publish(ctx, evt); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">c.metrics = make([]domain.Metric, 0)
        return metrics, nil</span>
}

// Reset 수집된 메트릭을 초기화합니다.
func (c *Collector) Reset() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.metrics = make([]domain.Metric, 0)
}</span>
</pre>

        <pre class="file" id="file7" style="display: none">package github

import (
        "time"

        "github.com/aske/go_fi_chart/services/monitoring/metrics/domain"
)

// ActionStatus GitHub 액션의 상태를 나타냅니다.
type ActionStatus string

const (
        ActionStatusSuccess    ActionStatus = "success"
        ActionStatusFailure    ActionStatus = "failure"
        ActionStatusInProgress ActionStatus = "in_progress"
)

// ActionMetric GitHub Actions 실행 메트릭을 나타냅니다.
type ActionMetric struct {
        WorkflowName string
        Status       ActionStatus
        Duration     time.Duration
        StartedAt    time.Time
        FinishedAt   time.Time
}

// NewActionMetric 새로운 액션 메트릭을 생성합니다.
func NewActionMetric(name string, status ActionStatus, duration time.Duration) ActionMetric <span class="cov8"
                                                                                                  title="1">{
        now := time.Now()
        return ActionMetric{
                WorkflowName: name,
                Status:       status,
                Duration:     duration,
                StartedAt:    now.Add(-duration),
                FinishedAt:   now,
        }
}</span>

// ToMetric 액션 메트릭을 일반 메트릭으로 변환합니다.
func (m ActionMetric) ToMetric() domain.Metric <span class="cov8" title="1">{
        var value float64
        switch m.Status </span>{
        case ActionStatusSuccess:<span class="cov8" title="1">
                value = 1</span>
        case ActionStatusFailure:<span class="cov8" title="1">
                value = 0</span>
        case ActionStatusInProgress:<span class="cov8" title="1">
                value = 2</span>
        default:<span class="cov8" title="1">
                value = -1</span>
        }

        <span class="cov8" title="1">return domain.NewBaseMetric(
                m.WorkflowName,
                domain.TypeGauge,
                domain.NewValue(value, map[string]string{
                        "status": string(m.Status),
                }),
                "GitHub 액션 실행 상태",
        )</span>
}

// ToDurationMetric 액션 실행 시간 메트릭을 생성합니다.
func (m ActionMetric) ToDurationMetric() domain.Metric <span class="cov8" title="1">{
        return domain.NewBaseMetric(
                m.WorkflowName+"_duration",
                domain.TypeGauge,
                domain.NewValue(m.Duration.Seconds(), map[string]string{
                        "action": m.WorkflowName,
                }),
                "GitHub 액션 실행 시간 (초)",
        )
}</span>
</pre>

        <pre class="file" id="file8" style="display: none">package simple

import (
        "github.com/aske/go_fi_chart/services/monitoring/internal/metrics"
)

// Metric 기본 메트릭 구현체입니다.
type Metric struct {
        name        string
        metricType  metrics.Type
        value       metrics.Value
        description string
}

// NewMetric 새로운 메트릭을 생성합니다.
func NewMetric(name string, metricType metrics.Type, value float64, description string) *Metric <span class="cov0"
                                                                                                      title="0">{
        return &amp;Metric{
                name:        name,
                metricType:  metricType,
                value:       metrics.NewValue(value, nil),
                description: description,
        }
}</span>

// Name 메트릭의 이름을 반환합니다.
func (m *Metric) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

// Type 메트릭의 타입을 반환합니다.
func (m *Metric) Type() metrics.Type <span class="cov0" title="0">{
        return m.metricType
}</span>

// Value 메트릭의 값을 반환합니다.
func (m *Metric) Value() metrics.Value <span class="cov0" title="0">{
        return m.value
}</span>

// Description 메트릭의 설명을 반환합니다.
func (m *Metric) Description() string <span class="cov0" title="0">{
        return m.description
}</span>

// WithLabels 레이블이 추가된 새로운 메트릭을 반환합니다.
func (m *Metric) WithLabels(labels map[string]string) *Metric <span class="cov0" title="0">{
        return &amp;Metric{
                name:        m.name,
                metricType:  m.metricType,
                value:       m.value.WithLabels(labels),
                description: m.description,
        }
}</span>
</pre>

        <pre class="file" id="file9" style="display: none">package metrics

import (
        "context"
        "time"
)

// Type 메트릭의 타입을 나타냅니다.
type Type string

const (
        TypeCounter   Type = "counter"
        TypeGauge     Type = "gauge"
        TypeHistogram Type = "histogram"
        TypeSummary   Type = "summary"
)

// Value 메트릭의 값을 나타냅니다.
type Value struct {
        Raw       float64           `json:"raw"`
        Labels    map[string]string `json:"labels,omitempty"`
        Timestamp time.Time         `json:"timestamp"`
}

// NewValue 새로운 메트릭 값을 생성합니다.
func NewValue(raw float64, labels map[string]string) Value <span class="cov0" title="0">{
        return Value{
                Raw:       raw,
                Labels:    labels,
                Timestamp: time.Now(),
        }
}</span>

// WithLabel 레이블을 추가한 새로운 Value를 반환합니다.
func (v Value) WithLabel(key, value string) Value <span class="cov0" title="0">{
        newLabels := make(map[string]string, len(v.Labels)+1)
        for k, v := range v.Labels </span><span class="cov0" title="0">{
                newLabels[k] = v
        }</span>
        <span class="cov0" title="0">newLabels[key] = value
        return Value{
                Raw:       v.Raw,
                Labels:    newLabels,
                Timestamp: v.Timestamp,
        }</span>
}

// WithLabels 여러 레이블을 추가한 새로운 Value를 반환합니다.
func (v Value) WithLabels(labels map[string]string) Value <span class="cov0" title="0">{
        newLabels := make(map[string]string, len(v.Labels)+len(labels))
        for k, v := range v.Labels </span><span class="cov0" title="0">{
                newLabels[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range labels </span><span class="cov0" title="0">{
                newLabels[k] = v
        }</span>
        <span class="cov0" title="0">return Value{
                Raw:       v.Raw,
                Labels:    newLabels,
                Timestamp: v.Timestamp,
        }</span>
}

// Metric 메트릭 인터페이스입니다.
type Metric interface {
        // Name 메트릭의 이름을 반환합니다.
        Name() string
        // Type 메트릭의 타입을 반환합니다.
        Type() Type
        // Value 메트릭의 값을 반환합니다.
        Value() Value
        // Description 메트릭의 설명을 반환합니다.
        Description() string
}

// Collector 메트릭 수집기 인터페이스입니다.
type Collector interface {
        // Collect 메트릭을 수집합니다.
        Collect(ctx context.Context) ([]Metric, error)
}
</pre>

        <pre class="file" id="file10" style="display: none">package collectors

import (
        "context"
        "sync"

        "github.com/aske/go_fi_chart/services/monitoring/metrics/domain"
)

// BaseCollector 모든 컬렉터의 기본 구현을 제공합니다.
type BaseCollector struct {
        mu        sync.RWMutex
        metrics   []domain.Metric
        publisher domain.Publisher
}

// NewBaseCollector 새로운 BaseCollector를 생성합니다.
func NewBaseCollector(publisher domain.Publisher) *BaseCollector <span class="cov8" title="1">{
        return &amp;BaseCollector{
                metrics:   make([]domain.Metric, 0),
                publisher: publisher,
        }
}</span>

// AddMetric 메트릭을 추가합니다.
func (c *BaseCollector) AddMetric(metric domain.Metric) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.metrics = append(c.metrics, metric)
        return nil
}</span>

// Collect 수집된 메트릭을 반환하고 이벤트를 발행합니다.
func (c *BaseCollector) Collect(ctx context.Context) ([]domain.Metric, error) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        metrics := make([]domain.Metric, len(c.metrics))
        copy(metrics, c.metrics)

        if err := c.publisher.Publish(ctx, metrics); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">c.metrics = make([]domain.Metric, 0)
        return metrics, nil</span>
}

// Reset 수집된 메트릭을 초기화합니다.
func (c *BaseCollector) Reset() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.metrics = make([]domain.Metric, 0)
}</span>
</pre>

        <pre class="file" id="file11" style="display: none">package collectors

import (
        "github.com/aske/go_fi_chart/services/monitoring/metrics/domain"
)

// SimpleCollector 기본적인 메트릭 수집기 구현체입니다.
type SimpleCollector struct {
        *BaseCollector
}

// NewSimpleCollector 새로운 SimpleCollector를 생성합니다.
func NewSimpleCollector(publisher domain.Publisher) *SimpleCollector <span class="cov8" title="1">{
        return &amp;SimpleCollector{
                BaseCollector: NewBaseCollector(publisher),
        }
}</span>
</pre>

        <pre class="file" id="file12" style="display: none">package domain

// BaseMetric 기본 메트릭 구현체입니다.
type BaseMetric struct {
        name        string
        metricType  Type
        value       Value
        description string
}

// NewBaseMetric 새로운 BaseMetric을 생성합니다.
func NewBaseMetric(name string, metricType Type, value Value, description string) *BaseMetric <span class="cov8"
                                                                                                    title="1">{
        return &amp;BaseMetric{
                name:        name,
                metricType:  metricType,
                value:       value,
                description: description,
        }
}</span>

// Name 메트릭의 이름을 반환합니다.
func (m *BaseMetric) Name() string <span class="cov8" title="1">{
        return m.name
}</span>

// Type 메트릭의 타입을 반환합니다.
func (m *BaseMetric) Type() Type <span class="cov8" title="1">{
        return m.metricType
}</span>

// Value 메트릭의 값을 반환합니다.
func (m *BaseMetric) Value() Value <span class="cov8" title="1">{
        return m.value
}</span>

// Description 메트릭의 설명을 반환합니다.
func (m *BaseMetric) Description() string <span class="cov8" title="1">{
        return m.description
}</span>
</pre>

        <pre class="file" id="file13" style="display: none">package domain

import (
        "context"
        "time"
)

// Type 메트릭의 타입을 나타냅니다.
type Type string

const (
        // TypeCounter 카운터 타입 메트릭입니다.
        TypeCounter Type = "counter"
        // TypeGauge 게이지 타입 메트릭입니다.
        TypeGauge Type = "gauge"
        // TypeHistogram 히스토그램 타입 메트릭입니다.
        TypeHistogram Type = "histogram"
        // TypeSummary 요약 타입 메트릭입니다.
        TypeSummary Type = "summary"
)

// Value 메트릭의 값을 나타냅니다.
type Value struct {
        Raw       float64           `json:"raw"`
        Labels    map[string]string `json:"labels,omitempty"`
        Timestamp time.Time         `json:"timestamp"`
}

// NewValue 새로운 메트릭 값을 생성합니다.
func NewValue(raw float64, labels map[string]string) Value <span class="cov8" title="1">{
        return Value{
                Raw:       raw,
                Labels:    labels,
                Timestamp: time.Now(),
        }
}</span>

// WithLabel 레이블을 추가한 새로운 Value를 반환합니다.
func (v Value) WithLabel(key, value string) Value <span class="cov8" title="1">{
        newLabels := make(map[string]string, len(v.Labels)+1)
        for k, v := range v.Labels </span><span class="cov8" title="1">{
                newLabels[k] = v
        }</span>
        <span class="cov8" title="1">newLabels[key] = value
        return Value{
                Raw:       v.Raw,
                Labels:    newLabels,
                Timestamp: v.Timestamp,
        }</span>
}

// WithLabels 여러 레이블을 추가한 새로운 Value를 반환합니다.
func (v Value) WithLabels(labels map[string]string) Value <span class="cov8" title="1">{
        newLabels := make(map[string]string, len(v.Labels)+len(labels))
        for k, v := range v.Labels </span><span class="cov8" title="1">{
                newLabels[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range labels </span><span class="cov8" title="1">{
                newLabels[k] = v
        }</span>
        <span class="cov8" title="1">return Value{
                Raw:       v.Raw,
                Labels:    newLabels,
                Timestamp: v.Timestamp,
        }</span>
}

// Metric 메트릭 인터페이스입니다.
type Metric interface {
        // Name 메트릭의 이름을 반환합니다.
        Name() string
        // Type 메트릭의 타입을 반환합니다.
        Type() Type
        // Value 메트릭의 값을 반환합니다.
        Value() Value
        // Description 메트릭의 설명을 반환합니다.
        Description() string
}

// Collector 메트릭 수집기 인터페이스입니다.
type Collector interface {
        // Collect 메트릭을 수집합니다.
        Collect(ctx context.Context) ([]Metric, error)
        // AddMetric 메트릭을 추가합니다.
        AddMetric(metric Metric) error
        // Reset 수집된 메트릭을 초기화합니다.
        Reset()
}

// Publisher 메트릭 이벤트 발행자 인터페이스입니다.
type Publisher interface {
        // Publish 메트릭 이벤트를 발행합니다.
        Publish(ctx context.Context, metrics []Metric) error
}

// Event 메트릭 이벤트입니다.
type Event struct {
        Type      string
        Metrics   []Metric
        Timestamp time.Time
}

const (
        // TypeMetricCollected 메트릭 수집 이벤트 타입입니다.
        TypeMetricCollected = "metric.collected"
)
</pre>

        <pre class="file" id="file14" style="display: none">package domain

import (
        "context"
        "time"

        metricsdomain "github.com/aske/go_fi_chart/services/monitoring/metrics/domain"
)

// EventType 이벤트 타입입니다.
type EventType string

const (
        TypeMetricCollected EventType = "metric_collected"
        TypeAlertTriggered  EventType = "alert_triggered"
)

// Event 모니터링 이벤트입니다.
type Event struct {
        Type      EventType
        Timestamp time.Time
        Data      interface{}
}

// NewMonitoringEvent 새로운 모니터링 이벤트를 생성합니다.
func NewMonitoringEvent(eventType EventType, data interface{}) Event <span class="cov0" title="0">{
        return Event{
                Type:      eventType,
                Timestamp: time.Now(),
                Data:      data,
        }
}</span>

// Handler 이벤트 핸들러 인터페이스입니다.
type Handler interface {
        Handle(ctx context.Context, event Event) error
}

// Publisher 이벤트 발행자 인터페이스입니다.
type Publisher interface {
        Publish(ctx context.Context, event Event) error
        Subscribe(handler Handler) error
        Unsubscribe(handler Handler) error
}

// MetricType 메트릭의 타입을 나타냅니다.
type MetricType = metricsdomain.Type

const (
        TypeCounter   = metricsdomain.TypeCounter
        TypeGauge     = metricsdomain.TypeGauge
        TypeHistogram = metricsdomain.TypeHistogram
        TypeSummary   = metricsdomain.TypeSummary
)

// MetricValue 메트릭의 값을 나타냅니다.
type MetricValue = metricsdomain.Value

// NewMetricValue 새로운 메트릭 값을 생성합니다.
func NewMetricValue(raw float64, labels map[string]string) MetricValue <span class="cov0" title="0">{
        return metricsdomain.NewValue(raw, labels)
}</span>

// Metric 메트릭 인터페이스입니다.
type Metric = metricsdomain.Metric

// Collector 메트릭 수집기 인터페이스입니다.
type Collector = metricsdomain.Collector

// AlertLevel 알림의 심각도를 나타냅니다.
type AlertLevel string

const (
        LevelInfo     AlertLevel = "INFO"
        LevelWarning  AlertLevel = "WARNING"
        LevelError    AlertLevel = "ERROR"
        LevelCritical AlertLevel = "CRITICAL"
)

// Alert 알림을 나타냅니다.
type Alert struct {
        ID        string
        Level     AlertLevel
        Source    string
        Message   string
        Timestamp time.Time
        Metadata  map[string]string
}

// NewAlert 새로운 알림을 생성합니다.
func NewAlert(id, source, message string, level AlertLevel, metadata map[string]string) Alert <span class="cov0"
                                                                                                    title="0">{
        return Alert{
                ID:        id,
                Level:     level,
                Source:    source,
                Message:   message,
                Timestamp: time.Now(),
                Metadata:  metadata,
        }
}</span>

// Notifier 알림 처리자 인터페이스입니다.
type Notifier interface {
        Notify(ctx context.Context, alert Alert) error
}
</pre>

        <pre class="file" id="file15" style="display: none">package health

import (
        "context"
        "sync"
        "time"
)

// Status 서비스의 상태를 나타냅니다.
type Status string

const (
        StatusUp   Status = "UP"
        StatusDown Status = "DOWN"
)

// Check 헬스 체크 결과를 나타냅니다.
type Check struct {
        Status    Status    `json:"status"`
        Timestamp time.Time `json:"timestamp"`
        Error     string    `json:"error,omitempty"`
}

// Checker 서비스 상태를 체크하는 인터페이스입니다.
type Checker interface {
        // Check 현재 서비스의 상태를 확인합니다.
        Check(ctx context.Context) Check
}

// SimpleChecker 기본적인 상태 체크 구현체입니다.
type SimpleChecker struct {
        mu     sync.RWMutex
        status Status
        err    error
}

// NewSimpleChecker 새로운 SimpleChecker를 생성합니다.
func NewSimpleChecker() *SimpleChecker <span class="cov8" title="1">{
        return &amp;SimpleChecker{
                status: StatusUp,
        }
}</span>

// Check 현재 서비스의 상태를 반환합니다.
func (c *SimpleChecker) Check(_ context.Context) Check <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        var errStr string
        if c.err != nil </span><span class="cov8" title="1">{
                errStr = c.err.Error()
        }</span>

        <span class="cov8" title="1">return Check{
                Status:    c.status,
                Timestamp: time.Now(),
                Error:     errStr,
        }</span>
}

// SetStatus 서비스의 상태를 설정합니다.
func (c *SimpleChecker) SetStatus(status Status, err error) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.status = status
        c.err = err
}</span>
</pre>

</div>
</body>
<script>
        (function () {
                var files = document.getElementById('files');
                var visible;
                files.addEventListener('change', onChange, false);

                function select(part) {
                        if (visible)
                                visible.style.display = 'none';
                        visible = document.getElementById(part);
                        if (!visible)
                                return;
                        files.value = part;
                        visible.style.display = 'block';
                        location.hash = part;
                }

                function onChange() {
                        select(files.value);
                        window.scrollTo(0, 0);
                }

                if (location.hash != "") {
                        select(location.hash.substr(1));
                }
                if (!visible) {
                        select("file0");
                }
        })();
</script>
</html>
