
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>alerts: Go Coverage Report</title>
    <style>
        body {
            background: black;
            color: rgb(80, 80, 80);
        }

        body, pre, #legend span {
            font-family: Menlo, monospace;
            font-weight: bold;
        }

        #topbar {
            background: black;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 42px;
            border-bottom: 1px solid rgb(80, 80, 80);
        }

        #content {
            margin-top: 50px;
        }

        #nav, #legend {
            float: left;
            margin-left: 10px;
        }

        #legend {
            margin-top: 12px;
        }

        #nav {
            margin-top: 10px;
        }

        #legend span {
            margin: 0 5px;
        }

        .cov0 {
            color: rgb(192, 0, 0)
        }

        .cov1 {
            color: rgb(128, 128, 128)
        }

        .cov2 {
            color: rgb(116, 140, 131)
        }

        .cov3 {
            color: rgb(104, 152, 134)
        }

        .cov4 {
            color: rgb(92, 164, 137)
        }

        .cov5 {
            color: rgb(80, 176, 140)
        }

        .cov6 {
            color: rgb(68, 188, 143)
        }

        .cov7 {
            color: rgb(56, 200, 146)
        }

        .cov8 {
            color: rgb(44, 212, 149)
        }

        .cov9 {
            color: rgb(32, 224, 152)
        }

        .cov10 {
            color: rgb(20, 236, 155)
        }

    </style>
</head>
<body>
<div id="topbar">
    <div id="nav">
        <select id="files">

            <option value="file0">github.com/aske/go_fi_chart/services/monitoring/internal/alerts/alert.go (89.5%)
            </option>

            <option value="file1">github.com/aske/go_fi_chart/services/monitoring/internal/events/event.go (94.7%)
            </option>

            <option value="file2">
                github.com/aske/go_fi_chart/services/monitoring/internal/exporters/prometheus/exporter.go (93.5%)
            </option>

            <option value="file3">github.com/aske/go_fi_chart/services/monitoring/internal/metrics/collector.go
                (100.0%)
            </option>

            <option value="file4">github.com/aske/go_fi_chart/services/monitoring/internal/metrics/github/collector.go
                (100.0%)
            </option>

            <option value="file5">github.com/aske/go_fi_chart/services/monitoring/pkg/health/checker.go (100.0%)
            </option>

        </select>
    </div>
    <div id="legend">
        <span>not tracked</span>

        <span class="cov0">not covered</span>
        <span class="cov8">covered</span>

    </div>
</div>
<div id="content">
		
		<pre class="file" id="file0" style="display: none">package alerts

import (
        "context"
        "sync"
        "time"

        "github.com/aske/go_fi_chart/internal/domain"
        "github.com/aske/go_fi_chart/services/monitoring/internal/events"
)

// AlertLevel 알림의 심각도를 나타냅니다.
type AlertLevel string

const (
        LevelInfo     AlertLevel = "INFO"
        LevelWarning  AlertLevel = "WARNING"
        LevelError    AlertLevel = "ERROR"
        LevelCritical AlertLevel = "CRITICAL"
)

// Alert 모니터링 시스템의 알림을 나타냅니다.
type Alert struct {
        ID        string            `json:"id"`
        Level     AlertLevel        `json:"level"`
        Source    string            `json:"source"`
        Message   string            `json:"message"`
        Timestamp time.Time         `json:"timestamp"`
        Metadata  map[string]string `json:"metadata,omitempty"`
}

// Notifier 알림을 처리하는 인터페이스입니다.
type Notifier interface {
        Notify(ctx context.Context, alert Alert) error
}

// SimpleNotifier 기본적인 알림 처리자 구현체입니다.
type SimpleNotifier struct {
        mu        sync.RWMutex
        publisher events.Publisher
        handlers  []Notifier
}

// NewSimpleNotifier 새로운 SimpleNotifier를 생성합니다.
func NewSimpleNotifier(publisher events.Publisher) *SimpleNotifier <span class="cov8" title="1">{
        return &amp;SimpleNotifier{
                publisher: publisher,
                handlers:  make([]Notifier, 0),
        }
}</span>

// AddHandler 알림 핸들러를 추가합니다.
func (n *SimpleNotifier) AddHandler(handler Notifier) <span class="cov8" title="1">{
        n.mu.Lock()
        defer n.mu.Unlock()
        n.handlers = append(n.handlers, handler)
}</span>

// RemoveHandler 알림 핸들러를 제거합니다.
func (n *SimpleNotifier) RemoveHandler(handler Notifier) <span class="cov8" title="1">{
        n.mu.Lock()
        defer n.mu.Unlock()
        for i, h := range n.handlers </span><span class="cov8" title="1">{
                if h == handler </span><span class="cov8" title="1">{
                        n.handlers = append(n.handlers[:i], n.handlers[i+1:]...)
                        break</span>
                }
        }
}

// Notify 알림을 처리하고 이벤트를 발행합니다.
func (n *SimpleNotifier) Notify(ctx context.Context, alert Alert) error <span class="cov8" title="1">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        // 모든 핸들러에게 알림 전달
        for _, handler := range n.handlers </span><span class="cov8" title="1">{
                if err := handler.Notify(ctx, alert); err != nil </span><span class="cov0" title="0">{
                        // 에러가 발생해도 다른 핸들러는 계속 실행
                        continue</span>
                }
        }

        // 알림 이벤트 발행
        <span class="cov8" title="1">event := events.NewMonitoringEvent(
                events.TypeAlertTriggered,
                alert.Source,
                alert,
                alert.Metadata,
        )

        if err := n.publisher.Publish(ctx, event); err != nil </span><span class="cov0" title="0">{
                return domain.NewError("alerts", domain.ErrCodeInternal, "알림 이벤트 발행 실패")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>

    <pre class="file" id="file1" style="display: none">package events

import (
        "context"
        "sync"
        "time"

        "github.com/aske/go_fi_chart/internal/domain"
        "github.com/aske/go_fi_chart/services/monitoring/internal/metrics"
)

// MetricPayload 메트릭 수집 이벤트의 페이로드입니다.
type MetricPayload struct {
        Metrics []metrics.Metric `json:"metrics"`
}

// MonitoringEvent 모니터링 시스템의 이벤트입니다.
type MonitoringEvent struct {
        domain.BaseEvent
}

// NewMonitoringEvent 새로운 모니터링 이벤트를 생성합니다.
func NewMonitoringEvent(eventType string, source string, payload interface{}, metadata map[string]string) domain.Event <span
                class="cov8" title="1">{
        return &amp;MonitoringEvent{
                BaseEvent: domain.BaseEvent{
                        Type: eventType,
                        Time: time.Now(),
                        Data: payload,
                        Src:  source,
                        Meta: metadata,
                },
        }
}</span>

// Handler 이벤트를 처리하는 핸들러입니다.
type Handler interface {
        Handle(ctx context.Context, event domain.Event) error
}

// Publisher 이벤트를 발행하는 인터페이스입니다.
type Publisher interface {
        Publish(ctx context.Context, event domain.Event) error
        Subscribe(handler Handler) error
        Unsubscribe(handler Handler) error
}

// SimplePublisher 기본적인 이벤트 발행자 구현체입니다.
type SimplePublisher struct {
        mu       sync.RWMutex
        handlers []Handler
}

// NewSimplePublisher 새로운 SimplePublisher를 생성합니다.
func NewSimplePublisher() *SimplePublisher <span class="cov8" title="1">{
        return &amp;SimplePublisher{
                handlers: make([]Handler, 0),
        }
}</span>

// Publish 이벤트를 발행합니다.
func (p *SimplePublisher) Publish(ctx context.Context, event domain.Event) error <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        for _, handler := range p.handlers </span><span class="cov8" title="1">{
                if err := handler.Handle(ctx, event); err != nil </span><span class="cov0" title="0">{
                        // 에러가 발생해도 다른 핸들러는 계속 실행
                        continue</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// Subscribe 이벤트 핸들러를 등록합니다.
func (p *SimplePublisher) Subscribe(handler Handler) error <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        p.handlers = append(p.handlers, handler)
        return nil
}</span>

// Unsubscribe 이벤트 핸들러를 제거합니다.
func (p *SimplePublisher) Unsubscribe(handler Handler) error <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        for i, h := range p.handlers </span><span class="cov8" title="1">{
                if h == handler </span><span class="cov8" title="1">{
                        p.handlers = append(p.handlers[:i], p.handlers[i+1:]...)
                        break</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// 이벤트 타입 상수
const (
        TypeMetricCollected = "METRIC_COLLECTED"
        TypeAlertTriggered  = "ALERT_TRIGGERED"
)
</pre>

    <pre class="file" id="file2" style="display: none">package prometheus

import (
        "context"
        "fmt"
        "sync"

        "github.com/aske/go_fi_chart/services/monitoring/internal/metrics"
        "github.com/prometheus/client_golang/prometheus"
)

// Exporter Prometheus 익스포터 구현체입니다.
type Exporter struct {
        mu       sync.RWMutex
        registry *prometheus.Registry
        metrics  map[string]prometheus.Collector
}

// NewExporter 새로운 Exporter를 생성합니다.
func NewExporter() *Exporter <span class="cov8" title="1">{
        return &amp;Exporter{
                registry: prometheus.NewRegistry(),
                metrics:  make(map[string]prometheus.Collector),
        }
}</span>

// Export 메트릭을 Prometheus 형식으로 변환하여 등록합니다.
func (e *Exporter) Export(_ context.Context, metrics []metrics.Metric) error <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()

        for _, m := range metrics </span><span class="cov8" title="1">{
                collector, err := e.getOrCreateCollector(m)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("메트릭 컬렉터 생성 실패: %w", err)
                }</span>

                <span class="cov8" title="1">switch m.Type </span>{
                case "counter":<span class="cov8" title="1">
                        if counter, ok := collector.(prometheus.Counter); ok </span><span class="cov8" title="1">{
                                counter.Add(m.Value)
                        }</span>
                case "gauge":<span class="cov8" title="1">
                        if gauge, ok := collector.(prometheus.Gauge); ok </span><span class="cov8" title="1">{
                                gauge.Set(m.Value)
                        }</span>
                case "histogram":<span class="cov8" title="1">
                        if histogram, ok := collector.(prometheus.Histogram); ok </span><span class="cov8" title="1">{
                                histogram.Observe(m.Value)
                        }</span>
                case "summary":<span class="cov8" title="1">
                        if summary, ok := collector.(prometheus.Summary); ok </span><span class="cov8" title="1">{
                                summary.Observe(m.Value)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// GetRegistry Prometheus 레지스트리를 반환합니다.
func (e *Exporter) GetRegistry() *prometheus.Registry <span class="cov0" title="0">{
        return e.registry
}</span>

// getOrCreateCollector 메트릭에 대한 Prometheus 컬렉터를 반환하거나 생성합니다.
func (e *Exporter) getOrCreateCollector(m metrics.Metric) (prometheus.Collector, error) <span class="cov8" title="1">{
        if collector, exists := e.metrics[m.Name]; exists </span><span class="cov8" title="1">{
                return collector, nil
        }</span>

        <span class="cov8" title="1">var collector prometheus.Collector

        switch m.Type </span>{
        case "counter":<span class="cov8" title="1">
                collector = prometheus.NewCounter(prometheus.CounterOpts{
                        Name: m.Name,
                        Help: m.Description,
                })</span>
        case "gauge":<span class="cov8" title="1">
                collector = prometheus.NewGauge(prometheus.GaugeOpts{
                        Name: m.Name,
                        Help: m.Description,
                })</span>
        case "histogram":<span class="cov8" title="1">
                collector = prometheus.NewHistogram(prometheus.HistogramOpts{
                        Name: m.Name,
                        Help: m.Description,
                })</span>
        case "summary":<span class="cov8" title="1">
                collector = prometheus.NewSummary(prometheus.SummaryOpts{
                        Name: m.Name,
                        Help: m.Description,
                })</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("지원하지 않는 메트릭 타입: %s", m.Type)</span>
        }

        <span class="cov8" title="1">if err := e.registry.Register(collector); err != nil </span><span class="cov0"
                                                                                                       title="0">{
                return nil, fmt.Errorf("메트릭 등록 실패: %w", err)
        }</span>

        <span class="cov8" title="1">e.metrics[m.Name] = collector
        return collector, nil</span>
}
</pre>

    <pre class="file" id="file3" style="display: none">package metrics

import (
        "context"
        "sync"
        "time"
)

// MetricType 메트릭의 타입을 나타냅니다.
type MetricType string

const (
        TypeCounter   MetricType = "counter"
        TypeGauge     MetricType = "gauge"
        TypeHistogram MetricType = "histogram"
        TypeSummary   MetricType = "summary"
)

// Metric 모니터링 시스템의 메트릭을 나타냅니다.
type Metric struct {
        Name        string            `json:"name"`
        Type        MetricType        `json:"type"`
        Value       float64           `json:"value"`
        Labels      map[string]string `json:"labels,omitempty"`
        Timestamp   time.Time         `json:"timestamp"`
        Description string            `json:"description"`
}

// Collector 메트릭을 수집하는 인터페이스입니다.
type Collector interface {
        // Collect 메트릭을 수집합니다.
        Collect(ctx context.Context) ([]Metric, error)
}

// SimpleCollector 기본적인 메트릭 수집기 구현체입니다.
type SimpleCollector struct {
        mu      sync.RWMutex
        metrics []Metric
}

// NewSimpleCollector 새로운 SimpleCollector를 생성합니다.
func NewSimpleCollector() *SimpleCollector <span class="cov8" title="1">{
        return &amp;SimpleCollector{
                metrics: make([]Metric, 0),
        }
}</span>

// Collect 수집된 메트릭을 반환합니다.
func (c *SimpleCollector) Collect(_ context.Context) ([]Metric, error) <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.metrics, nil
}</span>

// AddMetric 메트릭을 추가합니다.
func (c *SimpleCollector) AddMetric(metric Metric) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if metric.Timestamp.IsZero() </span><span class="cov8" title="1">{
                metric.Timestamp = time.Now()
        }</span>
        <span class="cov8" title="1">c.metrics = append(c.metrics, metric)</span>
}

// Reset 수집된 메트릭을 초기화합니다.
func (c *SimpleCollector) Reset() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.metrics = make([]Metric, 0)
}</span>
</pre>

    <pre class="file" id="file4" style="display: none">package github

import (
        "context"
        "time"

        "github.com/aske/go_fi_chart/services/monitoring/internal/metrics"
)

// ActionStatus GitHub Actions의 실행 상태를 나타냅니다.
type ActionStatus string

const (
        StatusSuccess ActionStatus = "success"
        StatusFailure ActionStatus = "failure"
        StatusRunning ActionStatus = "running"
)

// ActionMetric GitHub Actions 실행 메트릭을 나타냅니다.
type ActionMetric struct {
        WorkflowName string
        Status       ActionStatus
        Duration     time.Duration
        StartedAt    time.Time
        FinishedAt   time.Time
}

// ActionCollector GitHub Actions 메트릭을 수집하는 컬렉터입니다.
type ActionCollector struct {
        baseCollector *metrics.SimpleCollector
}

// NewActionCollector 새로운 GitHub Actions 메트릭 컬렉터를 생성합니다.
func NewActionCollector() *ActionCollector <span class="cov8" title="1">{
        return &amp;ActionCollector{
                baseCollector: metrics.NewSimpleCollector(),
        }
}</span>

// Collect GitHub Actions 메트릭을 수집합니다.
func (c *ActionCollector) Collect(ctx context.Context) ([]metrics.Metric, error) <span class="cov8" title="1">{
        return c.baseCollector.Collect(ctx)
}</span>

// AddActionMetric GitHub Actions 메트릭을 추가합니다.
func (c *ActionCollector) AddActionMetric(actionMetric ActionMetric) <span class="cov8" title="1">{
        c.baseCollector.AddMetric(metrics.Metric{
                Name:  "github_action_duration_seconds",
                Type:  metrics.TypeGauge,
                Value: actionMetric.Duration.Seconds(),
                Labels: map[string]string{
                        "workflow": actionMetric.WorkflowName,
                        "status":   string(actionMetric.Status),
                },
                Timestamp: actionMetric.FinishedAt,
        })

        c.baseCollector.AddMetric(metrics.Metric{
                Name: "github_action_status",
                Type: metrics.TypeGauge,
                Value: map[ActionStatus]float64{
                        StatusSuccess: 1.0,
                        StatusFailure: 0.0,
                        StatusRunning: 0.5,
                }[actionMetric.Status],
                Labels: map[string]string{
                        "workflow": actionMetric.WorkflowName,
                },
                Timestamp: actionMetric.FinishedAt,
        })
}</span>
</pre>

    <pre class="file" id="file5" style="display: none">package health

import (
        "context"
        "sync"
        "time"
)

// Status 서비스의 상태를 나타냅니다.
type Status string

const (
        StatusUp   Status = "UP"
        StatusDown Status = "DOWN"
)

// Check 헬스 체크 결과를 나타냅니다.
type Check struct {
        Status    Status    `json:"status"`
        Timestamp time.Time `json:"timestamp"`
        Error     string    `json:"error,omitempty"`
}

// Checker 서비스 상태를 체크하는 인터페이스입니다.
type Checker interface {
        // Check 현재 서비스의 상태를 확인합니다.
        Check(ctx context.Context) Check
}

// SimpleChecker 기본적인 상태 체크 구현체입니다.
type SimpleChecker struct {
        mu     sync.RWMutex
        status Status
        err    error
}

// NewSimpleChecker 새로운 SimpleChecker를 생성합니다.
func NewSimpleChecker() *SimpleChecker <span class="cov8" title="1">{
        return &amp;SimpleChecker{
                status: StatusUp,
        }
}</span>

// Check 현재 서비스의 상태를 반환합니다.
func (c *SimpleChecker) Check(_ context.Context) Check <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        var errStr string
        if c.err != nil </span><span class="cov8" title="1">{
                errStr = c.err.Error()
        }</span>

        <span class="cov8" title="1">return Check{
                Status:    c.status,
                Timestamp: time.Now(),
                Error:     errStr,
        }</span>
}

// SetStatus 서비스의 상태를 설정합니다.
func (c *SimpleChecker) SetStatus(status Status, err error) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.status = status
        c.err = err
}</span>
</pre>

</div>
</body>
<script>
    (function () {
        var files = document.getElementById('files');
        var visible;
        files.addEventListener('change', onChange, false);

        function select(part) {
            if (visible)
                visible.style.display = 'none';
            visible = document.getElementById(part);
            if (!visible)
                return;
            files.value = part;
            visible.style.display = 'block';
            location.hash = part;
        }

        function onChange() {
            select(files.value);
            window.scrollTo(0, 0);
        }

        if (location.hash != "") {
            select(location.hash.substr(1));
        }
        if (!visible) {
            select("file0");
        }
    })();
</script>
</html>
